
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model Overtime
 * 
 */
export type Overtime = $Result.DefaultSelection<Prisma.$OvertimePayload>
/**
 * Model AttendanceSummary
 * 
 */
export type AttendanceSummary = $Result.DefaultSelection<Prisma.$AttendanceSummaryPayload>
/**
 * Model Payroll
 * 
 */
export type Payroll = $Result.DefaultSelection<Prisma.$PayrollPayload>
/**
 * Model PayrollExport
 * 
 */
export type PayrollExport = $Result.DefaultSelection<Prisma.$PayrollExportPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model PeriodClosure
 * 
 */
export type PeriodClosure = $Result.DefaultSelection<Prisma.$PeriodClosurePayload>
/**
 * Model SchoolClass
 * 
 */
export type SchoolClass = $Result.DefaultSelection<Prisma.$SchoolClassPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model StudentAttendance
 * 
 */
export type StudentAttendance = $Result.DefaultSelection<Prisma.$StudentAttendancePayload>
/**
 * Model ConstructionSite
 * 
 */
export type ConstructionSite = $Result.DefaultSelection<Prisma.$ConstructionSitePayload>
/**
 * Model ConstructionTeam
 * 
 */
export type ConstructionTeam = $Result.DefaultSelection<Prisma.$ConstructionTeamPayload>
/**
 * Model ConstructionWorker
 * 
 */
export type ConstructionWorker = $Result.DefaultSelection<Prisma.$ConstructionWorkerPayload>
/**
 * Model SiteAttendance
 * 
 */
export type SiteAttendance = $Result.DefaultSelection<Prisma.$SiteAttendancePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model UserRole
 * New RBAC table to replace Role[] progressively (non-breaking).
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Person
 * Person identity layer shared by employee/student/worker profiles.
 */
export type Person = $Result.DefaultSelection<Prisma.$PersonPayload>
/**
 * Model Employee
 * Employee profile used by HR/Payroll, linked to Person and optionally User.
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Worker
 * Worker profile for long-term architecture (kept separate from ConstructionWorker).
 */
export type Worker = $Result.DefaultSelection<Prisma.$WorkerPayload>
/**
 * Model AttendanceEvent
 * Unified attendance event stream (non-breaking; legacy Attendance preserved).
 */
export type AttendanceEvent = $Result.DefaultSelection<Prisma.$AttendanceEventPayload>
/**
 * Model AttendanceDailySummary
 * Daily summary for attendance status (separate from payroll AttendanceSummary).
 */
export type AttendanceDailySummary = $Result.DefaultSelection<Prisma.$AttendanceDailySummaryPayload>
/**
 * Model Device
 * Devices used for anti-fraud or attendance capture.
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model LeaveType
 * Leave configuration per company.
 */
export type LeaveType = $Result.DefaultSelection<Prisma.$LeaveTypePayload>
/**
 * Model LeaveBalance
 * Leave balance per employee/year.
 */
export type LeaveBalance = $Result.DefaultSelection<Prisma.$LeaveBalancePayload>
/**
 * Model LeaveRequest
 * Leave request workflow.
 */
export type LeaveRequest = $Result.DefaultSelection<Prisma.$LeaveRequestPayload>
/**
 * Model PublicHoliday
 * Public holidays (global or company-specific).
 */
export type PublicHoliday = $Result.DefaultSelection<Prisma.$PublicHolidayPayload>
/**
 * Model Contract
 * Employee contract and base salary definition.
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model PayrollPeriod
 * Payroll period (monthly closure).
 */
export type PayrollPeriod = $Result.DefaultSelection<Prisma.$PayrollPeriodPayload>
/**
 * Model PayrollLine
 * Payroll line item per employee and period.
 */
export type PayrollLine = $Result.DefaultSelection<Prisma.$PayrollLinePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  RH: 'RH',
  MANAGER: 'MANAGER',
  EMPLOYEE: 'EMPLOYEE',
  TEACHER: 'TEACHER',
  SITE_MANAGER: 'SITE_MANAGER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const OvertimeStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type OvertimeStatus = (typeof OvertimeStatus)[keyof typeof OvertimeStatus]


export const PayrollStatus: {
  DRAFT: 'DRAFT',
  FINALIZED: 'FINALIZED',
  PAID: 'PAID'
};

export type PayrollStatus = (typeof PayrollStatus)[keyof typeof PayrollStatus]


export const ExportFormat: {
  CSV: 'CSV',
  PDF: 'PDF'
};

export type ExportFormat = (typeof ExportFormat)[keyof typeof ExportFormat]


export const ReportType: {
  ATTENDANCE: 'ATTENDANCE',
  PAYROLL: 'PAYROLL',
  OVERTIME: 'OVERTIME'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]


export const StudentAttendanceStatus: {
  PRESENT: 'PRESENT',
  LATE: 'LATE',
  ABSENT: 'ABSENT'
};

export type StudentAttendanceStatus = (typeof StudentAttendanceStatus)[keyof typeof StudentAttendanceStatus]


export const CompanyType: {
  CORPORATE: 'CORPORATE',
  SCHOOL: 'SCHOOL',
  CONSTRUCTION: 'CONSTRUCTION'
};

export type CompanyType = (typeof CompanyType)[keyof typeof CompanyType]


export const PersonType: {
  EMPLOYEE: 'EMPLOYEE',
  STUDENT: 'STUDENT',
  WORKER: 'WORKER'
};

export type PersonType = (typeof PersonType)[keyof typeof PersonType]


export const AttendanceType: {
  CHECK_IN: 'CHECK_IN',
  CHECK_OUT: 'CHECK_OUT'
};

export type AttendanceType = (typeof AttendanceType)[keyof typeof AttendanceType]


export const AttendanceStatus: {
  ON_TIME: 'ON_TIME',
  LATE: 'LATE',
  EARLY_LEAVE: 'EARLY_LEAVE',
  ABSENT: 'ABSENT',
  HOLIDAY: 'HOLIDAY',
  SICK_LEAVE: 'SICK_LEAVE'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const SalaryType: {
  MONTHLY: 'MONTHLY',
  HOURLY: 'HOURLY'
};

export type SalaryType = (typeof SalaryType)[keyof typeof SalaryType]


export const LeaveStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type LeaveStatus = (typeof LeaveStatus)[keyof typeof LeaveStatus]


export const AuditAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const AuditEntity: {
  USER: 'USER',
  ATTENDANCE: 'ATTENDANCE',
  PAYROLL: 'PAYROLL'
};

export type AuditEntity = (typeof AuditEntity)[keyof typeof AuditEntity]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type OvertimeStatus = $Enums.OvertimeStatus

export const OvertimeStatus: typeof $Enums.OvertimeStatus

export type PayrollStatus = $Enums.PayrollStatus

export const PayrollStatus: typeof $Enums.PayrollStatus

export type ExportFormat = $Enums.ExportFormat

export const ExportFormat: typeof $Enums.ExportFormat

export type ReportType = $Enums.ReportType

export const ReportType: typeof $Enums.ReportType

export type StudentAttendanceStatus = $Enums.StudentAttendanceStatus

export const StudentAttendanceStatus: typeof $Enums.StudentAttendanceStatus

export type CompanyType = $Enums.CompanyType

export const CompanyType: typeof $Enums.CompanyType

export type PersonType = $Enums.PersonType

export const PersonType: typeof $Enums.PersonType

export type AttendanceType = $Enums.AttendanceType

export const AttendanceType: typeof $Enums.AttendanceType

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type SalaryType = $Enums.SalaryType

export const SalaryType: typeof $Enums.SalaryType

export type LeaveStatus = $Enums.LeaveStatus

export const LeaveStatus: typeof $Enums.LeaveStatus

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type AuditEntity = $Enums.AuditEntity

export const AuditEntity: typeof $Enums.AuditEntity

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.overtime`: Exposes CRUD operations for the **Overtime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Overtimes
    * const overtimes = await prisma.overtime.findMany()
    * ```
    */
  get overtime(): Prisma.OvertimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceSummary`: Exposes CRUD operations for the **AttendanceSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceSummaries
    * const attendanceSummaries = await prisma.attendanceSummary.findMany()
    * ```
    */
  get attendanceSummary(): Prisma.AttendanceSummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payroll`: Exposes CRUD operations for the **Payroll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payrolls
    * const payrolls = await prisma.payroll.findMany()
    * ```
    */
  get payroll(): Prisma.PayrollDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payrollExport`: Exposes CRUD operations for the **PayrollExport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollExports
    * const payrollExports = await prisma.payrollExport.findMany()
    * ```
    */
  get payrollExport(): Prisma.PayrollExportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.periodClosure`: Exposes CRUD operations for the **PeriodClosure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PeriodClosures
    * const periodClosures = await prisma.periodClosure.findMany()
    * ```
    */
  get periodClosure(): Prisma.PeriodClosureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schoolClass`: Exposes CRUD operations for the **SchoolClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolClasses
    * const schoolClasses = await prisma.schoolClass.findMany()
    * ```
    */
  get schoolClass(): Prisma.SchoolClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentAttendance`: Exposes CRUD operations for the **StudentAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentAttendances
    * const studentAttendances = await prisma.studentAttendance.findMany()
    * ```
    */
  get studentAttendance(): Prisma.StudentAttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.constructionSite`: Exposes CRUD operations for the **ConstructionSite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConstructionSites
    * const constructionSites = await prisma.constructionSite.findMany()
    * ```
    */
  get constructionSite(): Prisma.ConstructionSiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.constructionTeam`: Exposes CRUD operations for the **ConstructionTeam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConstructionTeams
    * const constructionTeams = await prisma.constructionTeam.findMany()
    * ```
    */
  get constructionTeam(): Prisma.ConstructionTeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.constructionWorker`: Exposes CRUD operations for the **ConstructionWorker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConstructionWorkers
    * const constructionWorkers = await prisma.constructionWorker.findMany()
    * ```
    */
  get constructionWorker(): Prisma.ConstructionWorkerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteAttendance`: Exposes CRUD operations for the **SiteAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteAttendances
    * const siteAttendances = await prisma.siteAttendance.findMany()
    * ```
    */
  get siteAttendance(): Prisma.SiteAttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): Prisma.PersonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.worker`: Exposes CRUD operations for the **Worker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workers
    * const workers = await prisma.worker.findMany()
    * ```
    */
  get worker(): Prisma.WorkerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceEvent`: Exposes CRUD operations for the **AttendanceEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceEvents
    * const attendanceEvents = await prisma.attendanceEvent.findMany()
    * ```
    */
  get attendanceEvent(): Prisma.AttendanceEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceDailySummary`: Exposes CRUD operations for the **AttendanceDailySummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceDailySummaries
    * const attendanceDailySummaries = await prisma.attendanceDailySummary.findMany()
    * ```
    */
  get attendanceDailySummary(): Prisma.AttendanceDailySummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaveType`: Exposes CRUD operations for the **LeaveType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveTypes
    * const leaveTypes = await prisma.leaveType.findMany()
    * ```
    */
  get leaveType(): Prisma.LeaveTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaveBalance`: Exposes CRUD operations for the **LeaveBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveBalances
    * const leaveBalances = await prisma.leaveBalance.findMany()
    * ```
    */
  get leaveBalance(): Prisma.LeaveBalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaveRequest`: Exposes CRUD operations for the **LeaveRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveRequests
    * const leaveRequests = await prisma.leaveRequest.findMany()
    * ```
    */
  get leaveRequest(): Prisma.LeaveRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publicHoliday`: Exposes CRUD operations for the **PublicHoliday** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PublicHolidays
    * const publicHolidays = await prisma.publicHoliday.findMany()
    * ```
    */
  get publicHoliday(): Prisma.PublicHolidayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payrollPeriod`: Exposes CRUD operations for the **PayrollPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollPeriods
    * const payrollPeriods = await prisma.payrollPeriod.findMany()
    * ```
    */
  get payrollPeriod(): Prisma.PayrollPeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payrollLine`: Exposes CRUD operations for the **PayrollLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollLines
    * const payrollLines = await prisma.payrollLine.findMany()
    * ```
    */
  get payrollLine(): Prisma.PayrollLineDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    User: 'User',
    Attendance: 'Attendance',
    Schedule: 'Schedule',
    Overtime: 'Overtime',
    AttendanceSummary: 'AttendanceSummary',
    Payroll: 'Payroll',
    PayrollExport: 'PayrollExport',
    Report: 'Report',
    PeriodClosure: 'PeriodClosure',
    SchoolClass: 'SchoolClass',
    Course: 'Course',
    Student: 'Student',
    StudentAttendance: 'StudentAttendance',
    ConstructionSite: 'ConstructionSite',
    ConstructionTeam: 'ConstructionTeam',
    ConstructionWorker: 'ConstructionWorker',
    SiteAttendance: 'SiteAttendance',
    AuditLog: 'AuditLog',
    UserRole: 'UserRole',
    Person: 'Person',
    Employee: 'Employee',
    Worker: 'Worker',
    AttendanceEvent: 'AttendanceEvent',
    AttendanceDailySummary: 'AttendanceDailySummary',
    Device: 'Device',
    LeaveType: 'LeaveType',
    LeaveBalance: 'LeaveBalance',
    LeaveRequest: 'LeaveRequest',
    PublicHoliday: 'PublicHoliday',
    Contract: 'Contract',
    PayrollPeriod: 'PayrollPeriod',
    PayrollLine: 'PayrollLine'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "company" | "user" | "attendance" | "schedule" | "overtime" | "attendanceSummary" | "payroll" | "payrollExport" | "report" | "periodClosure" | "schoolClass" | "course" | "student" | "studentAttendance" | "constructionSite" | "constructionTeam" | "constructionWorker" | "siteAttendance" | "auditLog" | "userRole" | "person" | "employee" | "worker" | "attendanceEvent" | "attendanceDailySummary" | "device" | "leaveType" | "leaveBalance" | "leaveRequest" | "publicHoliday" | "contract" | "payrollPeriod" | "payrollLine"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      Overtime: {
        payload: Prisma.$OvertimePayload<ExtArgs>
        fields: Prisma.OvertimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OvertimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OvertimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          findFirst: {
            args: Prisma.OvertimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OvertimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          findMany: {
            args: Prisma.OvertimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>[]
          }
          create: {
            args: Prisma.OvertimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          createMany: {
            args: Prisma.OvertimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OvertimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>[]
          }
          delete: {
            args: Prisma.OvertimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          update: {
            args: Prisma.OvertimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          deleteMany: {
            args: Prisma.OvertimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OvertimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OvertimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>[]
          }
          upsert: {
            args: Prisma.OvertimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          aggregate: {
            args: Prisma.OvertimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOvertime>
          }
          groupBy: {
            args: Prisma.OvertimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<OvertimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OvertimeCountArgs<ExtArgs>
            result: $Utils.Optional<OvertimeCountAggregateOutputType> | number
          }
        }
      }
      AttendanceSummary: {
        payload: Prisma.$AttendanceSummaryPayload<ExtArgs>
        fields: Prisma.AttendanceSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          findFirst: {
            args: Prisma.AttendanceSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          findMany: {
            args: Prisma.AttendanceSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>[]
          }
          create: {
            args: Prisma.AttendanceSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          createMany: {
            args: Prisma.AttendanceSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceSummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>[]
          }
          delete: {
            args: Prisma.AttendanceSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          update: {
            args: Prisma.AttendanceSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceSummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          aggregate: {
            args: Prisma.AttendanceSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceSummary>
          }
          groupBy: {
            args: Prisma.AttendanceSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceSummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceSummaryCountAggregateOutputType> | number
          }
        }
      }
      Payroll: {
        payload: Prisma.$PayrollPayload<ExtArgs>
        fields: Prisma.PayrollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findFirst: {
            args: Prisma.PayrollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findMany: {
            args: Prisma.PayrollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          create: {
            args: Prisma.PayrollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          createMany: {
            args: Prisma.PayrollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          delete: {
            args: Prisma.PayrollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          update: {
            args: Prisma.PayrollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          deleteMany: {
            args: Prisma.PayrollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          upsert: {
            args: Prisma.PayrollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          aggregate: {
            args: Prisma.PayrollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayroll>
          }
          groupBy: {
            args: Prisma.PayrollGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollCountAggregateOutputType> | number
          }
        }
      }
      PayrollExport: {
        payload: Prisma.$PayrollExportPayload<ExtArgs>
        fields: Prisma.PayrollExportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollExportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollExportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollExportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollExportPayload>
          }
          findFirst: {
            args: Prisma.PayrollExportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollExportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollExportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollExportPayload>
          }
          findMany: {
            args: Prisma.PayrollExportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollExportPayload>[]
          }
          create: {
            args: Prisma.PayrollExportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollExportPayload>
          }
          createMany: {
            args: Prisma.PayrollExportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollExportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollExportPayload>[]
          }
          delete: {
            args: Prisma.PayrollExportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollExportPayload>
          }
          update: {
            args: Prisma.PayrollExportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollExportPayload>
          }
          deleteMany: {
            args: Prisma.PayrollExportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollExportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollExportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollExportPayload>[]
          }
          upsert: {
            args: Prisma.PayrollExportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollExportPayload>
          }
          aggregate: {
            args: Prisma.PayrollExportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollExport>
          }
          groupBy: {
            args: Prisma.PayrollExportGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollExportGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollExportCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollExportCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      PeriodClosure: {
        payload: Prisma.$PeriodClosurePayload<ExtArgs>
        fields: Prisma.PeriodClosureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PeriodClosureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodClosurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PeriodClosureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodClosurePayload>
          }
          findFirst: {
            args: Prisma.PeriodClosureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodClosurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PeriodClosureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodClosurePayload>
          }
          findMany: {
            args: Prisma.PeriodClosureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodClosurePayload>[]
          }
          create: {
            args: Prisma.PeriodClosureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodClosurePayload>
          }
          createMany: {
            args: Prisma.PeriodClosureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PeriodClosureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodClosurePayload>[]
          }
          delete: {
            args: Prisma.PeriodClosureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodClosurePayload>
          }
          update: {
            args: Prisma.PeriodClosureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodClosurePayload>
          }
          deleteMany: {
            args: Prisma.PeriodClosureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PeriodClosureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PeriodClosureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodClosurePayload>[]
          }
          upsert: {
            args: Prisma.PeriodClosureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodClosurePayload>
          }
          aggregate: {
            args: Prisma.PeriodClosureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePeriodClosure>
          }
          groupBy: {
            args: Prisma.PeriodClosureGroupByArgs<ExtArgs>
            result: $Utils.Optional<PeriodClosureGroupByOutputType>[]
          }
          count: {
            args: Prisma.PeriodClosureCountArgs<ExtArgs>
            result: $Utils.Optional<PeriodClosureCountAggregateOutputType> | number
          }
        }
      }
      SchoolClass: {
        payload: Prisma.$SchoolClassPayload<ExtArgs>
        fields: Prisma.SchoolClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolClassPayload>
          }
          findFirst: {
            args: Prisma.SchoolClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolClassPayload>
          }
          findMany: {
            args: Prisma.SchoolClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolClassPayload>[]
          }
          create: {
            args: Prisma.SchoolClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolClassPayload>
          }
          createMany: {
            args: Prisma.SchoolClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolClassPayload>[]
          }
          delete: {
            args: Prisma.SchoolClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolClassPayload>
          }
          update: {
            args: Prisma.SchoolClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolClassPayload>
          }
          deleteMany: {
            args: Prisma.SchoolClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolClassPayload>[]
          }
          upsert: {
            args: Prisma.SchoolClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolClassPayload>
          }
          aggregate: {
            args: Prisma.SchoolClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolClass>
          }
          groupBy: {
            args: Prisma.SchoolClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolClassCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolClassCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      StudentAttendance: {
        payload: Prisma.$StudentAttendancePayload<ExtArgs>
        fields: Prisma.StudentAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          findFirst: {
            args: Prisma.StudentAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          findMany: {
            args: Prisma.StudentAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>[]
          }
          create: {
            args: Prisma.StudentAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          createMany: {
            args: Prisma.StudentAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentAttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>[]
          }
          delete: {
            args: Prisma.StudentAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          update: {
            args: Prisma.StudentAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          deleteMany: {
            args: Prisma.StudentAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentAttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>[]
          }
          upsert: {
            args: Prisma.StudentAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          aggregate: {
            args: Prisma.StudentAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentAttendance>
          }
          groupBy: {
            args: Prisma.StudentAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<StudentAttendanceCountAggregateOutputType> | number
          }
        }
      }
      ConstructionSite: {
        payload: Prisma.$ConstructionSitePayload<ExtArgs>
        fields: Prisma.ConstructionSiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConstructionSiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionSitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConstructionSiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionSitePayload>
          }
          findFirst: {
            args: Prisma.ConstructionSiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionSitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConstructionSiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionSitePayload>
          }
          findMany: {
            args: Prisma.ConstructionSiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionSitePayload>[]
          }
          create: {
            args: Prisma.ConstructionSiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionSitePayload>
          }
          createMany: {
            args: Prisma.ConstructionSiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConstructionSiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionSitePayload>[]
          }
          delete: {
            args: Prisma.ConstructionSiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionSitePayload>
          }
          update: {
            args: Prisma.ConstructionSiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionSitePayload>
          }
          deleteMany: {
            args: Prisma.ConstructionSiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConstructionSiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConstructionSiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionSitePayload>[]
          }
          upsert: {
            args: Prisma.ConstructionSiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionSitePayload>
          }
          aggregate: {
            args: Prisma.ConstructionSiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConstructionSite>
          }
          groupBy: {
            args: Prisma.ConstructionSiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConstructionSiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConstructionSiteCountArgs<ExtArgs>
            result: $Utils.Optional<ConstructionSiteCountAggregateOutputType> | number
          }
        }
      }
      ConstructionTeam: {
        payload: Prisma.$ConstructionTeamPayload<ExtArgs>
        fields: Prisma.ConstructionTeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConstructionTeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConstructionTeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTeamPayload>
          }
          findFirst: {
            args: Prisma.ConstructionTeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConstructionTeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTeamPayload>
          }
          findMany: {
            args: Prisma.ConstructionTeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTeamPayload>[]
          }
          create: {
            args: Prisma.ConstructionTeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTeamPayload>
          }
          createMany: {
            args: Prisma.ConstructionTeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConstructionTeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTeamPayload>[]
          }
          delete: {
            args: Prisma.ConstructionTeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTeamPayload>
          }
          update: {
            args: Prisma.ConstructionTeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTeamPayload>
          }
          deleteMany: {
            args: Prisma.ConstructionTeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConstructionTeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConstructionTeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTeamPayload>[]
          }
          upsert: {
            args: Prisma.ConstructionTeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionTeamPayload>
          }
          aggregate: {
            args: Prisma.ConstructionTeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConstructionTeam>
          }
          groupBy: {
            args: Prisma.ConstructionTeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConstructionTeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConstructionTeamCountArgs<ExtArgs>
            result: $Utils.Optional<ConstructionTeamCountAggregateOutputType> | number
          }
        }
      }
      ConstructionWorker: {
        payload: Prisma.$ConstructionWorkerPayload<ExtArgs>
        fields: Prisma.ConstructionWorkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConstructionWorkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionWorkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConstructionWorkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionWorkerPayload>
          }
          findFirst: {
            args: Prisma.ConstructionWorkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionWorkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConstructionWorkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionWorkerPayload>
          }
          findMany: {
            args: Prisma.ConstructionWorkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionWorkerPayload>[]
          }
          create: {
            args: Prisma.ConstructionWorkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionWorkerPayload>
          }
          createMany: {
            args: Prisma.ConstructionWorkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConstructionWorkerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionWorkerPayload>[]
          }
          delete: {
            args: Prisma.ConstructionWorkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionWorkerPayload>
          }
          update: {
            args: Prisma.ConstructionWorkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionWorkerPayload>
          }
          deleteMany: {
            args: Prisma.ConstructionWorkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConstructionWorkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConstructionWorkerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionWorkerPayload>[]
          }
          upsert: {
            args: Prisma.ConstructionWorkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionWorkerPayload>
          }
          aggregate: {
            args: Prisma.ConstructionWorkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConstructionWorker>
          }
          groupBy: {
            args: Prisma.ConstructionWorkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConstructionWorkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConstructionWorkerCountArgs<ExtArgs>
            result: $Utils.Optional<ConstructionWorkerCountAggregateOutputType> | number
          }
        }
      }
      SiteAttendance: {
        payload: Prisma.$SiteAttendancePayload<ExtArgs>
        fields: Prisma.SiteAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteAttendancePayload>
          }
          findFirst: {
            args: Prisma.SiteAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteAttendancePayload>
          }
          findMany: {
            args: Prisma.SiteAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteAttendancePayload>[]
          }
          create: {
            args: Prisma.SiteAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteAttendancePayload>
          }
          createMany: {
            args: Prisma.SiteAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteAttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteAttendancePayload>[]
          }
          delete: {
            args: Prisma.SiteAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteAttendancePayload>
          }
          update: {
            args: Prisma.SiteAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteAttendancePayload>
          }
          deleteMany: {
            args: Prisma.SiteAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteAttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteAttendancePayload>[]
          }
          upsert: {
            args: Prisma.SiteAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteAttendancePayload>
          }
          aggregate: {
            args: Prisma.SiteAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteAttendance>
          }
          groupBy: {
            args: Prisma.SiteAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<SiteAttendanceCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Person: {
        payload: Prisma.$PersonPayload<ExtArgs>
        fields: Prisma.PersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findFirst: {
            args: Prisma.PersonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findMany: {
            args: Prisma.PersonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          create: {
            args: Prisma.PersonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          createMany: {
            args: Prisma.PersonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          delete: {
            args: Prisma.PersonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          update: {
            args: Prisma.PersonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          deleteMany: {
            args: Prisma.PersonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          upsert: {
            args: Prisma.PersonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          aggregate: {
            args: Prisma.PersonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerson>
          }
          groupBy: {
            args: Prisma.PersonGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonCountArgs<ExtArgs>
            result: $Utils.Optional<PersonCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Worker: {
        payload: Prisma.$WorkerPayload<ExtArgs>
        fields: Prisma.WorkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findFirst: {
            args: Prisma.WorkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findMany: {
            args: Prisma.WorkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          create: {
            args: Prisma.WorkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          createMany: {
            args: Prisma.WorkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          delete: {
            args: Prisma.WorkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          update: {
            args: Prisma.WorkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          deleteMany: {
            args: Prisma.WorkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          upsert: {
            args: Prisma.WorkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          aggregate: {
            args: Prisma.WorkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorker>
          }
          groupBy: {
            args: Prisma.WorkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerCountAggregateOutputType> | number
          }
        }
      }
      AttendanceEvent: {
        payload: Prisma.$AttendanceEventPayload<ExtArgs>
        fields: Prisma.AttendanceEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          findFirst: {
            args: Prisma.AttendanceEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          findMany: {
            args: Prisma.AttendanceEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>[]
          }
          create: {
            args: Prisma.AttendanceEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          createMany: {
            args: Prisma.AttendanceEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>[]
          }
          delete: {
            args: Prisma.AttendanceEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          update: {
            args: Prisma.AttendanceEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          aggregate: {
            args: Prisma.AttendanceEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceEvent>
          }
          groupBy: {
            args: Prisma.AttendanceEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceEventCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceEventCountAggregateOutputType> | number
          }
        }
      }
      AttendanceDailySummary: {
        payload: Prisma.$AttendanceDailySummaryPayload<ExtArgs>
        fields: Prisma.AttendanceDailySummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceDailySummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailySummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceDailySummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailySummaryPayload>
          }
          findFirst: {
            args: Prisma.AttendanceDailySummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailySummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceDailySummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailySummaryPayload>
          }
          findMany: {
            args: Prisma.AttendanceDailySummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailySummaryPayload>[]
          }
          create: {
            args: Prisma.AttendanceDailySummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailySummaryPayload>
          }
          createMany: {
            args: Prisma.AttendanceDailySummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceDailySummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailySummaryPayload>[]
          }
          delete: {
            args: Prisma.AttendanceDailySummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailySummaryPayload>
          }
          update: {
            args: Prisma.AttendanceDailySummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailySummaryPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDailySummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceDailySummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceDailySummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailySummaryPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceDailySummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailySummaryPayload>
          }
          aggregate: {
            args: Prisma.AttendanceDailySummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceDailySummary>
          }
          groupBy: {
            args: Prisma.AttendanceDailySummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceDailySummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceDailySummaryCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceDailySummaryCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      LeaveType: {
        payload: Prisma.$LeaveTypePayload<ExtArgs>
        fields: Prisma.LeaveTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          findFirst: {
            args: Prisma.LeaveTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          findMany: {
            args: Prisma.LeaveTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>[]
          }
          create: {
            args: Prisma.LeaveTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          createMany: {
            args: Prisma.LeaveTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>[]
          }
          delete: {
            args: Prisma.LeaveTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          update: {
            args: Prisma.LeaveTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          deleteMany: {
            args: Prisma.LeaveTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>[]
          }
          upsert: {
            args: Prisma.LeaveTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          aggregate: {
            args: Prisma.LeaveTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveType>
          }
          groupBy: {
            args: Prisma.LeaveTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveTypeCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveTypeCountAggregateOutputType> | number
          }
        }
      }
      LeaveBalance: {
        payload: Prisma.$LeaveBalancePayload<ExtArgs>
        fields: Prisma.LeaveBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          findFirst: {
            args: Prisma.LeaveBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          findMany: {
            args: Prisma.LeaveBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
          }
          create: {
            args: Prisma.LeaveBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          createMany: {
            args: Prisma.LeaveBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveBalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
          }
          delete: {
            args: Prisma.LeaveBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          update: {
            args: Prisma.LeaveBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          deleteMany: {
            args: Prisma.LeaveBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveBalanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
          }
          upsert: {
            args: Prisma.LeaveBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          aggregate: {
            args: Prisma.LeaveBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveBalance>
          }
          groupBy: {
            args: Prisma.LeaveBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveBalanceCountAggregateOutputType> | number
          }
        }
      }
      LeaveRequest: {
        payload: Prisma.$LeaveRequestPayload<ExtArgs>
        fields: Prisma.LeaveRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findFirst: {
            args: Prisma.LeaveRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findMany: {
            args: Prisma.LeaveRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          create: {
            args: Prisma.LeaveRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          createMany: {
            args: Prisma.LeaveRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          delete: {
            args: Prisma.LeaveRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          update: {
            args: Prisma.LeaveRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          deleteMany: {
            args: Prisma.LeaveRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          upsert: {
            args: Prisma.LeaveRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          aggregate: {
            args: Prisma.LeaveRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveRequest>
          }
          groupBy: {
            args: Prisma.LeaveRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveRequestCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestCountAggregateOutputType> | number
          }
        }
      }
      PublicHoliday: {
        payload: Prisma.$PublicHolidayPayload<ExtArgs>
        fields: Prisma.PublicHolidayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublicHolidayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicHolidayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublicHolidayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicHolidayPayload>
          }
          findFirst: {
            args: Prisma.PublicHolidayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicHolidayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublicHolidayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicHolidayPayload>
          }
          findMany: {
            args: Prisma.PublicHolidayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicHolidayPayload>[]
          }
          create: {
            args: Prisma.PublicHolidayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicHolidayPayload>
          }
          createMany: {
            args: Prisma.PublicHolidayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PublicHolidayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicHolidayPayload>[]
          }
          delete: {
            args: Prisma.PublicHolidayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicHolidayPayload>
          }
          update: {
            args: Prisma.PublicHolidayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicHolidayPayload>
          }
          deleteMany: {
            args: Prisma.PublicHolidayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PublicHolidayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PublicHolidayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicHolidayPayload>[]
          }
          upsert: {
            args: Prisma.PublicHolidayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicHolidayPayload>
          }
          aggregate: {
            args: Prisma.PublicHolidayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublicHoliday>
          }
          groupBy: {
            args: Prisma.PublicHolidayGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublicHolidayGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublicHolidayCountArgs<ExtArgs>
            result: $Utils.Optional<PublicHolidayCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      PayrollPeriod: {
        payload: Prisma.$PayrollPeriodPayload<ExtArgs>
        fields: Prisma.PayrollPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          findFirst: {
            args: Prisma.PayrollPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          findMany: {
            args: Prisma.PayrollPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>[]
          }
          create: {
            args: Prisma.PayrollPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          createMany: {
            args: Prisma.PayrollPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>[]
          }
          delete: {
            args: Prisma.PayrollPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          update: {
            args: Prisma.PayrollPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          deleteMany: {
            args: Prisma.PayrollPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollPeriodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>[]
          }
          upsert: {
            args: Prisma.PayrollPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          aggregate: {
            args: Prisma.PayrollPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollPeriod>
          }
          groupBy: {
            args: Prisma.PayrollPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollPeriodCountAggregateOutputType> | number
          }
        }
      }
      PayrollLine: {
        payload: Prisma.$PayrollLinePayload<ExtArgs>
        fields: Prisma.PayrollLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>
          }
          findFirst: {
            args: Prisma.PayrollLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>
          }
          findMany: {
            args: Prisma.PayrollLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>[]
          }
          create: {
            args: Prisma.PayrollLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>
          }
          createMany: {
            args: Prisma.PayrollLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>[]
          }
          delete: {
            args: Prisma.PayrollLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>
          }
          update: {
            args: Prisma.PayrollLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>
          }
          deleteMany: {
            args: Prisma.PayrollLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>[]
          }
          upsert: {
            args: Prisma.PayrollLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>
          }
          aggregate: {
            args: Prisma.PayrollLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollLine>
          }
          groupBy: {
            args: Prisma.PayrollLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollLineCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollLineCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    company?: CompanyOmit
    user?: UserOmit
    attendance?: AttendanceOmit
    schedule?: ScheduleOmit
    overtime?: OvertimeOmit
    attendanceSummary?: AttendanceSummaryOmit
    payroll?: PayrollOmit
    payrollExport?: PayrollExportOmit
    report?: ReportOmit
    periodClosure?: PeriodClosureOmit
    schoolClass?: SchoolClassOmit
    course?: CourseOmit
    student?: StudentOmit
    studentAttendance?: StudentAttendanceOmit
    constructionSite?: ConstructionSiteOmit
    constructionTeam?: ConstructionTeamOmit
    constructionWorker?: ConstructionWorkerOmit
    siteAttendance?: SiteAttendanceOmit
    auditLog?: AuditLogOmit
    userRole?: UserRoleOmit
    person?: PersonOmit
    employee?: EmployeeOmit
    worker?: WorkerOmit
    attendanceEvent?: AttendanceEventOmit
    attendanceDailySummary?: AttendanceDailySummaryOmit
    device?: DeviceOmit
    leaveType?: LeaveTypeOmit
    leaveBalance?: LeaveBalanceOmit
    leaveRequest?: LeaveRequestOmit
    publicHoliday?: PublicHolidayOmit
    contract?: ContractOmit
    payrollPeriod?: PayrollPeriodOmit
    payrollLine?: PayrollLineOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    users: number
    persons: number
    employees: number
    workers: number
    attendance: number
    attendanceEvents: number
    attendanceDailySummaries: number
    schedules: number
    overtime: number
    attendanceSummaries: number
    payrolls: number
    payrollPeriods: number
    payrollLines: number
    contracts: number
    payrollExports: number
    reports: number
    schoolClasses: number
    courses: number
    students: number
    studentAttendance: number
    leaveTypes: number
    leaveBalances: number
    leaveRequests: number
    publicHolidays: number
    constructionSites: number
    constructionTeams: number
    constructionWorkers: number
    siteAttendance: number
    auditLogs: number
    userRoles: number
    devices: number
    periodClosures: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    persons?: boolean | CompanyCountOutputTypeCountPersonsArgs
    employees?: boolean | CompanyCountOutputTypeCountEmployeesArgs
    workers?: boolean | CompanyCountOutputTypeCountWorkersArgs
    attendance?: boolean | CompanyCountOutputTypeCountAttendanceArgs
    attendanceEvents?: boolean | CompanyCountOutputTypeCountAttendanceEventsArgs
    attendanceDailySummaries?: boolean | CompanyCountOutputTypeCountAttendanceDailySummariesArgs
    schedules?: boolean | CompanyCountOutputTypeCountSchedulesArgs
    overtime?: boolean | CompanyCountOutputTypeCountOvertimeArgs
    attendanceSummaries?: boolean | CompanyCountOutputTypeCountAttendanceSummariesArgs
    payrolls?: boolean | CompanyCountOutputTypeCountPayrollsArgs
    payrollPeriods?: boolean | CompanyCountOutputTypeCountPayrollPeriodsArgs
    payrollLines?: boolean | CompanyCountOutputTypeCountPayrollLinesArgs
    contracts?: boolean | CompanyCountOutputTypeCountContractsArgs
    payrollExports?: boolean | CompanyCountOutputTypeCountPayrollExportsArgs
    reports?: boolean | CompanyCountOutputTypeCountReportsArgs
    schoolClasses?: boolean | CompanyCountOutputTypeCountSchoolClassesArgs
    courses?: boolean | CompanyCountOutputTypeCountCoursesArgs
    students?: boolean | CompanyCountOutputTypeCountStudentsArgs
    studentAttendance?: boolean | CompanyCountOutputTypeCountStudentAttendanceArgs
    leaveTypes?: boolean | CompanyCountOutputTypeCountLeaveTypesArgs
    leaveBalances?: boolean | CompanyCountOutputTypeCountLeaveBalancesArgs
    leaveRequests?: boolean | CompanyCountOutputTypeCountLeaveRequestsArgs
    publicHolidays?: boolean | CompanyCountOutputTypeCountPublicHolidaysArgs
    constructionSites?: boolean | CompanyCountOutputTypeCountConstructionSitesArgs
    constructionTeams?: boolean | CompanyCountOutputTypeCountConstructionTeamsArgs
    constructionWorkers?: boolean | CompanyCountOutputTypeCountConstructionWorkersArgs
    siteAttendance?: boolean | CompanyCountOutputTypeCountSiteAttendanceArgs
    auditLogs?: boolean | CompanyCountOutputTypeCountAuditLogsArgs
    userRoles?: boolean | CompanyCountOutputTypeCountUserRolesArgs
    devices?: boolean | CompanyCountOutputTypeCountDevicesArgs
    periodClosures?: boolean | CompanyCountOutputTypeCountPeriodClosuresArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPersonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAttendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceEventWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAttendanceDailySummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDailySummaryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountOvertimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimeWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAttendanceSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceSummaryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPayrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPayrollPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollPeriodWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPayrollLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollLineWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPayrollExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollExportWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSchoolClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolClassWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountStudentAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountLeaveTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveTypeWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountLeaveBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveBalanceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountLeaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPublicHolidaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicHolidayWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountConstructionSitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConstructionSiteWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountConstructionTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConstructionTeamWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountConstructionWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConstructionWorkerWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSiteAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteAttendanceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPeriodClosuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PeriodClosureWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userRoles: number
    attendance: number
    overtimeRequests: number
    overtimeApprovals: number
    studentAttendanceRecords: number
    attendanceValidations: number
    leaveValidations: number
    payrollPeriodClosures: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
    attendance?: boolean | UserCountOutputTypeCountAttendanceArgs
    overtimeRequests?: boolean | UserCountOutputTypeCountOvertimeRequestsArgs
    overtimeApprovals?: boolean | UserCountOutputTypeCountOvertimeApprovalsArgs
    studentAttendanceRecords?: boolean | UserCountOutputTypeCountStudentAttendanceRecordsArgs
    attendanceValidations?: boolean | UserCountOutputTypeCountAttendanceValidationsArgs
    leaveValidations?: boolean | UserCountOutputTypeCountLeaveValidationsArgs
    payrollPeriodClosures?: boolean | UserCountOutputTypeCountPayrollPeriodClosuresArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOvertimeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOvertimeApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudentAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceValidationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDailySummaryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaveValidationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPayrollPeriodClosuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollPeriodWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type ScheduleCountOutputType
   */

  export type ScheduleCountOutputType = {
    employees: number
  }

  export type ScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | ScheduleCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleCountOutputType
     */
    select?: ScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type AttendanceSummaryCountOutputType
   */

  export type AttendanceSummaryCountOutputType = {
    payrolls: number
  }

  export type AttendanceSummaryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payrolls?: boolean | AttendanceSummaryCountOutputTypeCountPayrollsArgs
  }

  // Custom InputTypes
  /**
   * AttendanceSummaryCountOutputType without action
   */
  export type AttendanceSummaryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummaryCountOutputType
     */
    select?: AttendanceSummaryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttendanceSummaryCountOutputType without action
   */
  export type AttendanceSummaryCountOutputTypeCountPayrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
  }


  /**
   * Count Type PayrollCountOutputType
   */

  export type PayrollCountOutputType = {
    exports: number
  }

  export type PayrollCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exports?: boolean | PayrollCountOutputTypeCountExportsArgs
  }

  // Custom InputTypes
  /**
   * PayrollCountOutputType without action
   */
  export type PayrollCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollCountOutputType
     */
    select?: PayrollCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayrollCountOutputType without action
   */
  export type PayrollCountOutputTypeCountExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollExportWhereInput
  }


  /**
   * Count Type SchoolClassCountOutputType
   */

  export type SchoolClassCountOutputType = {
    courses: number
    students: number
  }

  export type SchoolClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | SchoolClassCountOutputTypeCountCoursesArgs
    students?: boolean | SchoolClassCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * SchoolClassCountOutputType without action
   */
  export type SchoolClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClassCountOutputType
     */
    select?: SchoolClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolClassCountOutputType without action
   */
  export type SchoolClassCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * SchoolClassCountOutputType without action
   */
  export type SchoolClassCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    attendance: number
    attendanceEvents: number
    dailySummaries: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | StudentCountOutputTypeCountAttendanceArgs
    attendanceEvents?: boolean | StudentCountOutputTypeCountAttendanceEventsArgs
    dailySummaries?: boolean | StudentCountOutputTypeCountDailySummariesArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAttendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceEventWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountDailySummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDailySummaryWhereInput
  }


  /**
   * Count Type ConstructionSiteCountOutputType
   */

  export type ConstructionSiteCountOutputType = {
    teams: number
    attendance: number
  }

  export type ConstructionSiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | ConstructionSiteCountOutputTypeCountTeamsArgs
    attendance?: boolean | ConstructionSiteCountOutputTypeCountAttendanceArgs
  }

  // Custom InputTypes
  /**
   * ConstructionSiteCountOutputType without action
   */
  export type ConstructionSiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSiteCountOutputType
     */
    select?: ConstructionSiteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConstructionSiteCountOutputType without action
   */
  export type ConstructionSiteCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConstructionTeamWhereInput
  }

  /**
   * ConstructionSiteCountOutputType without action
   */
  export type ConstructionSiteCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteAttendanceWhereInput
  }


  /**
   * Count Type ConstructionTeamCountOutputType
   */

  export type ConstructionTeamCountOutputType = {
    workers: number
  }

  export type ConstructionTeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workers?: boolean | ConstructionTeamCountOutputTypeCountWorkersArgs
  }

  // Custom InputTypes
  /**
   * ConstructionTeamCountOutputType without action
   */
  export type ConstructionTeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeamCountOutputType
     */
    select?: ConstructionTeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConstructionTeamCountOutputType without action
   */
  export type ConstructionTeamCountOutputTypeCountWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConstructionWorkerWhereInput
  }


  /**
   * Count Type ConstructionWorkerCountOutputType
   */

  export type ConstructionWorkerCountOutputType = {
    attendance: number
  }

  export type ConstructionWorkerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | ConstructionWorkerCountOutputTypeCountAttendanceArgs
  }

  // Custom InputTypes
  /**
   * ConstructionWorkerCountOutputType without action
   */
  export type ConstructionWorkerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorkerCountOutputType
     */
    select?: ConstructionWorkerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConstructionWorkerCountOutputType without action
   */
  export type ConstructionWorkerCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteAttendanceWhereInput
  }


  /**
   * Count Type PersonCountOutputType
   */

  export type PersonCountOutputType = {
    devices: number
  }

  export type PersonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devices?: boolean | PersonCountOutputTypeCountDevicesArgs
  }

  // Custom InputTypes
  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonCountOutputType
     */
    select?: PersonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    attendances: number
    dailySummaries: number
    payrollLines: number
    contracts: number
    leaveBalances: number
    leaveRequests: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | EmployeeCountOutputTypeCountAttendancesArgs
    dailySummaries?: boolean | EmployeeCountOutputTypeCountDailySummariesArgs
    payrollLines?: boolean | EmployeeCountOutputTypeCountPayrollLinesArgs
    contracts?: boolean | EmployeeCountOutputTypeCountContractsArgs
    leaveBalances?: boolean | EmployeeCountOutputTypeCountLeaveBalancesArgs
    leaveRequests?: boolean | EmployeeCountOutputTypeCountLeaveRequestsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceEventWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDailySummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDailySummaryWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPayrollLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollLineWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeaveBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveBalanceWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }


  /**
   * Count Type WorkerCountOutputType
   */

  export type WorkerCountOutputType = {
    attendances: number
    dailySummaries: number
  }

  export type WorkerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | WorkerCountOutputTypeCountAttendancesArgs
    dailySummaries?: boolean | WorkerCountOutputTypeCountDailySummariesArgs
  }

  // Custom InputTypes
  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerCountOutputType
     */
    select?: WorkerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceEventWhereInput
  }

  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeCountDailySummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDailySummaryWhereInput
  }


  /**
   * Count Type DeviceCountOutputType
   */

  export type DeviceCountOutputType = {
    attendanceEvents: number
  }

  export type DeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendanceEvents?: boolean | DeviceCountOutputTypeCountAttendanceEventsArgs
  }

  // Custom InputTypes
  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCountOutputType
     */
    select?: DeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceCountOutputType without action
   */
  export type DeviceCountOutputTypeCountAttendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceEventWhereInput
  }


  /**
   * Count Type LeaveTypeCountOutputType
   */

  export type LeaveTypeCountOutputType = {
    balances: number
    requests: number
  }

  export type LeaveTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balances?: boolean | LeaveTypeCountOutputTypeCountBalancesArgs
    requests?: boolean | LeaveTypeCountOutputTypeCountRequestsArgs
  }

  // Custom InputTypes
  /**
   * LeaveTypeCountOutputType without action
   */
  export type LeaveTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveTypeCountOutputType
     */
    select?: LeaveTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeaveTypeCountOutputType without action
   */
  export type LeaveTypeCountOutputTypeCountBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveBalanceWhereInput
  }

  /**
   * LeaveTypeCountOutputType without action
   */
  export type LeaveTypeCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }


  /**
   * Count Type PayrollPeriodCountOutputType
   */

  export type PayrollPeriodCountOutputType = {
    lines: number
  }

  export type PayrollPeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | PayrollPeriodCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * PayrollPeriodCountOutputType without action
   */
  export type PayrollPeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriodCountOutputType
     */
    select?: PayrollPeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayrollPeriodCountOutputType without action
   */
  export type PayrollPeriodCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollLineWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    type: $Enums.CompanyType | null
    isActive: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    type: $Enums.CompanyType | null
    isActive: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    code: number
    type: number
    isActive: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    type?: true
    isActive?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    type?: true
    isActive?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    type?: true
    isActive?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    code: string
    type: $Enums.CompanyType
    isActive: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    isActive?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Company$usersArgs<ExtArgs>
    persons?: boolean | Company$personsArgs<ExtArgs>
    employees?: boolean | Company$employeesArgs<ExtArgs>
    workers?: boolean | Company$workersArgs<ExtArgs>
    attendance?: boolean | Company$attendanceArgs<ExtArgs>
    attendanceEvents?: boolean | Company$attendanceEventsArgs<ExtArgs>
    attendanceDailySummaries?: boolean | Company$attendanceDailySummariesArgs<ExtArgs>
    schedules?: boolean | Company$schedulesArgs<ExtArgs>
    overtime?: boolean | Company$overtimeArgs<ExtArgs>
    attendanceSummaries?: boolean | Company$attendanceSummariesArgs<ExtArgs>
    payrolls?: boolean | Company$payrollsArgs<ExtArgs>
    payrollPeriods?: boolean | Company$payrollPeriodsArgs<ExtArgs>
    payrollLines?: boolean | Company$payrollLinesArgs<ExtArgs>
    contracts?: boolean | Company$contractsArgs<ExtArgs>
    payrollExports?: boolean | Company$payrollExportsArgs<ExtArgs>
    reports?: boolean | Company$reportsArgs<ExtArgs>
    schoolClasses?: boolean | Company$schoolClassesArgs<ExtArgs>
    courses?: boolean | Company$coursesArgs<ExtArgs>
    students?: boolean | Company$studentsArgs<ExtArgs>
    studentAttendance?: boolean | Company$studentAttendanceArgs<ExtArgs>
    leaveTypes?: boolean | Company$leaveTypesArgs<ExtArgs>
    leaveBalances?: boolean | Company$leaveBalancesArgs<ExtArgs>
    leaveRequests?: boolean | Company$leaveRequestsArgs<ExtArgs>
    publicHolidays?: boolean | Company$publicHolidaysArgs<ExtArgs>
    constructionSites?: boolean | Company$constructionSitesArgs<ExtArgs>
    constructionTeams?: boolean | Company$constructionTeamsArgs<ExtArgs>
    constructionWorkers?: boolean | Company$constructionWorkersArgs<ExtArgs>
    siteAttendance?: boolean | Company$siteAttendanceArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    userRoles?: boolean | Company$userRolesArgs<ExtArgs>
    devices?: boolean | Company$devicesArgs<ExtArgs>
    periodClosures?: boolean | Company$periodClosuresArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    isActive?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    isActive?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    isActive?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "type" | "isActive" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Company$usersArgs<ExtArgs>
    persons?: boolean | Company$personsArgs<ExtArgs>
    employees?: boolean | Company$employeesArgs<ExtArgs>
    workers?: boolean | Company$workersArgs<ExtArgs>
    attendance?: boolean | Company$attendanceArgs<ExtArgs>
    attendanceEvents?: boolean | Company$attendanceEventsArgs<ExtArgs>
    attendanceDailySummaries?: boolean | Company$attendanceDailySummariesArgs<ExtArgs>
    schedules?: boolean | Company$schedulesArgs<ExtArgs>
    overtime?: boolean | Company$overtimeArgs<ExtArgs>
    attendanceSummaries?: boolean | Company$attendanceSummariesArgs<ExtArgs>
    payrolls?: boolean | Company$payrollsArgs<ExtArgs>
    payrollPeriods?: boolean | Company$payrollPeriodsArgs<ExtArgs>
    payrollLines?: boolean | Company$payrollLinesArgs<ExtArgs>
    contracts?: boolean | Company$contractsArgs<ExtArgs>
    payrollExports?: boolean | Company$payrollExportsArgs<ExtArgs>
    reports?: boolean | Company$reportsArgs<ExtArgs>
    schoolClasses?: boolean | Company$schoolClassesArgs<ExtArgs>
    courses?: boolean | Company$coursesArgs<ExtArgs>
    students?: boolean | Company$studentsArgs<ExtArgs>
    studentAttendance?: boolean | Company$studentAttendanceArgs<ExtArgs>
    leaveTypes?: boolean | Company$leaveTypesArgs<ExtArgs>
    leaveBalances?: boolean | Company$leaveBalancesArgs<ExtArgs>
    leaveRequests?: boolean | Company$leaveRequestsArgs<ExtArgs>
    publicHolidays?: boolean | Company$publicHolidaysArgs<ExtArgs>
    constructionSites?: boolean | Company$constructionSitesArgs<ExtArgs>
    constructionTeams?: boolean | Company$constructionTeamsArgs<ExtArgs>
    constructionWorkers?: boolean | Company$constructionWorkersArgs<ExtArgs>
    siteAttendance?: boolean | Company$siteAttendanceArgs<ExtArgs>
    auditLogs?: boolean | Company$auditLogsArgs<ExtArgs>
    userRoles?: boolean | Company$userRolesArgs<ExtArgs>
    devices?: boolean | Company$devicesArgs<ExtArgs>
    periodClosures?: boolean | Company$periodClosuresArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      /**
       * New architecture: identity/person layer for all profiles.
       */
      persons: Prisma.$PersonPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      workers: Prisma.$WorkerPayload<ExtArgs>[]
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
      attendanceEvents: Prisma.$AttendanceEventPayload<ExtArgs>[]
      attendanceDailySummaries: Prisma.$AttendanceDailySummaryPayload<ExtArgs>[]
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
      overtime: Prisma.$OvertimePayload<ExtArgs>[]
      attendanceSummaries: Prisma.$AttendanceSummaryPayload<ExtArgs>[]
      payrolls: Prisma.$PayrollPayload<ExtArgs>[]
      payrollPeriods: Prisma.$PayrollPeriodPayload<ExtArgs>[]
      payrollLines: Prisma.$PayrollLinePayload<ExtArgs>[]
      contracts: Prisma.$ContractPayload<ExtArgs>[]
      payrollExports: Prisma.$PayrollExportPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      schoolClasses: Prisma.$SchoolClassPayload<ExtArgs>[]
      courses: Prisma.$CoursePayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      studentAttendance: Prisma.$StudentAttendancePayload<ExtArgs>[]
      leaveTypes: Prisma.$LeaveTypePayload<ExtArgs>[]
      leaveBalances: Prisma.$LeaveBalancePayload<ExtArgs>[]
      leaveRequests: Prisma.$LeaveRequestPayload<ExtArgs>[]
      publicHolidays: Prisma.$PublicHolidayPayload<ExtArgs>[]
      constructionSites: Prisma.$ConstructionSitePayload<ExtArgs>[]
      constructionTeams: Prisma.$ConstructionTeamPayload<ExtArgs>[]
      constructionWorkers: Prisma.$ConstructionWorkerPayload<ExtArgs>[]
      siteAttendance: Prisma.$SiteAttendancePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      devices: Prisma.$DevicePayload<ExtArgs>[]
      periodClosures: Prisma.$PeriodClosurePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      /**
       * Optional classification to guide feature flags and UI.
       */
      type: $Enums.CompanyType
      isActive: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    persons<T extends Company$personsArgs<ExtArgs> = {}>(args?: Subset<T, Company$personsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Company$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Company$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workers<T extends Company$workersArgs<ExtArgs> = {}>(args?: Subset<T, Company$workersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends Company$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Company$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceEvents<T extends Company$attendanceEventsArgs<ExtArgs> = {}>(args?: Subset<T, Company$attendanceEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceDailySummaries<T extends Company$attendanceDailySummariesArgs<ExtArgs> = {}>(args?: Subset<T, Company$attendanceDailySummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedules<T extends Company$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Company$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    overtime<T extends Company$overtimeArgs<ExtArgs> = {}>(args?: Subset<T, Company$overtimeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceSummaries<T extends Company$attendanceSummariesArgs<ExtArgs> = {}>(args?: Subset<T, Company$attendanceSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrolls<T extends Company$payrollsArgs<ExtArgs> = {}>(args?: Subset<T, Company$payrollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrollPeriods<T extends Company$payrollPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, Company$payrollPeriodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrollLines<T extends Company$payrollLinesArgs<ExtArgs> = {}>(args?: Subset<T, Company$payrollLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contracts<T extends Company$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Company$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrollExports<T extends Company$payrollExportsArgs<ExtArgs> = {}>(args?: Subset<T, Company$payrollExportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollExportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends Company$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Company$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schoolClasses<T extends Company$schoolClassesArgs<ExtArgs> = {}>(args?: Subset<T, Company$schoolClassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courses<T extends Company$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Company$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends Company$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentAttendance<T extends Company$studentAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Company$studentAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaveTypes<T extends Company$leaveTypesArgs<ExtArgs> = {}>(args?: Subset<T, Company$leaveTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaveBalances<T extends Company$leaveBalancesArgs<ExtArgs> = {}>(args?: Subset<T, Company$leaveBalancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaveRequests<T extends Company$leaveRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Company$leaveRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    publicHolidays<T extends Company$publicHolidaysArgs<ExtArgs> = {}>(args?: Subset<T, Company$publicHolidaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicHolidayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    constructionSites<T extends Company$constructionSitesArgs<ExtArgs> = {}>(args?: Subset<T, Company$constructionSitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    constructionTeams<T extends Company$constructionTeamsArgs<ExtArgs> = {}>(args?: Subset<T, Company$constructionTeamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    constructionWorkers<T extends Company$constructionWorkersArgs<ExtArgs> = {}>(args?: Subset<T, Company$constructionWorkersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    siteAttendance<T extends Company$siteAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Company$siteAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Company$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Company$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userRoles<T extends Company$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Company$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devices<T extends Company$devicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    periodClosures<T extends Company$periodClosuresArgs<ExtArgs> = {}>(args?: Subset<T, Company$periodClosuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodClosurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly code: FieldRef<"Company", 'String'>
    readonly type: FieldRef<"Company", 'CompanyType'>
    readonly isActive: FieldRef<"Company", 'Boolean'>
    readonly deletedAt: FieldRef<"Company", 'DateTime'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.persons
   */
  export type Company$personsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    where?: PersonWhereInput
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    cursor?: PersonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Company.employees
   */
  export type Company$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Company.workers
   */
  export type Company$workersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    cursor?: WorkerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Company.attendance
   */
  export type Company$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Company.attendanceEvents
   */
  export type Company$attendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    where?: AttendanceEventWhereInput
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    cursor?: AttendanceEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * Company.attendanceDailySummaries
   */
  export type Company$attendanceDailySummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    where?: AttendanceDailySummaryWhereInput
    orderBy?: AttendanceDailySummaryOrderByWithRelationInput | AttendanceDailySummaryOrderByWithRelationInput[]
    cursor?: AttendanceDailySummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceDailySummaryScalarFieldEnum | AttendanceDailySummaryScalarFieldEnum[]
  }

  /**
   * Company.schedules
   */
  export type Company$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Company.overtime
   */
  export type Company$overtimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    where?: OvertimeWhereInput
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    cursor?: OvertimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * Company.attendanceSummaries
   */
  export type Company$attendanceSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    where?: AttendanceSummaryWhereInput
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    cursor?: AttendanceSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * Company.payrolls
   */
  export type Company$payrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    cursor?: PayrollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Company.payrollPeriods
   */
  export type Company$payrollPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    where?: PayrollPeriodWhereInput
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    cursor?: PayrollPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollPeriodScalarFieldEnum | PayrollPeriodScalarFieldEnum[]
  }

  /**
   * Company.payrollLines
   */
  export type Company$payrollLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    where?: PayrollLineWhereInput
    orderBy?: PayrollLineOrderByWithRelationInput | PayrollLineOrderByWithRelationInput[]
    cursor?: PayrollLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollLineScalarFieldEnum | PayrollLineScalarFieldEnum[]
  }

  /**
   * Company.contracts
   */
  export type Company$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Company.payrollExports
   */
  export type Company$payrollExportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportInclude<ExtArgs> | null
    where?: PayrollExportWhereInput
    orderBy?: PayrollExportOrderByWithRelationInput | PayrollExportOrderByWithRelationInput[]
    cursor?: PayrollExportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollExportScalarFieldEnum | PayrollExportScalarFieldEnum[]
  }

  /**
   * Company.reports
   */
  export type Company$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Company.schoolClasses
   */
  export type Company$schoolClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClass
     */
    select?: SchoolClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolClass
     */
    omit?: SchoolClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolClassInclude<ExtArgs> | null
    where?: SchoolClassWhereInput
    orderBy?: SchoolClassOrderByWithRelationInput | SchoolClassOrderByWithRelationInput[]
    cursor?: SchoolClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolClassScalarFieldEnum | SchoolClassScalarFieldEnum[]
  }

  /**
   * Company.courses
   */
  export type Company$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Company.students
   */
  export type Company$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Company.studentAttendance
   */
  export type Company$studentAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    cursor?: StudentAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * Company.leaveTypes
   */
  export type Company$leaveTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    where?: LeaveTypeWhereInput
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    cursor?: LeaveTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * Company.leaveBalances
   */
  export type Company$leaveBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    where?: LeaveBalanceWhereInput
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    cursor?: LeaveBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * Company.leaveRequests
   */
  export type Company$leaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * Company.publicHolidays
   */
  export type Company$publicHolidaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicHoliday
     */
    select?: PublicHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicHoliday
     */
    omit?: PublicHolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicHolidayInclude<ExtArgs> | null
    where?: PublicHolidayWhereInput
    orderBy?: PublicHolidayOrderByWithRelationInput | PublicHolidayOrderByWithRelationInput[]
    cursor?: PublicHolidayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicHolidayScalarFieldEnum | PublicHolidayScalarFieldEnum[]
  }

  /**
   * Company.constructionSites
   */
  export type Company$constructionSitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSite
     */
    select?: ConstructionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionSite
     */
    omit?: ConstructionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionSiteInclude<ExtArgs> | null
    where?: ConstructionSiteWhereInput
    orderBy?: ConstructionSiteOrderByWithRelationInput | ConstructionSiteOrderByWithRelationInput[]
    cursor?: ConstructionSiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConstructionSiteScalarFieldEnum | ConstructionSiteScalarFieldEnum[]
  }

  /**
   * Company.constructionTeams
   */
  export type Company$constructionTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamInclude<ExtArgs> | null
    where?: ConstructionTeamWhereInput
    orderBy?: ConstructionTeamOrderByWithRelationInput | ConstructionTeamOrderByWithRelationInput[]
    cursor?: ConstructionTeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConstructionTeamScalarFieldEnum | ConstructionTeamScalarFieldEnum[]
  }

  /**
   * Company.constructionWorkers
   */
  export type Company$constructionWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerInclude<ExtArgs> | null
    where?: ConstructionWorkerWhereInput
    orderBy?: ConstructionWorkerOrderByWithRelationInput | ConstructionWorkerOrderByWithRelationInput[]
    cursor?: ConstructionWorkerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConstructionWorkerScalarFieldEnum | ConstructionWorkerScalarFieldEnum[]
  }

  /**
   * Company.siteAttendance
   */
  export type Company$siteAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceInclude<ExtArgs> | null
    where?: SiteAttendanceWhereInput
    orderBy?: SiteAttendanceOrderByWithRelationInput | SiteAttendanceOrderByWithRelationInput[]
    cursor?: SiteAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteAttendanceScalarFieldEnum | SiteAttendanceScalarFieldEnum[]
  }

  /**
   * Company.auditLogs
   */
  export type Company$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Company.userRoles
   */
  export type Company$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Company.devices
   */
  export type Company$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Company.periodClosures
   */
  export type Company$periodClosuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodClosure
     */
    select?: PeriodClosureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeriodClosure
     */
    omit?: PeriodClosureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodClosureInclude<ExtArgs> | null
    where?: PeriodClosureWhereInput
    orderBy?: PeriodClosureOrderByWithRelationInput | PeriodClosureOrderByWithRelationInput[]
    cursor?: PeriodClosureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PeriodClosureScalarFieldEnum | PeriodClosureScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    isActive: boolean | null
    companyId: string | null
    personId: string | null
    refreshTokenHash: string | null
    refreshTokenExpiresAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    isActive: boolean | null
    companyId: string | null
    personId: string | null
    refreshTokenHash: string | null
    refreshTokenExpiresAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    passwordHash: number
    roles: number
    isActive: number
    companyId: number
    personId: number
    refreshTokenHash: number
    refreshTokenExpiresAt: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    isActive?: true
    companyId?: true
    personId?: true
    refreshTokenHash?: true
    refreshTokenExpiresAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    isActive?: true
    companyId?: true
    personId?: true
    refreshTokenHash?: true
    refreshTokenExpiresAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    roles?: true
    isActive?: true
    companyId?: true
    personId?: true
    refreshTokenHash?: true
    refreshTokenExpiresAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    passwordHash: string
    roles: $Enums.Role[]
    isActive: boolean
    companyId: string
    personId: string | null
    refreshTokenHash: string | null
    refreshTokenExpiresAt: Date | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    roles?: boolean
    isActive?: boolean
    companyId?: boolean
    personId?: boolean
    refreshTokenHash?: boolean
    refreshTokenExpiresAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | User$personArgs<ExtArgs>
    employee?: boolean | User$employeeArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    attendance?: boolean | User$attendanceArgs<ExtArgs>
    overtimeRequests?: boolean | User$overtimeRequestsArgs<ExtArgs>
    overtimeApprovals?: boolean | User$overtimeApprovalsArgs<ExtArgs>
    studentAttendanceRecords?: boolean | User$studentAttendanceRecordsArgs<ExtArgs>
    attendanceValidations?: boolean | User$attendanceValidationsArgs<ExtArgs>
    leaveValidations?: boolean | User$leaveValidationsArgs<ExtArgs>
    payrollPeriodClosures?: boolean | User$payrollPeriodClosuresArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    roles?: boolean
    isActive?: boolean
    companyId?: boolean
    personId?: boolean
    refreshTokenHash?: boolean
    refreshTokenExpiresAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | User$personArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    roles?: boolean
    isActive?: boolean
    companyId?: boolean
    personId?: boolean
    refreshTokenHash?: boolean
    refreshTokenExpiresAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | User$personArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    roles?: boolean
    isActive?: boolean
    companyId?: boolean
    personId?: boolean
    refreshTokenHash?: boolean
    refreshTokenExpiresAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "passwordHash" | "roles" | "isActive" | "companyId" | "personId" | "refreshTokenHash" | "refreshTokenExpiresAt" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | User$personArgs<ExtArgs>
    employee?: boolean | User$employeeArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    attendance?: boolean | User$attendanceArgs<ExtArgs>
    overtimeRequests?: boolean | User$overtimeRequestsArgs<ExtArgs>
    overtimeApprovals?: boolean | User$overtimeApprovalsArgs<ExtArgs>
    studentAttendanceRecords?: boolean | User$studentAttendanceRecordsArgs<ExtArgs>
    attendanceValidations?: boolean | User$attendanceValidationsArgs<ExtArgs>
    leaveValidations?: boolean | User$leaveValidationsArgs<ExtArgs>
    payrollPeriodClosures?: boolean | User$payrollPeriodClosuresArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | User$personArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | User$personArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      person: Prisma.$PersonPayload<ExtArgs> | null
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      /**
       * New RBAC table for more granular role management.
       */
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
      overtimeRequests: Prisma.$OvertimePayload<ExtArgs>[]
      overtimeApprovals: Prisma.$OvertimePayload<ExtArgs>[]
      studentAttendanceRecords: Prisma.$StudentAttendancePayload<ExtArgs>[]
      attendanceValidations: Prisma.$AttendanceDailySummaryPayload<ExtArgs>[]
      leaveValidations: Prisma.$LeaveRequestPayload<ExtArgs>[]
      payrollPeriodClosures: Prisma.$PayrollPeriodPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      passwordHash: string
      roles: $Enums.Role[]
      isActive: boolean
      companyId: string
      /**
       * Optional link to the identity/person layer (progressive migration).
       */
      personId: string | null
      refreshTokenHash: string | null
      refreshTokenExpiresAt: Date | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    person<T extends User$personArgs<ExtArgs> = {}>(args?: Subset<T, User$personArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employee<T extends User$employeeArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends User$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    overtimeRequests<T extends User$overtimeRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$overtimeRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    overtimeApprovals<T extends User$overtimeApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$overtimeApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentAttendanceRecords<T extends User$studentAttendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$studentAttendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceValidations<T extends User$attendanceValidationsArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceValidationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaveValidations<T extends User$leaveValidationsArgs<ExtArgs> = {}>(args?: Subset<T, User$leaveValidationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrollPeriodClosures<T extends User$payrollPeriodClosuresArgs<ExtArgs> = {}>(args?: Subset<T, User$payrollPeriodClosuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly roles: FieldRef<"User", 'Role[]'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly companyId: FieldRef<"User", 'String'>
    readonly personId: FieldRef<"User", 'String'>
    readonly refreshTokenHash: FieldRef<"User", 'String'>
    readonly refreshTokenExpiresAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.person
   */
  export type User$personArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    where?: PersonWhereInput
  }

  /**
   * User.employee
   */
  export type User$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.attendance
   */
  export type User$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * User.overtimeRequests
   */
  export type User$overtimeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    where?: OvertimeWhereInput
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    cursor?: OvertimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * User.overtimeApprovals
   */
  export type User$overtimeApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    where?: OvertimeWhereInput
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    cursor?: OvertimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * User.studentAttendanceRecords
   */
  export type User$studentAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    cursor?: StudentAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * User.attendanceValidations
   */
  export type User$attendanceValidationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    where?: AttendanceDailySummaryWhereInput
    orderBy?: AttendanceDailySummaryOrderByWithRelationInput | AttendanceDailySummaryOrderByWithRelationInput[]
    cursor?: AttendanceDailySummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceDailySummaryScalarFieldEnum | AttendanceDailySummaryScalarFieldEnum[]
  }

  /**
   * User.leaveValidations
   */
  export type User$leaveValidationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * User.payrollPeriodClosures
   */
  export type User$payrollPeriodClosuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    where?: PayrollPeriodWhereInput
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    cursor?: PayrollPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollPeriodScalarFieldEnum | PayrollPeriodScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    checkInAt: Date | null
    checkOutAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    checkInAt: Date | null
    checkOutAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    checkInAt: number
    checkOutAt: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    checkInAt?: true
    checkOutAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    checkInAt?: true
    checkOutAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    checkInAt?: true
    checkOutAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    userId: string
    companyId: string
    checkInAt: Date
    checkOutAt: Date | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyId" | "checkInAt" | "checkOutAt" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string
      checkInAt: Date
      checkOutAt: Date | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly userId: FieldRef<"Attendance", 'String'>
    readonly companyId: FieldRef<"Attendance", 'String'>
    readonly checkInAt: FieldRef<"Attendance", 'DateTime'>
    readonly checkOutAt: FieldRef<"Attendance", 'DateTime'>
    readonly deletedAt: FieldRef<"Attendance", 'DateTime'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    startTime: string | null
    endTime: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    startTime: string | null
    endTime: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    startTime: number
    endTime: number
    daysOfWeek: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    startTime?: true
    endTime?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    startTime?: true
    endTime?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    startTime?: true
    endTime?: true
    daysOfWeek?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: string
    companyId: string
    name: string
    startTime: string
    endTime: string
    daysOfWeek: string[]
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    daysOfWeek?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employees?: boolean | Schedule$employeesArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    daysOfWeek?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    daysOfWeek?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    daysOfWeek?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "name" | "startTime" | "endTime" | "daysOfWeek" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["schedule"]>
  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employees?: boolean | Schedule$employeesArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      startTime: string
      endTime: string
      daysOfWeek: string[]
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {ScheduleCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules and returns the data updated in the database.
     * @param {ScheduleUpdateManyAndReturnArgs} args - Arguments to update many Schedules.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employees<T extends Schedule$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>
    readonly companyId: FieldRef<"Schedule", 'String'>
    readonly name: FieldRef<"Schedule", 'String'>
    readonly startTime: FieldRef<"Schedule", 'String'>
    readonly endTime: FieldRef<"Schedule", 'String'>
    readonly daysOfWeek: FieldRef<"Schedule", 'String[]'>
    readonly deletedAt: FieldRef<"Schedule", 'DateTime'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule createManyAndReturn
   */
  export type ScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedule updateManyAndReturn
   */
  export type ScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedule.employees
   */
  export type Schedule$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model Overtime
   */

  export type AggregateOvertime = {
    _count: OvertimeCountAggregateOutputType | null
    _avg: OvertimeAvgAggregateOutputType | null
    _sum: OvertimeSumAggregateOutputType | null
    _min: OvertimeMinAggregateOutputType | null
    _max: OvertimeMaxAggregateOutputType | null
  }

  export type OvertimeAvgAggregateOutputType = {
    hours: number | null
  }

  export type OvertimeSumAggregateOutputType = {
    hours: number | null
  }

  export type OvertimeMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    userId: string | null
    date: Date | null
    hours: number | null
    reason: string | null
    status: $Enums.OvertimeStatus | null
    approvedByUserId: string | null
    approvedAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OvertimeMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    userId: string | null
    date: Date | null
    hours: number | null
    reason: string | null
    status: $Enums.OvertimeStatus | null
    approvedByUserId: string | null
    approvedAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OvertimeCountAggregateOutputType = {
    id: number
    companyId: number
    userId: number
    date: number
    hours: number
    reason: number
    status: number
    approvedByUserId: number
    approvedAt: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OvertimeAvgAggregateInputType = {
    hours?: true
  }

  export type OvertimeSumAggregateInputType = {
    hours?: true
  }

  export type OvertimeMinAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    date?: true
    hours?: true
    reason?: true
    status?: true
    approvedByUserId?: true
    approvedAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OvertimeMaxAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    date?: true
    hours?: true
    reason?: true
    status?: true
    approvedByUserId?: true
    approvedAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OvertimeCountAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    date?: true
    hours?: true
    reason?: true
    status?: true
    approvedByUserId?: true
    approvedAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OvertimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Overtime to aggregate.
     */
    where?: OvertimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overtimes to fetch.
     */
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OvertimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Overtimes
    **/
    _count?: true | OvertimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OvertimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OvertimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OvertimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OvertimeMaxAggregateInputType
  }

  export type GetOvertimeAggregateType<T extends OvertimeAggregateArgs> = {
        [P in keyof T & keyof AggregateOvertime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOvertime[P]>
      : GetScalarType<T[P], AggregateOvertime[P]>
  }




  export type OvertimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimeWhereInput
    orderBy?: OvertimeOrderByWithAggregationInput | OvertimeOrderByWithAggregationInput[]
    by: OvertimeScalarFieldEnum[] | OvertimeScalarFieldEnum
    having?: OvertimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OvertimeCountAggregateInputType | true
    _avg?: OvertimeAvgAggregateInputType
    _sum?: OvertimeSumAggregateInputType
    _min?: OvertimeMinAggregateInputType
    _max?: OvertimeMaxAggregateInputType
  }

  export type OvertimeGroupByOutputType = {
    id: string
    companyId: string
    userId: string
    date: Date
    hours: number
    reason: string | null
    status: $Enums.OvertimeStatus
    approvedByUserId: string | null
    approvedAt: Date | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OvertimeCountAggregateOutputType | null
    _avg: OvertimeAvgAggregateOutputType | null
    _sum: OvertimeSumAggregateOutputType | null
    _min: OvertimeMinAggregateOutputType | null
    _max: OvertimeMaxAggregateOutputType | null
  }

  type GetOvertimeGroupByPayload<T extends OvertimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OvertimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OvertimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OvertimeGroupByOutputType[P]>
            : GetScalarType<T[P], OvertimeGroupByOutputType[P]>
        }
      >
    >


  export type OvertimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    date?: boolean
    hours?: boolean
    reason?: boolean
    status?: boolean
    approvedByUserId?: boolean
    approvedAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Overtime$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["overtime"]>

  export type OvertimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    date?: boolean
    hours?: boolean
    reason?: boolean
    status?: boolean
    approvedByUserId?: boolean
    approvedAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Overtime$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["overtime"]>

  export type OvertimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    date?: boolean
    hours?: boolean
    reason?: boolean
    status?: boolean
    approvedByUserId?: boolean
    approvedAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Overtime$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["overtime"]>

  export type OvertimeSelectScalar = {
    id?: boolean
    companyId?: boolean
    userId?: boolean
    date?: boolean
    hours?: boolean
    reason?: boolean
    status?: boolean
    approvedByUserId?: boolean
    approvedAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OvertimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "userId" | "date" | "hours" | "reason" | "status" | "approvedByUserId" | "approvedAt" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["overtime"]>
  export type OvertimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Overtime$approvedByArgs<ExtArgs>
  }
  export type OvertimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Overtime$approvedByArgs<ExtArgs>
  }
  export type OvertimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Overtime$approvedByArgs<ExtArgs>
  }

  export type $OvertimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Overtime"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      userId: string
      date: Date
      hours: number
      reason: string | null
      status: $Enums.OvertimeStatus
      approvedByUserId: string | null
      approvedAt: Date | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["overtime"]>
    composites: {}
  }

  type OvertimeGetPayload<S extends boolean | null | undefined | OvertimeDefaultArgs> = $Result.GetResult<Prisma.$OvertimePayload, S>

  type OvertimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OvertimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OvertimeCountAggregateInputType | true
    }

  export interface OvertimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Overtime'], meta: { name: 'Overtime' } }
    /**
     * Find zero or one Overtime that matches the filter.
     * @param {OvertimeFindUniqueArgs} args - Arguments to find a Overtime
     * @example
     * // Get one Overtime
     * const overtime = await prisma.overtime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OvertimeFindUniqueArgs>(args: SelectSubset<T, OvertimeFindUniqueArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Overtime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OvertimeFindUniqueOrThrowArgs} args - Arguments to find a Overtime
     * @example
     * // Get one Overtime
     * const overtime = await prisma.overtime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OvertimeFindUniqueOrThrowArgs>(args: SelectSubset<T, OvertimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Overtime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeFindFirstArgs} args - Arguments to find a Overtime
     * @example
     * // Get one Overtime
     * const overtime = await prisma.overtime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OvertimeFindFirstArgs>(args?: SelectSubset<T, OvertimeFindFirstArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Overtime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeFindFirstOrThrowArgs} args - Arguments to find a Overtime
     * @example
     * // Get one Overtime
     * const overtime = await prisma.overtime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OvertimeFindFirstOrThrowArgs>(args?: SelectSubset<T, OvertimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Overtimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Overtimes
     * const overtimes = await prisma.overtime.findMany()
     * 
     * // Get first 10 Overtimes
     * const overtimes = await prisma.overtime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const overtimeWithIdOnly = await prisma.overtime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OvertimeFindManyArgs>(args?: SelectSubset<T, OvertimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Overtime.
     * @param {OvertimeCreateArgs} args - Arguments to create a Overtime.
     * @example
     * // Create one Overtime
     * const Overtime = await prisma.overtime.create({
     *   data: {
     *     // ... data to create a Overtime
     *   }
     * })
     * 
     */
    create<T extends OvertimeCreateArgs>(args: SelectSubset<T, OvertimeCreateArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Overtimes.
     * @param {OvertimeCreateManyArgs} args - Arguments to create many Overtimes.
     * @example
     * // Create many Overtimes
     * const overtime = await prisma.overtime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OvertimeCreateManyArgs>(args?: SelectSubset<T, OvertimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Overtimes and returns the data saved in the database.
     * @param {OvertimeCreateManyAndReturnArgs} args - Arguments to create many Overtimes.
     * @example
     * // Create many Overtimes
     * const overtime = await prisma.overtime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Overtimes and only return the `id`
     * const overtimeWithIdOnly = await prisma.overtime.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OvertimeCreateManyAndReturnArgs>(args?: SelectSubset<T, OvertimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Overtime.
     * @param {OvertimeDeleteArgs} args - Arguments to delete one Overtime.
     * @example
     * // Delete one Overtime
     * const Overtime = await prisma.overtime.delete({
     *   where: {
     *     // ... filter to delete one Overtime
     *   }
     * })
     * 
     */
    delete<T extends OvertimeDeleteArgs>(args: SelectSubset<T, OvertimeDeleteArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Overtime.
     * @param {OvertimeUpdateArgs} args - Arguments to update one Overtime.
     * @example
     * // Update one Overtime
     * const overtime = await prisma.overtime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OvertimeUpdateArgs>(args: SelectSubset<T, OvertimeUpdateArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Overtimes.
     * @param {OvertimeDeleteManyArgs} args - Arguments to filter Overtimes to delete.
     * @example
     * // Delete a few Overtimes
     * const { count } = await prisma.overtime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OvertimeDeleteManyArgs>(args?: SelectSubset<T, OvertimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Overtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Overtimes
     * const overtime = await prisma.overtime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OvertimeUpdateManyArgs>(args: SelectSubset<T, OvertimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Overtimes and returns the data updated in the database.
     * @param {OvertimeUpdateManyAndReturnArgs} args - Arguments to update many Overtimes.
     * @example
     * // Update many Overtimes
     * const overtime = await prisma.overtime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Overtimes and only return the `id`
     * const overtimeWithIdOnly = await prisma.overtime.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OvertimeUpdateManyAndReturnArgs>(args: SelectSubset<T, OvertimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Overtime.
     * @param {OvertimeUpsertArgs} args - Arguments to update or create a Overtime.
     * @example
     * // Update or create a Overtime
     * const overtime = await prisma.overtime.upsert({
     *   create: {
     *     // ... data to create a Overtime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Overtime we want to update
     *   }
     * })
     */
    upsert<T extends OvertimeUpsertArgs>(args: SelectSubset<T, OvertimeUpsertArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Overtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeCountArgs} args - Arguments to filter Overtimes to count.
     * @example
     * // Count the number of Overtimes
     * const count = await prisma.overtime.count({
     *   where: {
     *     // ... the filter for the Overtimes we want to count
     *   }
     * })
    **/
    count<T extends OvertimeCountArgs>(
      args?: Subset<T, OvertimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OvertimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Overtime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OvertimeAggregateArgs>(args: Subset<T, OvertimeAggregateArgs>): Prisma.PrismaPromise<GetOvertimeAggregateType<T>>

    /**
     * Group by Overtime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OvertimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OvertimeGroupByArgs['orderBy'] }
        : { orderBy?: OvertimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OvertimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOvertimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Overtime model
   */
  readonly fields: OvertimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Overtime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OvertimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends Overtime$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Overtime$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Overtime model
   */
  interface OvertimeFieldRefs {
    readonly id: FieldRef<"Overtime", 'String'>
    readonly companyId: FieldRef<"Overtime", 'String'>
    readonly userId: FieldRef<"Overtime", 'String'>
    readonly date: FieldRef<"Overtime", 'DateTime'>
    readonly hours: FieldRef<"Overtime", 'Float'>
    readonly reason: FieldRef<"Overtime", 'String'>
    readonly status: FieldRef<"Overtime", 'OvertimeStatus'>
    readonly approvedByUserId: FieldRef<"Overtime", 'String'>
    readonly approvedAt: FieldRef<"Overtime", 'DateTime'>
    readonly deletedAt: FieldRef<"Overtime", 'DateTime'>
    readonly createdAt: FieldRef<"Overtime", 'DateTime'>
    readonly updatedAt: FieldRef<"Overtime", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Overtime findUnique
   */
  export type OvertimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtime to fetch.
     */
    where: OvertimeWhereUniqueInput
  }

  /**
   * Overtime findUniqueOrThrow
   */
  export type OvertimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtime to fetch.
     */
    where: OvertimeWhereUniqueInput
  }

  /**
   * Overtime findFirst
   */
  export type OvertimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtime to fetch.
     */
    where?: OvertimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overtimes to fetch.
     */
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Overtimes.
     */
    cursor?: OvertimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Overtimes.
     */
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * Overtime findFirstOrThrow
   */
  export type OvertimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtime to fetch.
     */
    where?: OvertimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overtimes to fetch.
     */
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Overtimes.
     */
    cursor?: OvertimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Overtimes.
     */
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * Overtime findMany
   */
  export type OvertimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtimes to fetch.
     */
    where?: OvertimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overtimes to fetch.
     */
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Overtimes.
     */
    cursor?: OvertimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overtimes.
     */
    skip?: number
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * Overtime create
   */
  export type OvertimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * The data needed to create a Overtime.
     */
    data: XOR<OvertimeCreateInput, OvertimeUncheckedCreateInput>
  }

  /**
   * Overtime createMany
   */
  export type OvertimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Overtimes.
     */
    data: OvertimeCreateManyInput | OvertimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Overtime createManyAndReturn
   */
  export type OvertimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * The data used to create many Overtimes.
     */
    data: OvertimeCreateManyInput | OvertimeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Overtime update
   */
  export type OvertimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * The data needed to update a Overtime.
     */
    data: XOR<OvertimeUpdateInput, OvertimeUncheckedUpdateInput>
    /**
     * Choose, which Overtime to update.
     */
    where: OvertimeWhereUniqueInput
  }

  /**
   * Overtime updateMany
   */
  export type OvertimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Overtimes.
     */
    data: XOR<OvertimeUpdateManyMutationInput, OvertimeUncheckedUpdateManyInput>
    /**
     * Filter which Overtimes to update
     */
    where?: OvertimeWhereInput
    /**
     * Limit how many Overtimes to update.
     */
    limit?: number
  }

  /**
   * Overtime updateManyAndReturn
   */
  export type OvertimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * The data used to update Overtimes.
     */
    data: XOR<OvertimeUpdateManyMutationInput, OvertimeUncheckedUpdateManyInput>
    /**
     * Filter which Overtimes to update
     */
    where?: OvertimeWhereInput
    /**
     * Limit how many Overtimes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Overtime upsert
   */
  export type OvertimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * The filter to search for the Overtime to update in case it exists.
     */
    where: OvertimeWhereUniqueInput
    /**
     * In case the Overtime found by the `where` argument doesn't exist, create a new Overtime with this data.
     */
    create: XOR<OvertimeCreateInput, OvertimeUncheckedCreateInput>
    /**
     * In case the Overtime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OvertimeUpdateInput, OvertimeUncheckedUpdateInput>
  }

  /**
   * Overtime delete
   */
  export type OvertimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter which Overtime to delete.
     */
    where: OvertimeWhereUniqueInput
  }

  /**
   * Overtime deleteMany
   */
  export type OvertimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Overtimes to delete
     */
    where?: OvertimeWhereInput
    /**
     * Limit how many Overtimes to delete.
     */
    limit?: number
  }

  /**
   * Overtime.approvedBy
   */
  export type Overtime$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Overtime without action
   */
  export type OvertimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceSummary
   */

  export type AggregateAttendanceSummary = {
    _count: AttendanceSummaryCountAggregateOutputType | null
    _avg: AttendanceSummaryAvgAggregateOutputType | null
    _sum: AttendanceSummarySumAggregateOutputType | null
    _min: AttendanceSummaryMinAggregateOutputType | null
    _max: AttendanceSummaryMaxAggregateOutputType | null
  }

  export type AttendanceSummaryAvgAggregateOutputType = {
    totalHours: number | null
    overtimeHours: number | null
  }

  export type AttendanceSummarySumAggregateOutputType = {
    totalHours: number | null
    overtimeHours: number | null
  }

  export type AttendanceSummaryMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    totalHours: number | null
    overtimeHours: number | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceSummaryMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    totalHours: number | null
    overtimeHours: number | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceSummaryCountAggregateOutputType = {
    id: number
    companyId: number
    periodStart: number
    periodEnd: number
    totalHours: number
    overtimeHours: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceSummaryAvgAggregateInputType = {
    totalHours?: true
    overtimeHours?: true
  }

  export type AttendanceSummarySumAggregateInputType = {
    totalHours?: true
    overtimeHours?: true
  }

  export type AttendanceSummaryMinAggregateInputType = {
    id?: true
    companyId?: true
    periodStart?: true
    periodEnd?: true
    totalHours?: true
    overtimeHours?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceSummaryMaxAggregateInputType = {
    id?: true
    companyId?: true
    periodStart?: true
    periodEnd?: true
    totalHours?: true
    overtimeHours?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceSummaryCountAggregateInputType = {
    id?: true
    companyId?: true
    periodStart?: true
    periodEnd?: true
    totalHours?: true
    overtimeHours?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceSummary to aggregate.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceSummaries
    **/
    _count?: true | AttendanceSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceSummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceSummaryMaxAggregateInputType
  }

  export type GetAttendanceSummaryAggregateType<T extends AttendanceSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceSummary[P]>
      : GetScalarType<T[P], AggregateAttendanceSummary[P]>
  }




  export type AttendanceSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceSummaryWhereInput
    orderBy?: AttendanceSummaryOrderByWithAggregationInput | AttendanceSummaryOrderByWithAggregationInput[]
    by: AttendanceSummaryScalarFieldEnum[] | AttendanceSummaryScalarFieldEnum
    having?: AttendanceSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceSummaryCountAggregateInputType | true
    _avg?: AttendanceSummaryAvgAggregateInputType
    _sum?: AttendanceSummarySumAggregateInputType
    _min?: AttendanceSummaryMinAggregateInputType
    _max?: AttendanceSummaryMaxAggregateInputType
  }

  export type AttendanceSummaryGroupByOutputType = {
    id: string
    companyId: string
    periodStart: Date
    periodEnd: Date
    totalHours: number
    overtimeHours: number
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AttendanceSummaryCountAggregateOutputType | null
    _avg: AttendanceSummaryAvgAggregateOutputType | null
    _sum: AttendanceSummarySumAggregateOutputType | null
    _min: AttendanceSummaryMinAggregateOutputType | null
    _max: AttendanceSummaryMaxAggregateOutputType | null
  }

  type GetAttendanceSummaryGroupByPayload<T extends AttendanceSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceSummaryGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalHours?: boolean
    overtimeHours?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payrolls?: boolean | AttendanceSummary$payrollsArgs<ExtArgs>
    _count?: boolean | AttendanceSummaryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceSummary"]>

  export type AttendanceSummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalHours?: boolean
    overtimeHours?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceSummary"]>

  export type AttendanceSummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalHours?: boolean
    overtimeHours?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceSummary"]>

  export type AttendanceSummarySelectScalar = {
    id?: boolean
    companyId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalHours?: boolean
    overtimeHours?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceSummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "periodStart" | "periodEnd" | "totalHours" | "overtimeHours" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["attendanceSummary"]>
  export type AttendanceSummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payrolls?: boolean | AttendanceSummary$payrollsArgs<ExtArgs>
    _count?: boolean | AttendanceSummaryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AttendanceSummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type AttendanceSummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $AttendanceSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceSummary"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      payrolls: Prisma.$PayrollPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      periodStart: Date
      periodEnd: Date
      totalHours: number
      overtimeHours: number
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendanceSummary"]>
    composites: {}
  }

  type AttendanceSummaryGetPayload<S extends boolean | null | undefined | AttendanceSummaryDefaultArgs> = $Result.GetResult<Prisma.$AttendanceSummaryPayload, S>

  type AttendanceSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceSummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceSummaryCountAggregateInputType | true
    }

  export interface AttendanceSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceSummary'], meta: { name: 'AttendanceSummary' } }
    /**
     * Find zero or one AttendanceSummary that matches the filter.
     * @param {AttendanceSummaryFindUniqueArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceSummaryFindUniqueArgs>(args: SelectSubset<T, AttendanceSummaryFindUniqueArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceSummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceSummaryFindUniqueOrThrowArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryFindFirstArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceSummaryFindFirstArgs>(args?: SelectSubset<T, AttendanceSummaryFindFirstArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryFindFirstOrThrowArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceSummaries
     * const attendanceSummaries = await prisma.attendanceSummary.findMany()
     * 
     * // Get first 10 AttendanceSummaries
     * const attendanceSummaries = await prisma.attendanceSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceSummaryWithIdOnly = await prisma.attendanceSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceSummaryFindManyArgs>(args?: SelectSubset<T, AttendanceSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceSummary.
     * @param {AttendanceSummaryCreateArgs} args - Arguments to create a AttendanceSummary.
     * @example
     * // Create one AttendanceSummary
     * const AttendanceSummary = await prisma.attendanceSummary.create({
     *   data: {
     *     // ... data to create a AttendanceSummary
     *   }
     * })
     * 
     */
    create<T extends AttendanceSummaryCreateArgs>(args: SelectSubset<T, AttendanceSummaryCreateArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceSummaries.
     * @param {AttendanceSummaryCreateManyArgs} args - Arguments to create many AttendanceSummaries.
     * @example
     * // Create many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceSummaryCreateManyArgs>(args?: SelectSubset<T, AttendanceSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceSummaries and returns the data saved in the database.
     * @param {AttendanceSummaryCreateManyAndReturnArgs} args - Arguments to create many AttendanceSummaries.
     * @example
     * // Create many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceSummaries and only return the `id`
     * const attendanceSummaryWithIdOnly = await prisma.attendanceSummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceSummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceSummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceSummary.
     * @param {AttendanceSummaryDeleteArgs} args - Arguments to delete one AttendanceSummary.
     * @example
     * // Delete one AttendanceSummary
     * const AttendanceSummary = await prisma.attendanceSummary.delete({
     *   where: {
     *     // ... filter to delete one AttendanceSummary
     *   }
     * })
     * 
     */
    delete<T extends AttendanceSummaryDeleteArgs>(args: SelectSubset<T, AttendanceSummaryDeleteArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceSummary.
     * @param {AttendanceSummaryUpdateArgs} args - Arguments to update one AttendanceSummary.
     * @example
     * // Update one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceSummaryUpdateArgs>(args: SelectSubset<T, AttendanceSummaryUpdateArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceSummaries.
     * @param {AttendanceSummaryDeleteManyArgs} args - Arguments to filter AttendanceSummaries to delete.
     * @example
     * // Delete a few AttendanceSummaries
     * const { count } = await prisma.attendanceSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceSummaryDeleteManyArgs>(args?: SelectSubset<T, AttendanceSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceSummaryUpdateManyArgs>(args: SelectSubset<T, AttendanceSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceSummaries and returns the data updated in the database.
     * @param {AttendanceSummaryUpdateManyAndReturnArgs} args - Arguments to update many AttendanceSummaries.
     * @example
     * // Update many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceSummaries and only return the `id`
     * const attendanceSummaryWithIdOnly = await prisma.attendanceSummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceSummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceSummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceSummary.
     * @param {AttendanceSummaryUpsertArgs} args - Arguments to update or create a AttendanceSummary.
     * @example
     * // Update or create a AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.upsert({
     *   create: {
     *     // ... data to create a AttendanceSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceSummary we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceSummaryUpsertArgs>(args: SelectSubset<T, AttendanceSummaryUpsertArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryCountArgs} args - Arguments to filter AttendanceSummaries to count.
     * @example
     * // Count the number of AttendanceSummaries
     * const count = await prisma.attendanceSummary.count({
     *   where: {
     *     // ... the filter for the AttendanceSummaries we want to count
     *   }
     * })
    **/
    count<T extends AttendanceSummaryCountArgs>(
      args?: Subset<T, AttendanceSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceSummaryAggregateArgs>(args: Subset<T, AttendanceSummaryAggregateArgs>): Prisma.PrismaPromise<GetAttendanceSummaryAggregateType<T>>

    /**
     * Group by AttendanceSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceSummaryGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceSummary model
   */
  readonly fields: AttendanceSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payrolls<T extends AttendanceSummary$payrollsArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceSummary$payrollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceSummary model
   */
  interface AttendanceSummaryFieldRefs {
    readonly id: FieldRef<"AttendanceSummary", 'String'>
    readonly companyId: FieldRef<"AttendanceSummary", 'String'>
    readonly periodStart: FieldRef<"AttendanceSummary", 'DateTime'>
    readonly periodEnd: FieldRef<"AttendanceSummary", 'DateTime'>
    readonly totalHours: FieldRef<"AttendanceSummary", 'Float'>
    readonly overtimeHours: FieldRef<"AttendanceSummary", 'Float'>
    readonly deletedAt: FieldRef<"AttendanceSummary", 'DateTime'>
    readonly createdAt: FieldRef<"AttendanceSummary", 'DateTime'>
    readonly updatedAt: FieldRef<"AttendanceSummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceSummary findUnique
   */
  export type AttendanceSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary findUniqueOrThrow
   */
  export type AttendanceSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary findFirst
   */
  export type AttendanceSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceSummaries.
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceSummaries.
     */
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * AttendanceSummary findFirstOrThrow
   */
  export type AttendanceSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceSummaries.
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceSummaries.
     */
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * AttendanceSummary findMany
   */
  export type AttendanceSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummaries to fetch.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceSummaries.
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * AttendanceSummary create
   */
  export type AttendanceSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceSummary.
     */
    data: XOR<AttendanceSummaryCreateInput, AttendanceSummaryUncheckedCreateInput>
  }

  /**
   * AttendanceSummary createMany
   */
  export type AttendanceSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceSummaries.
     */
    data: AttendanceSummaryCreateManyInput | AttendanceSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceSummary createManyAndReturn
   */
  export type AttendanceSummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceSummaries.
     */
    data: AttendanceSummaryCreateManyInput | AttendanceSummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceSummary update
   */
  export type AttendanceSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceSummary.
     */
    data: XOR<AttendanceSummaryUpdateInput, AttendanceSummaryUncheckedUpdateInput>
    /**
     * Choose, which AttendanceSummary to update.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary updateMany
   */
  export type AttendanceSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceSummaries.
     */
    data: XOR<AttendanceSummaryUpdateManyMutationInput, AttendanceSummaryUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceSummaries to update
     */
    where?: AttendanceSummaryWhereInput
    /**
     * Limit how many AttendanceSummaries to update.
     */
    limit?: number
  }

  /**
   * AttendanceSummary updateManyAndReturn
   */
  export type AttendanceSummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceSummaries.
     */
    data: XOR<AttendanceSummaryUpdateManyMutationInput, AttendanceSummaryUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceSummaries to update
     */
    where?: AttendanceSummaryWhereInput
    /**
     * Limit how many AttendanceSummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceSummary upsert
   */
  export type AttendanceSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceSummary to update in case it exists.
     */
    where: AttendanceSummaryWhereUniqueInput
    /**
     * In case the AttendanceSummary found by the `where` argument doesn't exist, create a new AttendanceSummary with this data.
     */
    create: XOR<AttendanceSummaryCreateInput, AttendanceSummaryUncheckedCreateInput>
    /**
     * In case the AttendanceSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceSummaryUpdateInput, AttendanceSummaryUncheckedUpdateInput>
  }

  /**
   * AttendanceSummary delete
   */
  export type AttendanceSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter which AttendanceSummary to delete.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary deleteMany
   */
  export type AttendanceSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceSummaries to delete
     */
    where?: AttendanceSummaryWhereInput
    /**
     * Limit how many AttendanceSummaries to delete.
     */
    limit?: number
  }

  /**
   * AttendanceSummary.payrolls
   */
  export type AttendanceSummary$payrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    cursor?: PayrollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * AttendanceSummary without action
   */
  export type AttendanceSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
  }


  /**
   * Model Payroll
   */

  export type AggregatePayroll = {
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  export type PayrollAvgAggregateOutputType = {
    grossPay: number | null
    netPay: number | null
  }

  export type PayrollSumAggregateOutputType = {
    grossPay: number | null
    netPay: number | null
  }

  export type PayrollMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    attendanceSummaryId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    grossPay: number | null
    netPay: number | null
    status: $Enums.PayrollStatus | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    attendanceSummaryId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    grossPay: number | null
    netPay: number | null
    status: $Enums.PayrollStatus | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollCountAggregateOutputType = {
    id: number
    companyId: number
    attendanceSummaryId: number
    periodStart: number
    periodEnd: number
    grossPay: number
    netPay: number
    status: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollAvgAggregateInputType = {
    grossPay?: true
    netPay?: true
  }

  export type PayrollSumAggregateInputType = {
    grossPay?: true
    netPay?: true
  }

  export type PayrollMinAggregateInputType = {
    id?: true
    companyId?: true
    attendanceSummaryId?: true
    periodStart?: true
    periodEnd?: true
    grossPay?: true
    netPay?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollMaxAggregateInputType = {
    id?: true
    companyId?: true
    attendanceSummaryId?: true
    periodStart?: true
    periodEnd?: true
    grossPay?: true
    netPay?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollCountAggregateInputType = {
    id?: true
    companyId?: true
    attendanceSummaryId?: true
    periodStart?: true
    periodEnd?: true
    grossPay?: true
    netPay?: true
    status?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payroll to aggregate.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payrolls
    **/
    _count?: true | PayrollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollMaxAggregateInputType
  }

  export type GetPayrollAggregateType<T extends PayrollAggregateArgs> = {
        [P in keyof T & keyof AggregatePayroll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayroll[P]>
      : GetScalarType<T[P], AggregatePayroll[P]>
  }




  export type PayrollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithAggregationInput | PayrollOrderByWithAggregationInput[]
    by: PayrollScalarFieldEnum[] | PayrollScalarFieldEnum
    having?: PayrollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollCountAggregateInputType | true
    _avg?: PayrollAvgAggregateInputType
    _sum?: PayrollSumAggregateInputType
    _min?: PayrollMinAggregateInputType
    _max?: PayrollMaxAggregateInputType
  }

  export type PayrollGroupByOutputType = {
    id: string
    companyId: string
    attendanceSummaryId: string
    periodStart: Date
    periodEnd: Date
    grossPay: number
    netPay: number
    status: $Enums.PayrollStatus
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  type GetPayrollGroupByPayload<T extends PayrollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollGroupByOutputType[P]>
        }
      >
    >


  export type PayrollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    attendanceSummaryId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    grossPay?: boolean
    netPay?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    attendanceSummary?: boolean | AttendanceSummaryDefaultArgs<ExtArgs>
    exports?: boolean | Payroll$exportsArgs<ExtArgs>
    _count?: boolean | PayrollCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    attendanceSummaryId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    grossPay?: boolean
    netPay?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    attendanceSummary?: boolean | AttendanceSummaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    attendanceSummaryId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    grossPay?: boolean
    netPay?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    attendanceSummary?: boolean | AttendanceSummaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectScalar = {
    id?: boolean
    companyId?: boolean
    attendanceSummaryId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    grossPay?: boolean
    netPay?: boolean
    status?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "attendanceSummaryId" | "periodStart" | "periodEnd" | "grossPay" | "netPay" | "status" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["payroll"]>
  export type PayrollInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    attendanceSummary?: boolean | AttendanceSummaryDefaultArgs<ExtArgs>
    exports?: boolean | Payroll$exportsArgs<ExtArgs>
    _count?: boolean | PayrollCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PayrollIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    attendanceSummary?: boolean | AttendanceSummaryDefaultArgs<ExtArgs>
  }
  export type PayrollIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    attendanceSummary?: boolean | AttendanceSummaryDefaultArgs<ExtArgs>
  }

  export type $PayrollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payroll"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      attendanceSummary: Prisma.$AttendanceSummaryPayload<ExtArgs>
      exports: Prisma.$PayrollExportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      attendanceSummaryId: string
      periodStart: Date
      periodEnd: Date
      grossPay: number
      netPay: number
      status: $Enums.PayrollStatus
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payroll"]>
    composites: {}
  }

  type PayrollGetPayload<S extends boolean | null | undefined | PayrollDefaultArgs> = $Result.GetResult<Prisma.$PayrollPayload, S>

  type PayrollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollCountAggregateInputType | true
    }

  export interface PayrollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payroll'], meta: { name: 'Payroll' } }
    /**
     * Find zero or one Payroll that matches the filter.
     * @param {PayrollFindUniqueArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollFindUniqueArgs>(args: SelectSubset<T, PayrollFindUniqueArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payroll that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollFindUniqueOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payroll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollFindFirstArgs>(args?: SelectSubset<T, PayrollFindFirstArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payroll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payrolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payrolls
     * const payrolls = await prisma.payroll.findMany()
     * 
     * // Get first 10 Payrolls
     * const payrolls = await prisma.payroll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollWithIdOnly = await prisma.payroll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollFindManyArgs>(args?: SelectSubset<T, PayrollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payroll.
     * @param {PayrollCreateArgs} args - Arguments to create a Payroll.
     * @example
     * // Create one Payroll
     * const Payroll = await prisma.payroll.create({
     *   data: {
     *     // ... data to create a Payroll
     *   }
     * })
     * 
     */
    create<T extends PayrollCreateArgs>(args: SelectSubset<T, PayrollCreateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payrolls.
     * @param {PayrollCreateManyArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollCreateManyArgs>(args?: SelectSubset<T, PayrollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payrolls and returns the data saved in the database.
     * @param {PayrollCreateManyAndReturnArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payrolls and only return the `id`
     * const payrollWithIdOnly = await prisma.payroll.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payroll.
     * @param {PayrollDeleteArgs} args - Arguments to delete one Payroll.
     * @example
     * // Delete one Payroll
     * const Payroll = await prisma.payroll.delete({
     *   where: {
     *     // ... filter to delete one Payroll
     *   }
     * })
     * 
     */
    delete<T extends PayrollDeleteArgs>(args: SelectSubset<T, PayrollDeleteArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payroll.
     * @param {PayrollUpdateArgs} args - Arguments to update one Payroll.
     * @example
     * // Update one Payroll
     * const payroll = await prisma.payroll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollUpdateArgs>(args: SelectSubset<T, PayrollUpdateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payrolls.
     * @param {PayrollDeleteManyArgs} args - Arguments to filter Payrolls to delete.
     * @example
     * // Delete a few Payrolls
     * const { count } = await prisma.payroll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollDeleteManyArgs>(args?: SelectSubset<T, PayrollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payrolls
     * const payroll = await prisma.payroll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollUpdateManyArgs>(args: SelectSubset<T, PayrollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrolls and returns the data updated in the database.
     * @param {PayrollUpdateManyAndReturnArgs} args - Arguments to update many Payrolls.
     * @example
     * // Update many Payrolls
     * const payroll = await prisma.payroll.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payrolls and only return the `id`
     * const payrollWithIdOnly = await prisma.payroll.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payroll.
     * @param {PayrollUpsertArgs} args - Arguments to update or create a Payroll.
     * @example
     * // Update or create a Payroll
     * const payroll = await prisma.payroll.upsert({
     *   create: {
     *     // ... data to create a Payroll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payroll we want to update
     *   }
     * })
     */
    upsert<T extends PayrollUpsertArgs>(args: SelectSubset<T, PayrollUpsertArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollCountArgs} args - Arguments to filter Payrolls to count.
     * @example
     * // Count the number of Payrolls
     * const count = await prisma.payroll.count({
     *   where: {
     *     // ... the filter for the Payrolls we want to count
     *   }
     * })
    **/
    count<T extends PayrollCountArgs>(
      args?: Subset<T, PayrollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollAggregateArgs>(args: Subset<T, PayrollAggregateArgs>): Prisma.PrismaPromise<GetPayrollAggregateType<T>>

    /**
     * Group by Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollGroupByArgs['orderBy'] }
        : { orderBy?: PayrollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payroll model
   */
  readonly fields: PayrollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payroll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendanceSummary<T extends AttendanceSummaryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceSummaryDefaultArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exports<T extends Payroll$exportsArgs<ExtArgs> = {}>(args?: Subset<T, Payroll$exportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollExportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payroll model
   */
  interface PayrollFieldRefs {
    readonly id: FieldRef<"Payroll", 'String'>
    readonly companyId: FieldRef<"Payroll", 'String'>
    readonly attendanceSummaryId: FieldRef<"Payroll", 'String'>
    readonly periodStart: FieldRef<"Payroll", 'DateTime'>
    readonly periodEnd: FieldRef<"Payroll", 'DateTime'>
    readonly grossPay: FieldRef<"Payroll", 'Float'>
    readonly netPay: FieldRef<"Payroll", 'Float'>
    readonly status: FieldRef<"Payroll", 'PayrollStatus'>
    readonly deletedAt: FieldRef<"Payroll", 'DateTime'>
    readonly createdAt: FieldRef<"Payroll", 'DateTime'>
    readonly updatedAt: FieldRef<"Payroll", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payroll findUnique
   */
  export type PayrollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findUniqueOrThrow
   */
  export type PayrollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findFirst
   */
  export type PayrollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findFirstOrThrow
   */
  export type PayrollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findMany
   */
  export type PayrollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payrolls to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll create
   */
  export type PayrollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to create a Payroll.
     */
    data: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
  }

  /**
   * Payroll createMany
   */
  export type PayrollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payroll createManyAndReturn
   */
  export type PayrollCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payroll update
   */
  export type PayrollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to update a Payroll.
     */
    data: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
    /**
     * Choose, which Payroll to update.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll updateMany
   */
  export type PayrollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payrolls.
     */
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyInput>
    /**
     * Filter which Payrolls to update
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to update.
     */
    limit?: number
  }

  /**
   * Payroll updateManyAndReturn
   */
  export type PayrollUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * The data used to update Payrolls.
     */
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyInput>
    /**
     * Filter which Payrolls to update
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payroll upsert
   */
  export type PayrollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The filter to search for the Payroll to update in case it exists.
     */
    where: PayrollWhereUniqueInput
    /**
     * In case the Payroll found by the `where` argument doesn't exist, create a new Payroll with this data.
     */
    create: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
    /**
     * In case the Payroll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
  }

  /**
   * Payroll delete
   */
  export type PayrollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter which Payroll to delete.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll deleteMany
   */
  export type PayrollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payrolls to delete
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to delete.
     */
    limit?: number
  }

  /**
   * Payroll.exports
   */
  export type Payroll$exportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportInclude<ExtArgs> | null
    where?: PayrollExportWhereInput
    orderBy?: PayrollExportOrderByWithRelationInput | PayrollExportOrderByWithRelationInput[]
    cursor?: PayrollExportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollExportScalarFieldEnum | PayrollExportScalarFieldEnum[]
  }

  /**
   * Payroll without action
   */
  export type PayrollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
  }


  /**
   * Model PayrollExport
   */

  export type AggregatePayrollExport = {
    _count: PayrollExportCountAggregateOutputType | null
    _min: PayrollExportMinAggregateOutputType | null
    _max: PayrollExportMaxAggregateOutputType | null
  }

  export type PayrollExportMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    payrollId: string | null
    format: $Enums.ExportFormat | null
    path: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollExportMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    payrollId: string | null
    format: $Enums.ExportFormat | null
    path: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollExportCountAggregateOutputType = {
    id: number
    companyId: number
    payrollId: number
    format: number
    path: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollExportMinAggregateInputType = {
    id?: true
    companyId?: true
    payrollId?: true
    format?: true
    path?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollExportMaxAggregateInputType = {
    id?: true
    companyId?: true
    payrollId?: true
    format?: true
    path?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollExportCountAggregateInputType = {
    id?: true
    companyId?: true
    payrollId?: true
    format?: true
    path?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollExportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollExport to aggregate.
     */
    where?: PayrollExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollExports to fetch.
     */
    orderBy?: PayrollExportOrderByWithRelationInput | PayrollExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollExports
    **/
    _count?: true | PayrollExportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollExportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollExportMaxAggregateInputType
  }

  export type GetPayrollExportAggregateType<T extends PayrollExportAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollExport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollExport[P]>
      : GetScalarType<T[P], AggregatePayrollExport[P]>
  }




  export type PayrollExportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollExportWhereInput
    orderBy?: PayrollExportOrderByWithAggregationInput | PayrollExportOrderByWithAggregationInput[]
    by: PayrollExportScalarFieldEnum[] | PayrollExportScalarFieldEnum
    having?: PayrollExportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollExportCountAggregateInputType | true
    _min?: PayrollExportMinAggregateInputType
    _max?: PayrollExportMaxAggregateInputType
  }

  export type PayrollExportGroupByOutputType = {
    id: string
    companyId: string
    payrollId: string
    format: $Enums.ExportFormat
    path: string
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PayrollExportCountAggregateOutputType | null
    _min: PayrollExportMinAggregateOutputType | null
    _max: PayrollExportMaxAggregateOutputType | null
  }

  type GetPayrollExportGroupByPayload<T extends PayrollExportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollExportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollExportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollExportGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollExportGroupByOutputType[P]>
        }
      >
    >


  export type PayrollExportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    payrollId?: boolean
    format?: boolean
    path?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollExport"]>

  export type PayrollExportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    payrollId?: boolean
    format?: boolean
    path?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollExport"]>

  export type PayrollExportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    payrollId?: boolean
    format?: boolean
    path?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollExport"]>

  export type PayrollExportSelectScalar = {
    id?: boolean
    companyId?: boolean
    payrollId?: boolean
    format?: boolean
    path?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollExportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "payrollId" | "format" | "path" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["payrollExport"]>
  export type PayrollExportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
  }
  export type PayrollExportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
  }
  export type PayrollExportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
  }

  export type $PayrollExportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayrollExport"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      payroll: Prisma.$PayrollPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      payrollId: string
      format: $Enums.ExportFormat
      path: string
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payrollExport"]>
    composites: {}
  }

  type PayrollExportGetPayload<S extends boolean | null | undefined | PayrollExportDefaultArgs> = $Result.GetResult<Prisma.$PayrollExportPayload, S>

  type PayrollExportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollExportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollExportCountAggregateInputType | true
    }

  export interface PayrollExportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollExport'], meta: { name: 'PayrollExport' } }
    /**
     * Find zero or one PayrollExport that matches the filter.
     * @param {PayrollExportFindUniqueArgs} args - Arguments to find a PayrollExport
     * @example
     * // Get one PayrollExport
     * const payrollExport = await prisma.payrollExport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollExportFindUniqueArgs>(args: SelectSubset<T, PayrollExportFindUniqueArgs<ExtArgs>>): Prisma__PayrollExportClient<$Result.GetResult<Prisma.$PayrollExportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayrollExport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollExportFindUniqueOrThrowArgs} args - Arguments to find a PayrollExport
     * @example
     * // Get one PayrollExport
     * const payrollExport = await prisma.payrollExport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollExportFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollExportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollExportClient<$Result.GetResult<Prisma.$PayrollExportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollExport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollExportFindFirstArgs} args - Arguments to find a PayrollExport
     * @example
     * // Get one PayrollExport
     * const payrollExport = await prisma.payrollExport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollExportFindFirstArgs>(args?: SelectSubset<T, PayrollExportFindFirstArgs<ExtArgs>>): Prisma__PayrollExportClient<$Result.GetResult<Prisma.$PayrollExportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollExport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollExportFindFirstOrThrowArgs} args - Arguments to find a PayrollExport
     * @example
     * // Get one PayrollExport
     * const payrollExport = await prisma.payrollExport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollExportFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollExportFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollExportClient<$Result.GetResult<Prisma.$PayrollExportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayrollExports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollExportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollExports
     * const payrollExports = await prisma.payrollExport.findMany()
     * 
     * // Get first 10 PayrollExports
     * const payrollExports = await prisma.payrollExport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollExportWithIdOnly = await prisma.payrollExport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollExportFindManyArgs>(args?: SelectSubset<T, PayrollExportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollExportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayrollExport.
     * @param {PayrollExportCreateArgs} args - Arguments to create a PayrollExport.
     * @example
     * // Create one PayrollExport
     * const PayrollExport = await prisma.payrollExport.create({
     *   data: {
     *     // ... data to create a PayrollExport
     *   }
     * })
     * 
     */
    create<T extends PayrollExportCreateArgs>(args: SelectSubset<T, PayrollExportCreateArgs<ExtArgs>>): Prisma__PayrollExportClient<$Result.GetResult<Prisma.$PayrollExportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayrollExports.
     * @param {PayrollExportCreateManyArgs} args - Arguments to create many PayrollExports.
     * @example
     * // Create many PayrollExports
     * const payrollExport = await prisma.payrollExport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollExportCreateManyArgs>(args?: SelectSubset<T, PayrollExportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayrollExports and returns the data saved in the database.
     * @param {PayrollExportCreateManyAndReturnArgs} args - Arguments to create many PayrollExports.
     * @example
     * // Create many PayrollExports
     * const payrollExport = await prisma.payrollExport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayrollExports and only return the `id`
     * const payrollExportWithIdOnly = await prisma.payrollExport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollExportCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollExportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollExportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayrollExport.
     * @param {PayrollExportDeleteArgs} args - Arguments to delete one PayrollExport.
     * @example
     * // Delete one PayrollExport
     * const PayrollExport = await prisma.payrollExport.delete({
     *   where: {
     *     // ... filter to delete one PayrollExport
     *   }
     * })
     * 
     */
    delete<T extends PayrollExportDeleteArgs>(args: SelectSubset<T, PayrollExportDeleteArgs<ExtArgs>>): Prisma__PayrollExportClient<$Result.GetResult<Prisma.$PayrollExportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayrollExport.
     * @param {PayrollExportUpdateArgs} args - Arguments to update one PayrollExport.
     * @example
     * // Update one PayrollExport
     * const payrollExport = await prisma.payrollExport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollExportUpdateArgs>(args: SelectSubset<T, PayrollExportUpdateArgs<ExtArgs>>): Prisma__PayrollExportClient<$Result.GetResult<Prisma.$PayrollExportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayrollExports.
     * @param {PayrollExportDeleteManyArgs} args - Arguments to filter PayrollExports to delete.
     * @example
     * // Delete a few PayrollExports
     * const { count } = await prisma.payrollExport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollExportDeleteManyArgs>(args?: SelectSubset<T, PayrollExportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollExportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollExports
     * const payrollExport = await prisma.payrollExport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollExportUpdateManyArgs>(args: SelectSubset<T, PayrollExportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollExports and returns the data updated in the database.
     * @param {PayrollExportUpdateManyAndReturnArgs} args - Arguments to update many PayrollExports.
     * @example
     * // Update many PayrollExports
     * const payrollExport = await prisma.payrollExport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayrollExports and only return the `id`
     * const payrollExportWithIdOnly = await prisma.payrollExport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollExportUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollExportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollExportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayrollExport.
     * @param {PayrollExportUpsertArgs} args - Arguments to update or create a PayrollExport.
     * @example
     * // Update or create a PayrollExport
     * const payrollExport = await prisma.payrollExport.upsert({
     *   create: {
     *     // ... data to create a PayrollExport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollExport we want to update
     *   }
     * })
     */
    upsert<T extends PayrollExportUpsertArgs>(args: SelectSubset<T, PayrollExportUpsertArgs<ExtArgs>>): Prisma__PayrollExportClient<$Result.GetResult<Prisma.$PayrollExportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayrollExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollExportCountArgs} args - Arguments to filter PayrollExports to count.
     * @example
     * // Count the number of PayrollExports
     * const count = await prisma.payrollExport.count({
     *   where: {
     *     // ... the filter for the PayrollExports we want to count
     *   }
     * })
    **/
    count<T extends PayrollExportCountArgs>(
      args?: Subset<T, PayrollExportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollExportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollExportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollExportAggregateArgs>(args: Subset<T, PayrollExportAggregateArgs>): Prisma.PrismaPromise<GetPayrollExportAggregateType<T>>

    /**
     * Group by PayrollExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollExportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollExportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollExportGroupByArgs['orderBy'] }
        : { orderBy?: PayrollExportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollExportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollExportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayrollExport model
   */
  readonly fields: PayrollExportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollExport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollExportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payroll<T extends PayrollDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PayrollDefaultArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayrollExport model
   */
  interface PayrollExportFieldRefs {
    readonly id: FieldRef<"PayrollExport", 'String'>
    readonly companyId: FieldRef<"PayrollExport", 'String'>
    readonly payrollId: FieldRef<"PayrollExport", 'String'>
    readonly format: FieldRef<"PayrollExport", 'ExportFormat'>
    readonly path: FieldRef<"PayrollExport", 'String'>
    readonly deletedAt: FieldRef<"PayrollExport", 'DateTime'>
    readonly createdAt: FieldRef<"PayrollExport", 'DateTime'>
    readonly updatedAt: FieldRef<"PayrollExport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PayrollExport findUnique
   */
  export type PayrollExportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportInclude<ExtArgs> | null
    /**
     * Filter, which PayrollExport to fetch.
     */
    where: PayrollExportWhereUniqueInput
  }

  /**
   * PayrollExport findUniqueOrThrow
   */
  export type PayrollExportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportInclude<ExtArgs> | null
    /**
     * Filter, which PayrollExport to fetch.
     */
    where: PayrollExportWhereUniqueInput
  }

  /**
   * PayrollExport findFirst
   */
  export type PayrollExportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportInclude<ExtArgs> | null
    /**
     * Filter, which PayrollExport to fetch.
     */
    where?: PayrollExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollExports to fetch.
     */
    orderBy?: PayrollExportOrderByWithRelationInput | PayrollExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollExports.
     */
    cursor?: PayrollExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollExports.
     */
    distinct?: PayrollExportScalarFieldEnum | PayrollExportScalarFieldEnum[]
  }

  /**
   * PayrollExport findFirstOrThrow
   */
  export type PayrollExportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportInclude<ExtArgs> | null
    /**
     * Filter, which PayrollExport to fetch.
     */
    where?: PayrollExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollExports to fetch.
     */
    orderBy?: PayrollExportOrderByWithRelationInput | PayrollExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollExports.
     */
    cursor?: PayrollExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollExports.
     */
    distinct?: PayrollExportScalarFieldEnum | PayrollExportScalarFieldEnum[]
  }

  /**
   * PayrollExport findMany
   */
  export type PayrollExportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportInclude<ExtArgs> | null
    /**
     * Filter, which PayrollExports to fetch.
     */
    where?: PayrollExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollExports to fetch.
     */
    orderBy?: PayrollExportOrderByWithRelationInput | PayrollExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollExports.
     */
    cursor?: PayrollExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollExports.
     */
    skip?: number
    distinct?: PayrollExportScalarFieldEnum | PayrollExportScalarFieldEnum[]
  }

  /**
   * PayrollExport create
   */
  export type PayrollExportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollExport.
     */
    data: XOR<PayrollExportCreateInput, PayrollExportUncheckedCreateInput>
  }

  /**
   * PayrollExport createMany
   */
  export type PayrollExportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollExports.
     */
    data: PayrollExportCreateManyInput | PayrollExportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayrollExport createManyAndReturn
   */
  export type PayrollExportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * The data used to create many PayrollExports.
     */
    data: PayrollExportCreateManyInput | PayrollExportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollExport update
   */
  export type PayrollExportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollExport.
     */
    data: XOR<PayrollExportUpdateInput, PayrollExportUncheckedUpdateInput>
    /**
     * Choose, which PayrollExport to update.
     */
    where: PayrollExportWhereUniqueInput
  }

  /**
   * PayrollExport updateMany
   */
  export type PayrollExportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollExports.
     */
    data: XOR<PayrollExportUpdateManyMutationInput, PayrollExportUncheckedUpdateManyInput>
    /**
     * Filter which PayrollExports to update
     */
    where?: PayrollExportWhereInput
    /**
     * Limit how many PayrollExports to update.
     */
    limit?: number
  }

  /**
   * PayrollExport updateManyAndReturn
   */
  export type PayrollExportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * The data used to update PayrollExports.
     */
    data: XOR<PayrollExportUpdateManyMutationInput, PayrollExportUncheckedUpdateManyInput>
    /**
     * Filter which PayrollExports to update
     */
    where?: PayrollExportWhereInput
    /**
     * Limit how many PayrollExports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollExport upsert
   */
  export type PayrollExportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollExport to update in case it exists.
     */
    where: PayrollExportWhereUniqueInput
    /**
     * In case the PayrollExport found by the `where` argument doesn't exist, create a new PayrollExport with this data.
     */
    create: XOR<PayrollExportCreateInput, PayrollExportUncheckedCreateInput>
    /**
     * In case the PayrollExport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollExportUpdateInput, PayrollExportUncheckedUpdateInput>
  }

  /**
   * PayrollExport delete
   */
  export type PayrollExportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportInclude<ExtArgs> | null
    /**
     * Filter which PayrollExport to delete.
     */
    where: PayrollExportWhereUniqueInput
  }

  /**
   * PayrollExport deleteMany
   */
  export type PayrollExportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollExports to delete
     */
    where?: PayrollExportWhereInput
    /**
     * Limit how many PayrollExports to delete.
     */
    limit?: number
  }

  /**
   * PayrollExport without action
   */
  export type PayrollExportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollExport
     */
    select?: PayrollExportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollExport
     */
    omit?: PayrollExportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollExportInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    type: $Enums.ReportType | null
    periodStart: Date | null
    periodEnd: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    type: $Enums.ReportType | null
    periodStart: Date | null
    periodEnd: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    companyId: number
    type: number
    periodStart: number
    periodEnd: number
    data: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    companyId?: true
    type?: true
    periodStart?: true
    periodEnd?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    companyId?: true
    type?: true
    periodStart?: true
    periodEnd?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    companyId?: true
    type?: true
    periodStart?: true
    periodEnd?: true
    data?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    companyId: string
    type: $Enums.ReportType
    periodStart: Date
    periodEnd: Date
    data: JsonValue
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    type?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    data?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    type?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    data?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    type?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    data?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    companyId?: boolean
    type?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    data?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "type" | "periodStart" | "periodEnd" | "data" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      type: $Enums.ReportType
      periodStart: Date
      periodEnd: Date
      data: Prisma.JsonValue
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly companyId: FieldRef<"Report", 'String'>
    readonly type: FieldRef<"Report", 'ReportType'>
    readonly periodStart: FieldRef<"Report", 'DateTime'>
    readonly periodEnd: FieldRef<"Report", 'DateTime'>
    readonly data: FieldRef<"Report", 'Json'>
    readonly deletedAt: FieldRef<"Report", 'DateTime'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model PeriodClosure
   */

  export type AggregatePeriodClosure = {
    _count: PeriodClosureCountAggregateOutputType | null
    _min: PeriodClosureMinAggregateOutputType | null
    _max: PeriodClosureMaxAggregateOutputType | null
  }

  export type PeriodClosureMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    closedAt: Date | null
  }

  export type PeriodClosureMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    closedAt: Date | null
  }

  export type PeriodClosureCountAggregateOutputType = {
    id: number
    companyId: number
    periodStart: number
    periodEnd: number
    closedAt: number
    _all: number
  }


  export type PeriodClosureMinAggregateInputType = {
    id?: true
    companyId?: true
    periodStart?: true
    periodEnd?: true
    closedAt?: true
  }

  export type PeriodClosureMaxAggregateInputType = {
    id?: true
    companyId?: true
    periodStart?: true
    periodEnd?: true
    closedAt?: true
  }

  export type PeriodClosureCountAggregateInputType = {
    id?: true
    companyId?: true
    periodStart?: true
    periodEnd?: true
    closedAt?: true
    _all?: true
  }

  export type PeriodClosureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PeriodClosure to aggregate.
     */
    where?: PeriodClosureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeriodClosures to fetch.
     */
    orderBy?: PeriodClosureOrderByWithRelationInput | PeriodClosureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PeriodClosureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeriodClosures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeriodClosures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PeriodClosures
    **/
    _count?: true | PeriodClosureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PeriodClosureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PeriodClosureMaxAggregateInputType
  }

  export type GetPeriodClosureAggregateType<T extends PeriodClosureAggregateArgs> = {
        [P in keyof T & keyof AggregatePeriodClosure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeriodClosure[P]>
      : GetScalarType<T[P], AggregatePeriodClosure[P]>
  }




  export type PeriodClosureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PeriodClosureWhereInput
    orderBy?: PeriodClosureOrderByWithAggregationInput | PeriodClosureOrderByWithAggregationInput[]
    by: PeriodClosureScalarFieldEnum[] | PeriodClosureScalarFieldEnum
    having?: PeriodClosureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PeriodClosureCountAggregateInputType | true
    _min?: PeriodClosureMinAggregateInputType
    _max?: PeriodClosureMaxAggregateInputType
  }

  export type PeriodClosureGroupByOutputType = {
    id: string
    companyId: string
    periodStart: Date
    periodEnd: Date
    closedAt: Date
    _count: PeriodClosureCountAggregateOutputType | null
    _min: PeriodClosureMinAggregateOutputType | null
    _max: PeriodClosureMaxAggregateOutputType | null
  }

  type GetPeriodClosureGroupByPayload<T extends PeriodClosureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PeriodClosureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PeriodClosureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PeriodClosureGroupByOutputType[P]>
            : GetScalarType<T[P], PeriodClosureGroupByOutputType[P]>
        }
      >
    >


  export type PeriodClosureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    closedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["periodClosure"]>

  export type PeriodClosureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    closedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["periodClosure"]>

  export type PeriodClosureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    closedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["periodClosure"]>

  export type PeriodClosureSelectScalar = {
    id?: boolean
    companyId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    closedAt?: boolean
  }

  export type PeriodClosureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "periodStart" | "periodEnd" | "closedAt", ExtArgs["result"]["periodClosure"]>
  export type PeriodClosureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type PeriodClosureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type PeriodClosureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PeriodClosurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PeriodClosure"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      periodStart: Date
      periodEnd: Date
      closedAt: Date
    }, ExtArgs["result"]["periodClosure"]>
    composites: {}
  }

  type PeriodClosureGetPayload<S extends boolean | null | undefined | PeriodClosureDefaultArgs> = $Result.GetResult<Prisma.$PeriodClosurePayload, S>

  type PeriodClosureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PeriodClosureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PeriodClosureCountAggregateInputType | true
    }

  export interface PeriodClosureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PeriodClosure'], meta: { name: 'PeriodClosure' } }
    /**
     * Find zero or one PeriodClosure that matches the filter.
     * @param {PeriodClosureFindUniqueArgs} args - Arguments to find a PeriodClosure
     * @example
     * // Get one PeriodClosure
     * const periodClosure = await prisma.periodClosure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PeriodClosureFindUniqueArgs>(args: SelectSubset<T, PeriodClosureFindUniqueArgs<ExtArgs>>): Prisma__PeriodClosureClient<$Result.GetResult<Prisma.$PeriodClosurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PeriodClosure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PeriodClosureFindUniqueOrThrowArgs} args - Arguments to find a PeriodClosure
     * @example
     * // Get one PeriodClosure
     * const periodClosure = await prisma.periodClosure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PeriodClosureFindUniqueOrThrowArgs>(args: SelectSubset<T, PeriodClosureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PeriodClosureClient<$Result.GetResult<Prisma.$PeriodClosurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PeriodClosure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodClosureFindFirstArgs} args - Arguments to find a PeriodClosure
     * @example
     * // Get one PeriodClosure
     * const periodClosure = await prisma.periodClosure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PeriodClosureFindFirstArgs>(args?: SelectSubset<T, PeriodClosureFindFirstArgs<ExtArgs>>): Prisma__PeriodClosureClient<$Result.GetResult<Prisma.$PeriodClosurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PeriodClosure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodClosureFindFirstOrThrowArgs} args - Arguments to find a PeriodClosure
     * @example
     * // Get one PeriodClosure
     * const periodClosure = await prisma.periodClosure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PeriodClosureFindFirstOrThrowArgs>(args?: SelectSubset<T, PeriodClosureFindFirstOrThrowArgs<ExtArgs>>): Prisma__PeriodClosureClient<$Result.GetResult<Prisma.$PeriodClosurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PeriodClosures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodClosureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PeriodClosures
     * const periodClosures = await prisma.periodClosure.findMany()
     * 
     * // Get first 10 PeriodClosures
     * const periodClosures = await prisma.periodClosure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const periodClosureWithIdOnly = await prisma.periodClosure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PeriodClosureFindManyArgs>(args?: SelectSubset<T, PeriodClosureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodClosurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PeriodClosure.
     * @param {PeriodClosureCreateArgs} args - Arguments to create a PeriodClosure.
     * @example
     * // Create one PeriodClosure
     * const PeriodClosure = await prisma.periodClosure.create({
     *   data: {
     *     // ... data to create a PeriodClosure
     *   }
     * })
     * 
     */
    create<T extends PeriodClosureCreateArgs>(args: SelectSubset<T, PeriodClosureCreateArgs<ExtArgs>>): Prisma__PeriodClosureClient<$Result.GetResult<Prisma.$PeriodClosurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PeriodClosures.
     * @param {PeriodClosureCreateManyArgs} args - Arguments to create many PeriodClosures.
     * @example
     * // Create many PeriodClosures
     * const periodClosure = await prisma.periodClosure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PeriodClosureCreateManyArgs>(args?: SelectSubset<T, PeriodClosureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PeriodClosures and returns the data saved in the database.
     * @param {PeriodClosureCreateManyAndReturnArgs} args - Arguments to create many PeriodClosures.
     * @example
     * // Create many PeriodClosures
     * const periodClosure = await prisma.periodClosure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PeriodClosures and only return the `id`
     * const periodClosureWithIdOnly = await prisma.periodClosure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PeriodClosureCreateManyAndReturnArgs>(args?: SelectSubset<T, PeriodClosureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodClosurePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PeriodClosure.
     * @param {PeriodClosureDeleteArgs} args - Arguments to delete one PeriodClosure.
     * @example
     * // Delete one PeriodClosure
     * const PeriodClosure = await prisma.periodClosure.delete({
     *   where: {
     *     // ... filter to delete one PeriodClosure
     *   }
     * })
     * 
     */
    delete<T extends PeriodClosureDeleteArgs>(args: SelectSubset<T, PeriodClosureDeleteArgs<ExtArgs>>): Prisma__PeriodClosureClient<$Result.GetResult<Prisma.$PeriodClosurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PeriodClosure.
     * @param {PeriodClosureUpdateArgs} args - Arguments to update one PeriodClosure.
     * @example
     * // Update one PeriodClosure
     * const periodClosure = await prisma.periodClosure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PeriodClosureUpdateArgs>(args: SelectSubset<T, PeriodClosureUpdateArgs<ExtArgs>>): Prisma__PeriodClosureClient<$Result.GetResult<Prisma.$PeriodClosurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PeriodClosures.
     * @param {PeriodClosureDeleteManyArgs} args - Arguments to filter PeriodClosures to delete.
     * @example
     * // Delete a few PeriodClosures
     * const { count } = await prisma.periodClosure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PeriodClosureDeleteManyArgs>(args?: SelectSubset<T, PeriodClosureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PeriodClosures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodClosureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PeriodClosures
     * const periodClosure = await prisma.periodClosure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PeriodClosureUpdateManyArgs>(args: SelectSubset<T, PeriodClosureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PeriodClosures and returns the data updated in the database.
     * @param {PeriodClosureUpdateManyAndReturnArgs} args - Arguments to update many PeriodClosures.
     * @example
     * // Update many PeriodClosures
     * const periodClosure = await prisma.periodClosure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PeriodClosures and only return the `id`
     * const periodClosureWithIdOnly = await prisma.periodClosure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PeriodClosureUpdateManyAndReturnArgs>(args: SelectSubset<T, PeriodClosureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodClosurePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PeriodClosure.
     * @param {PeriodClosureUpsertArgs} args - Arguments to update or create a PeriodClosure.
     * @example
     * // Update or create a PeriodClosure
     * const periodClosure = await prisma.periodClosure.upsert({
     *   create: {
     *     // ... data to create a PeriodClosure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PeriodClosure we want to update
     *   }
     * })
     */
    upsert<T extends PeriodClosureUpsertArgs>(args: SelectSubset<T, PeriodClosureUpsertArgs<ExtArgs>>): Prisma__PeriodClosureClient<$Result.GetResult<Prisma.$PeriodClosurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PeriodClosures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodClosureCountArgs} args - Arguments to filter PeriodClosures to count.
     * @example
     * // Count the number of PeriodClosures
     * const count = await prisma.periodClosure.count({
     *   where: {
     *     // ... the filter for the PeriodClosures we want to count
     *   }
     * })
    **/
    count<T extends PeriodClosureCountArgs>(
      args?: Subset<T, PeriodClosureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeriodClosureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PeriodClosure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodClosureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeriodClosureAggregateArgs>(args: Subset<T, PeriodClosureAggregateArgs>): Prisma.PrismaPromise<GetPeriodClosureAggregateType<T>>

    /**
     * Group by PeriodClosure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodClosureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PeriodClosureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PeriodClosureGroupByArgs['orderBy'] }
        : { orderBy?: PeriodClosureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PeriodClosureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPeriodClosureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PeriodClosure model
   */
  readonly fields: PeriodClosureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PeriodClosure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PeriodClosureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PeriodClosure model
   */
  interface PeriodClosureFieldRefs {
    readonly id: FieldRef<"PeriodClosure", 'String'>
    readonly companyId: FieldRef<"PeriodClosure", 'String'>
    readonly periodStart: FieldRef<"PeriodClosure", 'DateTime'>
    readonly periodEnd: FieldRef<"PeriodClosure", 'DateTime'>
    readonly closedAt: FieldRef<"PeriodClosure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PeriodClosure findUnique
   */
  export type PeriodClosureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodClosure
     */
    select?: PeriodClosureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeriodClosure
     */
    omit?: PeriodClosureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodClosureInclude<ExtArgs> | null
    /**
     * Filter, which PeriodClosure to fetch.
     */
    where: PeriodClosureWhereUniqueInput
  }

  /**
   * PeriodClosure findUniqueOrThrow
   */
  export type PeriodClosureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodClosure
     */
    select?: PeriodClosureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeriodClosure
     */
    omit?: PeriodClosureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodClosureInclude<ExtArgs> | null
    /**
     * Filter, which PeriodClosure to fetch.
     */
    where: PeriodClosureWhereUniqueInput
  }

  /**
   * PeriodClosure findFirst
   */
  export type PeriodClosureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodClosure
     */
    select?: PeriodClosureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeriodClosure
     */
    omit?: PeriodClosureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodClosureInclude<ExtArgs> | null
    /**
     * Filter, which PeriodClosure to fetch.
     */
    where?: PeriodClosureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeriodClosures to fetch.
     */
    orderBy?: PeriodClosureOrderByWithRelationInput | PeriodClosureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PeriodClosures.
     */
    cursor?: PeriodClosureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeriodClosures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeriodClosures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PeriodClosures.
     */
    distinct?: PeriodClosureScalarFieldEnum | PeriodClosureScalarFieldEnum[]
  }

  /**
   * PeriodClosure findFirstOrThrow
   */
  export type PeriodClosureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodClosure
     */
    select?: PeriodClosureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeriodClosure
     */
    omit?: PeriodClosureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodClosureInclude<ExtArgs> | null
    /**
     * Filter, which PeriodClosure to fetch.
     */
    where?: PeriodClosureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeriodClosures to fetch.
     */
    orderBy?: PeriodClosureOrderByWithRelationInput | PeriodClosureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PeriodClosures.
     */
    cursor?: PeriodClosureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeriodClosures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeriodClosures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PeriodClosures.
     */
    distinct?: PeriodClosureScalarFieldEnum | PeriodClosureScalarFieldEnum[]
  }

  /**
   * PeriodClosure findMany
   */
  export type PeriodClosureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodClosure
     */
    select?: PeriodClosureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeriodClosure
     */
    omit?: PeriodClosureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodClosureInclude<ExtArgs> | null
    /**
     * Filter, which PeriodClosures to fetch.
     */
    where?: PeriodClosureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeriodClosures to fetch.
     */
    orderBy?: PeriodClosureOrderByWithRelationInput | PeriodClosureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PeriodClosures.
     */
    cursor?: PeriodClosureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeriodClosures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeriodClosures.
     */
    skip?: number
    distinct?: PeriodClosureScalarFieldEnum | PeriodClosureScalarFieldEnum[]
  }

  /**
   * PeriodClosure create
   */
  export type PeriodClosureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodClosure
     */
    select?: PeriodClosureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeriodClosure
     */
    omit?: PeriodClosureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodClosureInclude<ExtArgs> | null
    /**
     * The data needed to create a PeriodClosure.
     */
    data: XOR<PeriodClosureCreateInput, PeriodClosureUncheckedCreateInput>
  }

  /**
   * PeriodClosure createMany
   */
  export type PeriodClosureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PeriodClosures.
     */
    data: PeriodClosureCreateManyInput | PeriodClosureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PeriodClosure createManyAndReturn
   */
  export type PeriodClosureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodClosure
     */
    select?: PeriodClosureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PeriodClosure
     */
    omit?: PeriodClosureOmit<ExtArgs> | null
    /**
     * The data used to create many PeriodClosures.
     */
    data: PeriodClosureCreateManyInput | PeriodClosureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodClosureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PeriodClosure update
   */
  export type PeriodClosureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodClosure
     */
    select?: PeriodClosureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeriodClosure
     */
    omit?: PeriodClosureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodClosureInclude<ExtArgs> | null
    /**
     * The data needed to update a PeriodClosure.
     */
    data: XOR<PeriodClosureUpdateInput, PeriodClosureUncheckedUpdateInput>
    /**
     * Choose, which PeriodClosure to update.
     */
    where: PeriodClosureWhereUniqueInput
  }

  /**
   * PeriodClosure updateMany
   */
  export type PeriodClosureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PeriodClosures.
     */
    data: XOR<PeriodClosureUpdateManyMutationInput, PeriodClosureUncheckedUpdateManyInput>
    /**
     * Filter which PeriodClosures to update
     */
    where?: PeriodClosureWhereInput
    /**
     * Limit how many PeriodClosures to update.
     */
    limit?: number
  }

  /**
   * PeriodClosure updateManyAndReturn
   */
  export type PeriodClosureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodClosure
     */
    select?: PeriodClosureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PeriodClosure
     */
    omit?: PeriodClosureOmit<ExtArgs> | null
    /**
     * The data used to update PeriodClosures.
     */
    data: XOR<PeriodClosureUpdateManyMutationInput, PeriodClosureUncheckedUpdateManyInput>
    /**
     * Filter which PeriodClosures to update
     */
    where?: PeriodClosureWhereInput
    /**
     * Limit how many PeriodClosures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodClosureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PeriodClosure upsert
   */
  export type PeriodClosureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodClosure
     */
    select?: PeriodClosureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeriodClosure
     */
    omit?: PeriodClosureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodClosureInclude<ExtArgs> | null
    /**
     * The filter to search for the PeriodClosure to update in case it exists.
     */
    where: PeriodClosureWhereUniqueInput
    /**
     * In case the PeriodClosure found by the `where` argument doesn't exist, create a new PeriodClosure with this data.
     */
    create: XOR<PeriodClosureCreateInput, PeriodClosureUncheckedCreateInput>
    /**
     * In case the PeriodClosure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PeriodClosureUpdateInput, PeriodClosureUncheckedUpdateInput>
  }

  /**
   * PeriodClosure delete
   */
  export type PeriodClosureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodClosure
     */
    select?: PeriodClosureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeriodClosure
     */
    omit?: PeriodClosureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodClosureInclude<ExtArgs> | null
    /**
     * Filter which PeriodClosure to delete.
     */
    where: PeriodClosureWhereUniqueInput
  }

  /**
   * PeriodClosure deleteMany
   */
  export type PeriodClosureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PeriodClosures to delete
     */
    where?: PeriodClosureWhereInput
    /**
     * Limit how many PeriodClosures to delete.
     */
    limit?: number
  }

  /**
   * PeriodClosure without action
   */
  export type PeriodClosureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodClosure
     */
    select?: PeriodClosureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PeriodClosure
     */
    omit?: PeriodClosureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodClosureInclude<ExtArgs> | null
  }


  /**
   * Model SchoolClass
   */

  export type AggregateSchoolClass = {
    _count: SchoolClassCountAggregateOutputType | null
    _min: SchoolClassMinAggregateOutputType | null
    _max: SchoolClassMaxAggregateOutputType | null
  }

  export type SchoolClassMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    code: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolClassMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    code: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolClassCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    code: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolClassMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    code?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolClassMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    code?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolClassCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    code?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolClass to aggregate.
     */
    where?: SchoolClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolClasses to fetch.
     */
    orderBy?: SchoolClassOrderByWithRelationInput | SchoolClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolClasses
    **/
    _count?: true | SchoolClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolClassMaxAggregateInputType
  }

  export type GetSchoolClassAggregateType<T extends SchoolClassAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolClass[P]>
      : GetScalarType<T[P], AggregateSchoolClass[P]>
  }




  export type SchoolClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolClassWhereInput
    orderBy?: SchoolClassOrderByWithAggregationInput | SchoolClassOrderByWithAggregationInput[]
    by: SchoolClassScalarFieldEnum[] | SchoolClassScalarFieldEnum
    having?: SchoolClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolClassCountAggregateInputType | true
    _min?: SchoolClassMinAggregateInputType
    _max?: SchoolClassMaxAggregateInputType
  }

  export type SchoolClassGroupByOutputType = {
    id: string
    companyId: string
    name: string
    code: string
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SchoolClassCountAggregateOutputType | null
    _min: SchoolClassMinAggregateOutputType | null
    _max: SchoolClassMaxAggregateOutputType | null
  }

  type GetSchoolClassGroupByPayload<T extends SchoolClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolClassGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolClassGroupByOutputType[P]>
        }
      >
    >


  export type SchoolClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    code?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    courses?: boolean | SchoolClass$coursesArgs<ExtArgs>
    students?: boolean | SchoolClass$studentsArgs<ExtArgs>
    _count?: boolean | SchoolClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolClass"]>

  export type SchoolClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    code?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolClass"]>

  export type SchoolClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    code?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolClass"]>

  export type SchoolClassSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    code?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "name" | "code" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["schoolClass"]>
  export type SchoolClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    courses?: boolean | SchoolClass$coursesArgs<ExtArgs>
    students?: boolean | SchoolClass$studentsArgs<ExtArgs>
    _count?: boolean | SchoolClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type SchoolClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $SchoolClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolClass"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      courses: Prisma.$CoursePayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      code: string
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolClass"]>
    composites: {}
  }

  type SchoolClassGetPayload<S extends boolean | null | undefined | SchoolClassDefaultArgs> = $Result.GetResult<Prisma.$SchoolClassPayload, S>

  type SchoolClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolClassCountAggregateInputType | true
    }

  export interface SchoolClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolClass'], meta: { name: 'SchoolClass' } }
    /**
     * Find zero or one SchoolClass that matches the filter.
     * @param {SchoolClassFindUniqueArgs} args - Arguments to find a SchoolClass
     * @example
     * // Get one SchoolClass
     * const schoolClass = await prisma.schoolClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolClassFindUniqueArgs>(args: SelectSubset<T, SchoolClassFindUniqueArgs<ExtArgs>>): Prisma__SchoolClassClient<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SchoolClass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolClassFindUniqueOrThrowArgs} args - Arguments to find a SchoolClass
     * @example
     * // Get one SchoolClass
     * const schoolClass = await prisma.schoolClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolClassFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClassClient<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolClassFindFirstArgs} args - Arguments to find a SchoolClass
     * @example
     * // Get one SchoolClass
     * const schoolClass = await prisma.schoolClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolClassFindFirstArgs>(args?: SelectSubset<T, SchoolClassFindFirstArgs<ExtArgs>>): Prisma__SchoolClassClient<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolClassFindFirstOrThrowArgs} args - Arguments to find a SchoolClass
     * @example
     * // Get one SchoolClass
     * const schoolClass = await prisma.schoolClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolClassFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClassClient<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolClasses
     * const schoolClasses = await prisma.schoolClass.findMany()
     * 
     * // Get first 10 SchoolClasses
     * const schoolClasses = await prisma.schoolClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolClassWithIdOnly = await prisma.schoolClass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolClassFindManyArgs>(args?: SelectSubset<T, SchoolClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SchoolClass.
     * @param {SchoolClassCreateArgs} args - Arguments to create a SchoolClass.
     * @example
     * // Create one SchoolClass
     * const SchoolClass = await prisma.schoolClass.create({
     *   data: {
     *     // ... data to create a SchoolClass
     *   }
     * })
     * 
     */
    create<T extends SchoolClassCreateArgs>(args: SelectSubset<T, SchoolClassCreateArgs<ExtArgs>>): Prisma__SchoolClassClient<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SchoolClasses.
     * @param {SchoolClassCreateManyArgs} args - Arguments to create many SchoolClasses.
     * @example
     * // Create many SchoolClasses
     * const schoolClass = await prisma.schoolClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolClassCreateManyArgs>(args?: SelectSubset<T, SchoolClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolClasses and returns the data saved in the database.
     * @param {SchoolClassCreateManyAndReturnArgs} args - Arguments to create many SchoolClasses.
     * @example
     * // Create many SchoolClasses
     * const schoolClass = await prisma.schoolClass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolClasses and only return the `id`
     * const schoolClassWithIdOnly = await prisma.schoolClass.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolClassCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SchoolClass.
     * @param {SchoolClassDeleteArgs} args - Arguments to delete one SchoolClass.
     * @example
     * // Delete one SchoolClass
     * const SchoolClass = await prisma.schoolClass.delete({
     *   where: {
     *     // ... filter to delete one SchoolClass
     *   }
     * })
     * 
     */
    delete<T extends SchoolClassDeleteArgs>(args: SelectSubset<T, SchoolClassDeleteArgs<ExtArgs>>): Prisma__SchoolClassClient<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SchoolClass.
     * @param {SchoolClassUpdateArgs} args - Arguments to update one SchoolClass.
     * @example
     * // Update one SchoolClass
     * const schoolClass = await prisma.schoolClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolClassUpdateArgs>(args: SelectSubset<T, SchoolClassUpdateArgs<ExtArgs>>): Prisma__SchoolClassClient<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SchoolClasses.
     * @param {SchoolClassDeleteManyArgs} args - Arguments to filter SchoolClasses to delete.
     * @example
     * // Delete a few SchoolClasses
     * const { count } = await prisma.schoolClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolClassDeleteManyArgs>(args?: SelectSubset<T, SchoolClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolClasses
     * const schoolClass = await prisma.schoolClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolClassUpdateManyArgs>(args: SelectSubset<T, SchoolClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolClasses and returns the data updated in the database.
     * @param {SchoolClassUpdateManyAndReturnArgs} args - Arguments to update many SchoolClasses.
     * @example
     * // Update many SchoolClasses
     * const schoolClass = await prisma.schoolClass.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SchoolClasses and only return the `id`
     * const schoolClassWithIdOnly = await prisma.schoolClass.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolClassUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SchoolClass.
     * @param {SchoolClassUpsertArgs} args - Arguments to update or create a SchoolClass.
     * @example
     * // Update or create a SchoolClass
     * const schoolClass = await prisma.schoolClass.upsert({
     *   create: {
     *     // ... data to create a SchoolClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolClass we want to update
     *   }
     * })
     */
    upsert<T extends SchoolClassUpsertArgs>(args: SelectSubset<T, SchoolClassUpsertArgs<ExtArgs>>): Prisma__SchoolClassClient<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SchoolClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolClassCountArgs} args - Arguments to filter SchoolClasses to count.
     * @example
     * // Count the number of SchoolClasses
     * const count = await prisma.schoolClass.count({
     *   where: {
     *     // ... the filter for the SchoolClasses we want to count
     *   }
     * })
    **/
    count<T extends SchoolClassCountArgs>(
      args?: Subset<T, SchoolClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolClassAggregateArgs>(args: Subset<T, SchoolClassAggregateArgs>): Prisma.PrismaPromise<GetSchoolClassAggregateType<T>>

    /**
     * Group by SchoolClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolClassGroupByArgs['orderBy'] }
        : { orderBy?: SchoolClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolClass model
   */
  readonly fields: SchoolClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    courses<T extends SchoolClass$coursesArgs<ExtArgs> = {}>(args?: Subset<T, SchoolClass$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends SchoolClass$studentsArgs<ExtArgs> = {}>(args?: Subset<T, SchoolClass$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolClass model
   */
  interface SchoolClassFieldRefs {
    readonly id: FieldRef<"SchoolClass", 'String'>
    readonly companyId: FieldRef<"SchoolClass", 'String'>
    readonly name: FieldRef<"SchoolClass", 'String'>
    readonly code: FieldRef<"SchoolClass", 'String'>
    readonly deletedAt: FieldRef<"SchoolClass", 'DateTime'>
    readonly createdAt: FieldRef<"SchoolClass", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolClass", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolClass findUnique
   */
  export type SchoolClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClass
     */
    select?: SchoolClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolClass
     */
    omit?: SchoolClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolClassInclude<ExtArgs> | null
    /**
     * Filter, which SchoolClass to fetch.
     */
    where: SchoolClassWhereUniqueInput
  }

  /**
   * SchoolClass findUniqueOrThrow
   */
  export type SchoolClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClass
     */
    select?: SchoolClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolClass
     */
    omit?: SchoolClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolClassInclude<ExtArgs> | null
    /**
     * Filter, which SchoolClass to fetch.
     */
    where: SchoolClassWhereUniqueInput
  }

  /**
   * SchoolClass findFirst
   */
  export type SchoolClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClass
     */
    select?: SchoolClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolClass
     */
    omit?: SchoolClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolClassInclude<ExtArgs> | null
    /**
     * Filter, which SchoolClass to fetch.
     */
    where?: SchoolClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolClasses to fetch.
     */
    orderBy?: SchoolClassOrderByWithRelationInput | SchoolClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolClasses.
     */
    cursor?: SchoolClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolClasses.
     */
    distinct?: SchoolClassScalarFieldEnum | SchoolClassScalarFieldEnum[]
  }

  /**
   * SchoolClass findFirstOrThrow
   */
  export type SchoolClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClass
     */
    select?: SchoolClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolClass
     */
    omit?: SchoolClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolClassInclude<ExtArgs> | null
    /**
     * Filter, which SchoolClass to fetch.
     */
    where?: SchoolClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolClasses to fetch.
     */
    orderBy?: SchoolClassOrderByWithRelationInput | SchoolClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolClasses.
     */
    cursor?: SchoolClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolClasses.
     */
    distinct?: SchoolClassScalarFieldEnum | SchoolClassScalarFieldEnum[]
  }

  /**
   * SchoolClass findMany
   */
  export type SchoolClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClass
     */
    select?: SchoolClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolClass
     */
    omit?: SchoolClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolClassInclude<ExtArgs> | null
    /**
     * Filter, which SchoolClasses to fetch.
     */
    where?: SchoolClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolClasses to fetch.
     */
    orderBy?: SchoolClassOrderByWithRelationInput | SchoolClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolClasses.
     */
    cursor?: SchoolClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolClasses.
     */
    skip?: number
    distinct?: SchoolClassScalarFieldEnum | SchoolClassScalarFieldEnum[]
  }

  /**
   * SchoolClass create
   */
  export type SchoolClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClass
     */
    select?: SchoolClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolClass
     */
    omit?: SchoolClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolClassInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolClass.
     */
    data: XOR<SchoolClassCreateInput, SchoolClassUncheckedCreateInput>
  }

  /**
   * SchoolClass createMany
   */
  export type SchoolClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolClasses.
     */
    data: SchoolClassCreateManyInput | SchoolClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolClass createManyAndReturn
   */
  export type SchoolClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClass
     */
    select?: SchoolClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolClass
     */
    omit?: SchoolClassOmit<ExtArgs> | null
    /**
     * The data used to create many SchoolClasses.
     */
    data: SchoolClassCreateManyInput | SchoolClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolClass update
   */
  export type SchoolClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClass
     */
    select?: SchoolClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolClass
     */
    omit?: SchoolClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolClassInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolClass.
     */
    data: XOR<SchoolClassUpdateInput, SchoolClassUncheckedUpdateInput>
    /**
     * Choose, which SchoolClass to update.
     */
    where: SchoolClassWhereUniqueInput
  }

  /**
   * SchoolClass updateMany
   */
  export type SchoolClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolClasses.
     */
    data: XOR<SchoolClassUpdateManyMutationInput, SchoolClassUncheckedUpdateManyInput>
    /**
     * Filter which SchoolClasses to update
     */
    where?: SchoolClassWhereInput
    /**
     * Limit how many SchoolClasses to update.
     */
    limit?: number
  }

  /**
   * SchoolClass updateManyAndReturn
   */
  export type SchoolClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClass
     */
    select?: SchoolClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolClass
     */
    omit?: SchoolClassOmit<ExtArgs> | null
    /**
     * The data used to update SchoolClasses.
     */
    data: XOR<SchoolClassUpdateManyMutationInput, SchoolClassUncheckedUpdateManyInput>
    /**
     * Filter which SchoolClasses to update
     */
    where?: SchoolClassWhereInput
    /**
     * Limit how many SchoolClasses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolClass upsert
   */
  export type SchoolClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClass
     */
    select?: SchoolClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolClass
     */
    omit?: SchoolClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolClassInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolClass to update in case it exists.
     */
    where: SchoolClassWhereUniqueInput
    /**
     * In case the SchoolClass found by the `where` argument doesn't exist, create a new SchoolClass with this data.
     */
    create: XOR<SchoolClassCreateInput, SchoolClassUncheckedCreateInput>
    /**
     * In case the SchoolClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolClassUpdateInput, SchoolClassUncheckedUpdateInput>
  }

  /**
   * SchoolClass delete
   */
  export type SchoolClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClass
     */
    select?: SchoolClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolClass
     */
    omit?: SchoolClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolClassInclude<ExtArgs> | null
    /**
     * Filter which SchoolClass to delete.
     */
    where: SchoolClassWhereUniqueInput
  }

  /**
   * SchoolClass deleteMany
   */
  export type SchoolClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolClasses to delete
     */
    where?: SchoolClassWhereInput
    /**
     * Limit how many SchoolClasses to delete.
     */
    limit?: number
  }

  /**
   * SchoolClass.courses
   */
  export type SchoolClass$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * SchoolClass.students
   */
  export type SchoolClass$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * SchoolClass without action
   */
  export type SchoolClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolClass
     */
    select?: SchoolClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolClass
     */
    omit?: SchoolClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolClassInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    classId: string | null
    name: string | null
    code: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    classId: string | null
    name: string | null
    code: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    companyId: number
    classId: number
    name: number
    code: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseMinAggregateInputType = {
    id?: true
    companyId?: true
    classId?: true
    name?: true
    code?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    companyId?: true
    classId?: true
    name?: true
    code?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    companyId?: true
    classId?: true
    name?: true
    code?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    companyId: string
    classId: string
    name: string
    code: string
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    classId?: boolean
    name?: boolean
    code?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    class?: boolean | SchoolClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    classId?: boolean
    name?: boolean
    code?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    class?: boolean | SchoolClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    classId?: boolean
    name?: boolean
    code?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    class?: boolean | SchoolClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    companyId?: boolean
    classId?: boolean
    name?: boolean
    code?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "classId" | "name" | "code" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    class?: boolean | SchoolClassDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    class?: boolean | SchoolClassDefaultArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    class?: boolean | SchoolClassDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      class: Prisma.$SchoolClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      classId: string
      name: string
      code: string
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends SchoolClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolClassDefaultArgs<ExtArgs>>): Prisma__SchoolClassClient<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly companyId: FieldRef<"Course", 'String'>
    readonly classId: FieldRef<"Course", 'String'>
    readonly name: FieldRef<"Course", 'String'>
    readonly code: FieldRef<"Course", 'String'>
    readonly deletedAt: FieldRef<"Course", 'DateTime'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    classId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    personId: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    classId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    personId: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    companyId: number
    classId: number
    firstName: number
    lastName: number
    email: number
    personId: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    companyId?: true
    classId?: true
    firstName?: true
    lastName?: true
    email?: true
    personId?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    companyId?: true
    classId?: true
    firstName?: true
    lastName?: true
    email?: true
    personId?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    companyId?: true
    classId?: true
    firstName?: true
    lastName?: true
    email?: true
    personId?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    companyId: string
    classId: string
    firstName: string
    lastName: string
    email: string | null
    personId: string | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    classId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    personId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    class?: boolean | SchoolClassDefaultArgs<ExtArgs>
    person?: boolean | Student$personArgs<ExtArgs>
    attendance?: boolean | Student$attendanceArgs<ExtArgs>
    attendanceEvents?: boolean | Student$attendanceEventsArgs<ExtArgs>
    dailySummaries?: boolean | Student$dailySummariesArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    classId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    personId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    class?: boolean | SchoolClassDefaultArgs<ExtArgs>
    person?: boolean | Student$personArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    classId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    personId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    class?: boolean | SchoolClassDefaultArgs<ExtArgs>
    person?: boolean | Student$personArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    companyId?: boolean
    classId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    personId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "classId" | "firstName" | "lastName" | "email" | "personId" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    class?: boolean | SchoolClassDefaultArgs<ExtArgs>
    person?: boolean | Student$personArgs<ExtArgs>
    attendance?: boolean | Student$attendanceArgs<ExtArgs>
    attendanceEvents?: boolean | Student$attendanceEventsArgs<ExtArgs>
    dailySummaries?: boolean | Student$dailySummariesArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    class?: boolean | SchoolClassDefaultArgs<ExtArgs>
    person?: boolean | Student$personArgs<ExtArgs>
  }
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    class?: boolean | SchoolClassDefaultArgs<ExtArgs>
    person?: boolean | Student$personArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      class: Prisma.$SchoolClassPayload<ExtArgs>
      person: Prisma.$PersonPayload<ExtArgs> | null
      attendance: Prisma.$StudentAttendancePayload<ExtArgs>[]
      attendanceEvents: Prisma.$AttendanceEventPayload<ExtArgs>[]
      dailySummaries: Prisma.$AttendanceDailySummaryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      classId: string
      firstName: string
      lastName: string
      email: string | null
      /**
       * Optional link to Person for long-term identity unification.
       */
      personId: string | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends SchoolClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolClassDefaultArgs<ExtArgs>>): Prisma__SchoolClassClient<$Result.GetResult<Prisma.$SchoolClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    person<T extends Student$personArgs<ExtArgs> = {}>(args?: Subset<T, Student$personArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attendance<T extends Student$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Student$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceEvents<T extends Student$attendanceEventsArgs<ExtArgs> = {}>(args?: Subset<T, Student$attendanceEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailySummaries<T extends Student$dailySummariesArgs<ExtArgs> = {}>(args?: Subset<T, Student$dailySummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly companyId: FieldRef<"Student", 'String'>
    readonly classId: FieldRef<"Student", 'String'>
    readonly firstName: FieldRef<"Student", 'String'>
    readonly lastName: FieldRef<"Student", 'String'>
    readonly email: FieldRef<"Student", 'String'>
    readonly personId: FieldRef<"Student", 'String'>
    readonly deletedAt: FieldRef<"Student", 'DateTime'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.person
   */
  export type Student$personArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    where?: PersonWhereInput
  }

  /**
   * Student.attendance
   */
  export type Student$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    cursor?: StudentAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * Student.attendanceEvents
   */
  export type Student$attendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    where?: AttendanceEventWhereInput
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    cursor?: AttendanceEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * Student.dailySummaries
   */
  export type Student$dailySummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    where?: AttendanceDailySummaryWhereInput
    orderBy?: AttendanceDailySummaryOrderByWithRelationInput | AttendanceDailySummaryOrderByWithRelationInput[]
    cursor?: AttendanceDailySummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceDailySummaryScalarFieldEnum | AttendanceDailySummaryScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model StudentAttendance
   */

  export type AggregateStudentAttendance = {
    _count: StudentAttendanceCountAggregateOutputType | null
    _min: StudentAttendanceMinAggregateOutputType | null
    _max: StudentAttendanceMaxAggregateOutputType | null
  }

  export type StudentAttendanceMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    studentId: string | null
    date: Date | null
    status: $Enums.StudentAttendanceStatus | null
    note: string | null
    recordedByUserId: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAttendanceMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    studentId: string | null
    date: Date | null
    status: $Enums.StudentAttendanceStatus | null
    note: string | null
    recordedByUserId: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentAttendanceCountAggregateOutputType = {
    id: number
    companyId: number
    studentId: number
    date: number
    status: number
    note: number
    recordedByUserId: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAttendanceMinAggregateInputType = {
    id?: true
    companyId?: true
    studentId?: true
    date?: true
    status?: true
    note?: true
    recordedByUserId?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentAttendanceMaxAggregateInputType = {
    id?: true
    companyId?: true
    studentId?: true
    date?: true
    status?: true
    note?: true
    recordedByUserId?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentAttendanceCountAggregateInputType = {
    id?: true
    companyId?: true
    studentId?: true
    date?: true
    status?: true
    note?: true
    recordedByUserId?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAttendance to aggregate.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentAttendances
    **/
    _count?: true | StudentAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentAttendanceMaxAggregateInputType
  }

  export type GetStudentAttendanceAggregateType<T extends StudentAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentAttendance[P]>
      : GetScalarType<T[P], AggregateStudentAttendance[P]>
  }




  export type StudentAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithAggregationInput | StudentAttendanceOrderByWithAggregationInput[]
    by: StudentAttendanceScalarFieldEnum[] | StudentAttendanceScalarFieldEnum
    having?: StudentAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentAttendanceCountAggregateInputType | true
    _min?: StudentAttendanceMinAggregateInputType
    _max?: StudentAttendanceMaxAggregateInputType
  }

  export type StudentAttendanceGroupByOutputType = {
    id: string
    companyId: string
    studentId: string
    date: Date
    status: $Enums.StudentAttendanceStatus
    note: string | null
    recordedByUserId: string | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: StudentAttendanceCountAggregateOutputType | null
    _min: StudentAttendanceMinAggregateOutputType | null
    _max: StudentAttendanceMaxAggregateOutputType | null
  }

  type GetStudentAttendanceGroupByPayload<T extends StudentAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], StudentAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type StudentAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    studentId?: boolean
    date?: boolean
    status?: boolean
    note?: boolean
    recordedByUserId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    recordedBy?: boolean | StudentAttendance$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["studentAttendance"]>

  export type StudentAttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    studentId?: boolean
    date?: boolean
    status?: boolean
    note?: boolean
    recordedByUserId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    recordedBy?: boolean | StudentAttendance$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["studentAttendance"]>

  export type StudentAttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    studentId?: boolean
    date?: boolean
    status?: boolean
    note?: boolean
    recordedByUserId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    recordedBy?: boolean | StudentAttendance$recordedByArgs<ExtArgs>
  }, ExtArgs["result"]["studentAttendance"]>

  export type StudentAttendanceSelectScalar = {
    id?: boolean
    companyId?: boolean
    studentId?: boolean
    date?: boolean
    status?: boolean
    note?: boolean
    recordedByUserId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentAttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "studentId" | "date" | "status" | "note" | "recordedByUserId" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["studentAttendance"]>
  export type StudentAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    recordedBy?: boolean | StudentAttendance$recordedByArgs<ExtArgs>
  }
  export type StudentAttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    recordedBy?: boolean | StudentAttendance$recordedByArgs<ExtArgs>
  }
  export type StudentAttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    recordedBy?: boolean | StudentAttendance$recordedByArgs<ExtArgs>
  }

  export type $StudentAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentAttendance"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
      recordedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      studentId: string
      date: Date
      status: $Enums.StudentAttendanceStatus
      note: string | null
      recordedByUserId: string | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentAttendance"]>
    composites: {}
  }

  type StudentAttendanceGetPayload<S extends boolean | null | undefined | StudentAttendanceDefaultArgs> = $Result.GetResult<Prisma.$StudentAttendancePayload, S>

  type StudentAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentAttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentAttendanceCountAggregateInputType | true
    }

  export interface StudentAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentAttendance'], meta: { name: 'StudentAttendance' } }
    /**
     * Find zero or one StudentAttendance that matches the filter.
     * @param {StudentAttendanceFindUniqueArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentAttendanceFindUniqueArgs>(args: SelectSubset<T, StudentAttendanceFindUniqueArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentAttendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentAttendanceFindUniqueOrThrowArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindFirstArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentAttendanceFindFirstArgs>(args?: SelectSubset<T, StudentAttendanceFindFirstArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindFirstOrThrowArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentAttendances
     * const studentAttendances = await prisma.studentAttendance.findMany()
     * 
     * // Get first 10 StudentAttendances
     * const studentAttendances = await prisma.studentAttendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentAttendanceWithIdOnly = await prisma.studentAttendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentAttendanceFindManyArgs>(args?: SelectSubset<T, StudentAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentAttendance.
     * @param {StudentAttendanceCreateArgs} args - Arguments to create a StudentAttendance.
     * @example
     * // Create one StudentAttendance
     * const StudentAttendance = await prisma.studentAttendance.create({
     *   data: {
     *     // ... data to create a StudentAttendance
     *   }
     * })
     * 
     */
    create<T extends StudentAttendanceCreateArgs>(args: SelectSubset<T, StudentAttendanceCreateArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentAttendances.
     * @param {StudentAttendanceCreateManyArgs} args - Arguments to create many StudentAttendances.
     * @example
     * // Create many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentAttendanceCreateManyArgs>(args?: SelectSubset<T, StudentAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentAttendances and returns the data saved in the database.
     * @param {StudentAttendanceCreateManyAndReturnArgs} args - Arguments to create many StudentAttendances.
     * @example
     * // Create many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentAttendances and only return the `id`
     * const studentAttendanceWithIdOnly = await prisma.studentAttendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentAttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentAttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentAttendance.
     * @param {StudentAttendanceDeleteArgs} args - Arguments to delete one StudentAttendance.
     * @example
     * // Delete one StudentAttendance
     * const StudentAttendance = await prisma.studentAttendance.delete({
     *   where: {
     *     // ... filter to delete one StudentAttendance
     *   }
     * })
     * 
     */
    delete<T extends StudentAttendanceDeleteArgs>(args: SelectSubset<T, StudentAttendanceDeleteArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentAttendance.
     * @param {StudentAttendanceUpdateArgs} args - Arguments to update one StudentAttendance.
     * @example
     * // Update one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentAttendanceUpdateArgs>(args: SelectSubset<T, StudentAttendanceUpdateArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentAttendances.
     * @param {StudentAttendanceDeleteManyArgs} args - Arguments to filter StudentAttendances to delete.
     * @example
     * // Delete a few StudentAttendances
     * const { count } = await prisma.studentAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentAttendanceDeleteManyArgs>(args?: SelectSubset<T, StudentAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentAttendanceUpdateManyArgs>(args: SelectSubset<T, StudentAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAttendances and returns the data updated in the database.
     * @param {StudentAttendanceUpdateManyAndReturnArgs} args - Arguments to update many StudentAttendances.
     * @example
     * // Update many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentAttendances and only return the `id`
     * const studentAttendanceWithIdOnly = await prisma.studentAttendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentAttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentAttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentAttendance.
     * @param {StudentAttendanceUpsertArgs} args - Arguments to update or create a StudentAttendance.
     * @example
     * // Update or create a StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.upsert({
     *   create: {
     *     // ... data to create a StudentAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentAttendance we want to update
     *   }
     * })
     */
    upsert<T extends StudentAttendanceUpsertArgs>(args: SelectSubset<T, StudentAttendanceUpsertArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceCountArgs} args - Arguments to filter StudentAttendances to count.
     * @example
     * // Count the number of StudentAttendances
     * const count = await prisma.studentAttendance.count({
     *   where: {
     *     // ... the filter for the StudentAttendances we want to count
     *   }
     * })
    **/
    count<T extends StudentAttendanceCountArgs>(
      args?: Subset<T, StudentAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAttendanceAggregateArgs>(args: Subset<T, StudentAttendanceAggregateArgs>): Prisma.PrismaPromise<GetStudentAttendanceAggregateType<T>>

    /**
     * Group by StudentAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: StudentAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentAttendance model
   */
  readonly fields: StudentAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recordedBy<T extends StudentAttendance$recordedByArgs<ExtArgs> = {}>(args?: Subset<T, StudentAttendance$recordedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentAttendance model
   */
  interface StudentAttendanceFieldRefs {
    readonly id: FieldRef<"StudentAttendance", 'String'>
    readonly companyId: FieldRef<"StudentAttendance", 'String'>
    readonly studentId: FieldRef<"StudentAttendance", 'String'>
    readonly date: FieldRef<"StudentAttendance", 'DateTime'>
    readonly status: FieldRef<"StudentAttendance", 'StudentAttendanceStatus'>
    readonly note: FieldRef<"StudentAttendance", 'String'>
    readonly recordedByUserId: FieldRef<"StudentAttendance", 'String'>
    readonly deletedAt: FieldRef<"StudentAttendance", 'DateTime'>
    readonly createdAt: FieldRef<"StudentAttendance", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentAttendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentAttendance findUnique
   */
  export type StudentAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance findUniqueOrThrow
   */
  export type StudentAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance findFirst
   */
  export type StudentAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAttendances.
     */
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance findFirstOrThrow
   */
  export type StudentAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAttendances.
     */
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance findMany
   */
  export type StudentAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendances to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance create
   */
  export type StudentAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentAttendance.
     */
    data: XOR<StudentAttendanceCreateInput, StudentAttendanceUncheckedCreateInput>
  }

  /**
   * StudentAttendance createMany
   */
  export type StudentAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentAttendances.
     */
    data: StudentAttendanceCreateManyInput | StudentAttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentAttendance createManyAndReturn
   */
  export type StudentAttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many StudentAttendances.
     */
    data: StudentAttendanceCreateManyInput | StudentAttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentAttendance update
   */
  export type StudentAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentAttendance.
     */
    data: XOR<StudentAttendanceUpdateInput, StudentAttendanceUncheckedUpdateInput>
    /**
     * Choose, which StudentAttendance to update.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance updateMany
   */
  export type StudentAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentAttendances.
     */
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which StudentAttendances to update
     */
    where?: StudentAttendanceWhereInput
    /**
     * Limit how many StudentAttendances to update.
     */
    limit?: number
  }

  /**
   * StudentAttendance updateManyAndReturn
   */
  export type StudentAttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * The data used to update StudentAttendances.
     */
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which StudentAttendances to update
     */
    where?: StudentAttendanceWhereInput
    /**
     * Limit how many StudentAttendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentAttendance upsert
   */
  export type StudentAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentAttendance to update in case it exists.
     */
    where: StudentAttendanceWhereUniqueInput
    /**
     * In case the StudentAttendance found by the `where` argument doesn't exist, create a new StudentAttendance with this data.
     */
    create: XOR<StudentAttendanceCreateInput, StudentAttendanceUncheckedCreateInput>
    /**
     * In case the StudentAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentAttendanceUpdateInput, StudentAttendanceUncheckedUpdateInput>
  }

  /**
   * StudentAttendance delete
   */
  export type StudentAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter which StudentAttendance to delete.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance deleteMany
   */
  export type StudentAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAttendances to delete
     */
    where?: StudentAttendanceWhereInput
    /**
     * Limit how many StudentAttendances to delete.
     */
    limit?: number
  }

  /**
   * StudentAttendance.recordedBy
   */
  export type StudentAttendance$recordedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StudentAttendance without action
   */
  export type StudentAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAttendance
     */
    omit?: StudentAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
  }


  /**
   * Model ConstructionSite
   */

  export type AggregateConstructionSite = {
    _count: ConstructionSiteCountAggregateOutputType | null
    _avg: ConstructionSiteAvgAggregateOutputType | null
    _sum: ConstructionSiteSumAggregateOutputType | null
    _min: ConstructionSiteMinAggregateOutputType | null
    _max: ConstructionSiteMaxAggregateOutputType | null
  }

  export type ConstructionSiteAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type ConstructionSiteSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type ConstructionSiteMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    location: string | null
    latitude: number | null
    longitude: number | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConstructionSiteMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    location: string | null
    latitude: number | null
    longitude: number | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConstructionSiteCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    location: number
    latitude: number
    longitude: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConstructionSiteAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type ConstructionSiteSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type ConstructionSiteMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    location?: true
    latitude?: true
    longitude?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConstructionSiteMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    location?: true
    latitude?: true
    longitude?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConstructionSiteCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    location?: true
    latitude?: true
    longitude?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConstructionSiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionSite to aggregate.
     */
    where?: ConstructionSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionSites to fetch.
     */
    orderBy?: ConstructionSiteOrderByWithRelationInput | ConstructionSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConstructionSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConstructionSites
    **/
    _count?: true | ConstructionSiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConstructionSiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConstructionSiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConstructionSiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConstructionSiteMaxAggregateInputType
  }

  export type GetConstructionSiteAggregateType<T extends ConstructionSiteAggregateArgs> = {
        [P in keyof T & keyof AggregateConstructionSite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConstructionSite[P]>
      : GetScalarType<T[P], AggregateConstructionSite[P]>
  }




  export type ConstructionSiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConstructionSiteWhereInput
    orderBy?: ConstructionSiteOrderByWithAggregationInput | ConstructionSiteOrderByWithAggregationInput[]
    by: ConstructionSiteScalarFieldEnum[] | ConstructionSiteScalarFieldEnum
    having?: ConstructionSiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConstructionSiteCountAggregateInputType | true
    _avg?: ConstructionSiteAvgAggregateInputType
    _sum?: ConstructionSiteSumAggregateInputType
    _min?: ConstructionSiteMinAggregateInputType
    _max?: ConstructionSiteMaxAggregateInputType
  }

  export type ConstructionSiteGroupByOutputType = {
    id: string
    companyId: string
    name: string
    location: string | null
    latitude: number | null
    longitude: number | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ConstructionSiteCountAggregateOutputType | null
    _avg: ConstructionSiteAvgAggregateOutputType | null
    _sum: ConstructionSiteSumAggregateOutputType | null
    _min: ConstructionSiteMinAggregateOutputType | null
    _max: ConstructionSiteMaxAggregateOutputType | null
  }

  type GetConstructionSiteGroupByPayload<T extends ConstructionSiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConstructionSiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConstructionSiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConstructionSiteGroupByOutputType[P]>
            : GetScalarType<T[P], ConstructionSiteGroupByOutputType[P]>
        }
      >
    >


  export type ConstructionSiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    location?: boolean
    latitude?: boolean
    longitude?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    teams?: boolean | ConstructionSite$teamsArgs<ExtArgs>
    attendance?: boolean | ConstructionSite$attendanceArgs<ExtArgs>
    _count?: boolean | ConstructionSiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constructionSite"]>

  export type ConstructionSiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    location?: boolean
    latitude?: boolean
    longitude?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constructionSite"]>

  export type ConstructionSiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    location?: boolean
    latitude?: boolean
    longitude?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constructionSite"]>

  export type ConstructionSiteSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    location?: boolean
    latitude?: boolean
    longitude?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConstructionSiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "name" | "location" | "latitude" | "longitude" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["constructionSite"]>
  export type ConstructionSiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    teams?: boolean | ConstructionSite$teamsArgs<ExtArgs>
    attendance?: boolean | ConstructionSite$attendanceArgs<ExtArgs>
    _count?: boolean | ConstructionSiteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConstructionSiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ConstructionSiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ConstructionSitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConstructionSite"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      teams: Prisma.$ConstructionTeamPayload<ExtArgs>[]
      attendance: Prisma.$SiteAttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      location: string | null
      latitude: number | null
      longitude: number | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["constructionSite"]>
    composites: {}
  }

  type ConstructionSiteGetPayload<S extends boolean | null | undefined | ConstructionSiteDefaultArgs> = $Result.GetResult<Prisma.$ConstructionSitePayload, S>

  type ConstructionSiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConstructionSiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConstructionSiteCountAggregateInputType | true
    }

  export interface ConstructionSiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConstructionSite'], meta: { name: 'ConstructionSite' } }
    /**
     * Find zero or one ConstructionSite that matches the filter.
     * @param {ConstructionSiteFindUniqueArgs} args - Arguments to find a ConstructionSite
     * @example
     * // Get one ConstructionSite
     * const constructionSite = await prisma.constructionSite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConstructionSiteFindUniqueArgs>(args: SelectSubset<T, ConstructionSiteFindUniqueArgs<ExtArgs>>): Prisma__ConstructionSiteClient<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConstructionSite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConstructionSiteFindUniqueOrThrowArgs} args - Arguments to find a ConstructionSite
     * @example
     * // Get one ConstructionSite
     * const constructionSite = await prisma.constructionSite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConstructionSiteFindUniqueOrThrowArgs>(args: SelectSubset<T, ConstructionSiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConstructionSiteClient<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConstructionSite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionSiteFindFirstArgs} args - Arguments to find a ConstructionSite
     * @example
     * // Get one ConstructionSite
     * const constructionSite = await prisma.constructionSite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConstructionSiteFindFirstArgs>(args?: SelectSubset<T, ConstructionSiteFindFirstArgs<ExtArgs>>): Prisma__ConstructionSiteClient<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConstructionSite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionSiteFindFirstOrThrowArgs} args - Arguments to find a ConstructionSite
     * @example
     * // Get one ConstructionSite
     * const constructionSite = await prisma.constructionSite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConstructionSiteFindFirstOrThrowArgs>(args?: SelectSubset<T, ConstructionSiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConstructionSiteClient<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConstructionSites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionSiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConstructionSites
     * const constructionSites = await prisma.constructionSite.findMany()
     * 
     * // Get first 10 ConstructionSites
     * const constructionSites = await prisma.constructionSite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const constructionSiteWithIdOnly = await prisma.constructionSite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConstructionSiteFindManyArgs>(args?: SelectSubset<T, ConstructionSiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConstructionSite.
     * @param {ConstructionSiteCreateArgs} args - Arguments to create a ConstructionSite.
     * @example
     * // Create one ConstructionSite
     * const ConstructionSite = await prisma.constructionSite.create({
     *   data: {
     *     // ... data to create a ConstructionSite
     *   }
     * })
     * 
     */
    create<T extends ConstructionSiteCreateArgs>(args: SelectSubset<T, ConstructionSiteCreateArgs<ExtArgs>>): Prisma__ConstructionSiteClient<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConstructionSites.
     * @param {ConstructionSiteCreateManyArgs} args - Arguments to create many ConstructionSites.
     * @example
     * // Create many ConstructionSites
     * const constructionSite = await prisma.constructionSite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConstructionSiteCreateManyArgs>(args?: SelectSubset<T, ConstructionSiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConstructionSites and returns the data saved in the database.
     * @param {ConstructionSiteCreateManyAndReturnArgs} args - Arguments to create many ConstructionSites.
     * @example
     * // Create many ConstructionSites
     * const constructionSite = await prisma.constructionSite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConstructionSites and only return the `id`
     * const constructionSiteWithIdOnly = await prisma.constructionSite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConstructionSiteCreateManyAndReturnArgs>(args?: SelectSubset<T, ConstructionSiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConstructionSite.
     * @param {ConstructionSiteDeleteArgs} args - Arguments to delete one ConstructionSite.
     * @example
     * // Delete one ConstructionSite
     * const ConstructionSite = await prisma.constructionSite.delete({
     *   where: {
     *     // ... filter to delete one ConstructionSite
     *   }
     * })
     * 
     */
    delete<T extends ConstructionSiteDeleteArgs>(args: SelectSubset<T, ConstructionSiteDeleteArgs<ExtArgs>>): Prisma__ConstructionSiteClient<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConstructionSite.
     * @param {ConstructionSiteUpdateArgs} args - Arguments to update one ConstructionSite.
     * @example
     * // Update one ConstructionSite
     * const constructionSite = await prisma.constructionSite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConstructionSiteUpdateArgs>(args: SelectSubset<T, ConstructionSiteUpdateArgs<ExtArgs>>): Prisma__ConstructionSiteClient<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConstructionSites.
     * @param {ConstructionSiteDeleteManyArgs} args - Arguments to filter ConstructionSites to delete.
     * @example
     * // Delete a few ConstructionSites
     * const { count } = await prisma.constructionSite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConstructionSiteDeleteManyArgs>(args?: SelectSubset<T, ConstructionSiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConstructionSites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionSiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConstructionSites
     * const constructionSite = await prisma.constructionSite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConstructionSiteUpdateManyArgs>(args: SelectSubset<T, ConstructionSiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConstructionSites and returns the data updated in the database.
     * @param {ConstructionSiteUpdateManyAndReturnArgs} args - Arguments to update many ConstructionSites.
     * @example
     * // Update many ConstructionSites
     * const constructionSite = await prisma.constructionSite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConstructionSites and only return the `id`
     * const constructionSiteWithIdOnly = await prisma.constructionSite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConstructionSiteUpdateManyAndReturnArgs>(args: SelectSubset<T, ConstructionSiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConstructionSite.
     * @param {ConstructionSiteUpsertArgs} args - Arguments to update or create a ConstructionSite.
     * @example
     * // Update or create a ConstructionSite
     * const constructionSite = await prisma.constructionSite.upsert({
     *   create: {
     *     // ... data to create a ConstructionSite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConstructionSite we want to update
     *   }
     * })
     */
    upsert<T extends ConstructionSiteUpsertArgs>(args: SelectSubset<T, ConstructionSiteUpsertArgs<ExtArgs>>): Prisma__ConstructionSiteClient<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConstructionSites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionSiteCountArgs} args - Arguments to filter ConstructionSites to count.
     * @example
     * // Count the number of ConstructionSites
     * const count = await prisma.constructionSite.count({
     *   where: {
     *     // ... the filter for the ConstructionSites we want to count
     *   }
     * })
    **/
    count<T extends ConstructionSiteCountArgs>(
      args?: Subset<T, ConstructionSiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConstructionSiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConstructionSite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionSiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConstructionSiteAggregateArgs>(args: Subset<T, ConstructionSiteAggregateArgs>): Prisma.PrismaPromise<GetConstructionSiteAggregateType<T>>

    /**
     * Group by ConstructionSite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionSiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConstructionSiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConstructionSiteGroupByArgs['orderBy'] }
        : { orderBy?: ConstructionSiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConstructionSiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConstructionSiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConstructionSite model
   */
  readonly fields: ConstructionSiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConstructionSite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConstructionSiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teams<T extends ConstructionSite$teamsArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionSite$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends ConstructionSite$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionSite$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConstructionSite model
   */
  interface ConstructionSiteFieldRefs {
    readonly id: FieldRef<"ConstructionSite", 'String'>
    readonly companyId: FieldRef<"ConstructionSite", 'String'>
    readonly name: FieldRef<"ConstructionSite", 'String'>
    readonly location: FieldRef<"ConstructionSite", 'String'>
    readonly latitude: FieldRef<"ConstructionSite", 'Float'>
    readonly longitude: FieldRef<"ConstructionSite", 'Float'>
    readonly deletedAt: FieldRef<"ConstructionSite", 'DateTime'>
    readonly createdAt: FieldRef<"ConstructionSite", 'DateTime'>
    readonly updatedAt: FieldRef<"ConstructionSite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConstructionSite findUnique
   */
  export type ConstructionSiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSite
     */
    select?: ConstructionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionSite
     */
    omit?: ConstructionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionSiteInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionSite to fetch.
     */
    where: ConstructionSiteWhereUniqueInput
  }

  /**
   * ConstructionSite findUniqueOrThrow
   */
  export type ConstructionSiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSite
     */
    select?: ConstructionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionSite
     */
    omit?: ConstructionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionSiteInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionSite to fetch.
     */
    where: ConstructionSiteWhereUniqueInput
  }

  /**
   * ConstructionSite findFirst
   */
  export type ConstructionSiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSite
     */
    select?: ConstructionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionSite
     */
    omit?: ConstructionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionSiteInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionSite to fetch.
     */
    where?: ConstructionSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionSites to fetch.
     */
    orderBy?: ConstructionSiteOrderByWithRelationInput | ConstructionSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionSites.
     */
    cursor?: ConstructionSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionSites.
     */
    distinct?: ConstructionSiteScalarFieldEnum | ConstructionSiteScalarFieldEnum[]
  }

  /**
   * ConstructionSite findFirstOrThrow
   */
  export type ConstructionSiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSite
     */
    select?: ConstructionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionSite
     */
    omit?: ConstructionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionSiteInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionSite to fetch.
     */
    where?: ConstructionSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionSites to fetch.
     */
    orderBy?: ConstructionSiteOrderByWithRelationInput | ConstructionSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionSites.
     */
    cursor?: ConstructionSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionSites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionSites.
     */
    distinct?: ConstructionSiteScalarFieldEnum | ConstructionSiteScalarFieldEnum[]
  }

  /**
   * ConstructionSite findMany
   */
  export type ConstructionSiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSite
     */
    select?: ConstructionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionSite
     */
    omit?: ConstructionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionSiteInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionSites to fetch.
     */
    where?: ConstructionSiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionSites to fetch.
     */
    orderBy?: ConstructionSiteOrderByWithRelationInput | ConstructionSiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConstructionSites.
     */
    cursor?: ConstructionSiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionSites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionSites.
     */
    skip?: number
    distinct?: ConstructionSiteScalarFieldEnum | ConstructionSiteScalarFieldEnum[]
  }

  /**
   * ConstructionSite create
   */
  export type ConstructionSiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSite
     */
    select?: ConstructionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionSite
     */
    omit?: ConstructionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionSiteInclude<ExtArgs> | null
    /**
     * The data needed to create a ConstructionSite.
     */
    data: XOR<ConstructionSiteCreateInput, ConstructionSiteUncheckedCreateInput>
  }

  /**
   * ConstructionSite createMany
   */
  export type ConstructionSiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConstructionSites.
     */
    data: ConstructionSiteCreateManyInput | ConstructionSiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConstructionSite createManyAndReturn
   */
  export type ConstructionSiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSite
     */
    select?: ConstructionSiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionSite
     */
    omit?: ConstructionSiteOmit<ExtArgs> | null
    /**
     * The data used to create many ConstructionSites.
     */
    data: ConstructionSiteCreateManyInput | ConstructionSiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionSiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConstructionSite update
   */
  export type ConstructionSiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSite
     */
    select?: ConstructionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionSite
     */
    omit?: ConstructionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionSiteInclude<ExtArgs> | null
    /**
     * The data needed to update a ConstructionSite.
     */
    data: XOR<ConstructionSiteUpdateInput, ConstructionSiteUncheckedUpdateInput>
    /**
     * Choose, which ConstructionSite to update.
     */
    where: ConstructionSiteWhereUniqueInput
  }

  /**
   * ConstructionSite updateMany
   */
  export type ConstructionSiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConstructionSites.
     */
    data: XOR<ConstructionSiteUpdateManyMutationInput, ConstructionSiteUncheckedUpdateManyInput>
    /**
     * Filter which ConstructionSites to update
     */
    where?: ConstructionSiteWhereInput
    /**
     * Limit how many ConstructionSites to update.
     */
    limit?: number
  }

  /**
   * ConstructionSite updateManyAndReturn
   */
  export type ConstructionSiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSite
     */
    select?: ConstructionSiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionSite
     */
    omit?: ConstructionSiteOmit<ExtArgs> | null
    /**
     * The data used to update ConstructionSites.
     */
    data: XOR<ConstructionSiteUpdateManyMutationInput, ConstructionSiteUncheckedUpdateManyInput>
    /**
     * Filter which ConstructionSites to update
     */
    where?: ConstructionSiteWhereInput
    /**
     * Limit how many ConstructionSites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionSiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConstructionSite upsert
   */
  export type ConstructionSiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSite
     */
    select?: ConstructionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionSite
     */
    omit?: ConstructionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionSiteInclude<ExtArgs> | null
    /**
     * The filter to search for the ConstructionSite to update in case it exists.
     */
    where: ConstructionSiteWhereUniqueInput
    /**
     * In case the ConstructionSite found by the `where` argument doesn't exist, create a new ConstructionSite with this data.
     */
    create: XOR<ConstructionSiteCreateInput, ConstructionSiteUncheckedCreateInput>
    /**
     * In case the ConstructionSite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConstructionSiteUpdateInput, ConstructionSiteUncheckedUpdateInput>
  }

  /**
   * ConstructionSite delete
   */
  export type ConstructionSiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSite
     */
    select?: ConstructionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionSite
     */
    omit?: ConstructionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionSiteInclude<ExtArgs> | null
    /**
     * Filter which ConstructionSite to delete.
     */
    where: ConstructionSiteWhereUniqueInput
  }

  /**
   * ConstructionSite deleteMany
   */
  export type ConstructionSiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionSites to delete
     */
    where?: ConstructionSiteWhereInput
    /**
     * Limit how many ConstructionSites to delete.
     */
    limit?: number
  }

  /**
   * ConstructionSite.teams
   */
  export type ConstructionSite$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamInclude<ExtArgs> | null
    where?: ConstructionTeamWhereInput
    orderBy?: ConstructionTeamOrderByWithRelationInput | ConstructionTeamOrderByWithRelationInput[]
    cursor?: ConstructionTeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConstructionTeamScalarFieldEnum | ConstructionTeamScalarFieldEnum[]
  }

  /**
   * ConstructionSite.attendance
   */
  export type ConstructionSite$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceInclude<ExtArgs> | null
    where?: SiteAttendanceWhereInput
    orderBy?: SiteAttendanceOrderByWithRelationInput | SiteAttendanceOrderByWithRelationInput[]
    cursor?: SiteAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteAttendanceScalarFieldEnum | SiteAttendanceScalarFieldEnum[]
  }

  /**
   * ConstructionSite without action
   */
  export type ConstructionSiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionSite
     */
    select?: ConstructionSiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionSite
     */
    omit?: ConstructionSiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionSiteInclude<ExtArgs> | null
  }


  /**
   * Model ConstructionTeam
   */

  export type AggregateConstructionTeam = {
    _count: ConstructionTeamCountAggregateOutputType | null
    _min: ConstructionTeamMinAggregateOutputType | null
    _max: ConstructionTeamMaxAggregateOutputType | null
  }

  export type ConstructionTeamMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    siteId: string | null
    name: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConstructionTeamMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    siteId: string | null
    name: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConstructionTeamCountAggregateOutputType = {
    id: number
    companyId: number
    siteId: number
    name: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConstructionTeamMinAggregateInputType = {
    id?: true
    companyId?: true
    siteId?: true
    name?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConstructionTeamMaxAggregateInputType = {
    id?: true
    companyId?: true
    siteId?: true
    name?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConstructionTeamCountAggregateInputType = {
    id?: true
    companyId?: true
    siteId?: true
    name?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConstructionTeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionTeam to aggregate.
     */
    where?: ConstructionTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionTeams to fetch.
     */
    orderBy?: ConstructionTeamOrderByWithRelationInput | ConstructionTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConstructionTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConstructionTeams
    **/
    _count?: true | ConstructionTeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConstructionTeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConstructionTeamMaxAggregateInputType
  }

  export type GetConstructionTeamAggregateType<T extends ConstructionTeamAggregateArgs> = {
        [P in keyof T & keyof AggregateConstructionTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConstructionTeam[P]>
      : GetScalarType<T[P], AggregateConstructionTeam[P]>
  }




  export type ConstructionTeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConstructionTeamWhereInput
    orderBy?: ConstructionTeamOrderByWithAggregationInput | ConstructionTeamOrderByWithAggregationInput[]
    by: ConstructionTeamScalarFieldEnum[] | ConstructionTeamScalarFieldEnum
    having?: ConstructionTeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConstructionTeamCountAggregateInputType | true
    _min?: ConstructionTeamMinAggregateInputType
    _max?: ConstructionTeamMaxAggregateInputType
  }

  export type ConstructionTeamGroupByOutputType = {
    id: string
    companyId: string
    siteId: string
    name: string
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ConstructionTeamCountAggregateOutputType | null
    _min: ConstructionTeamMinAggregateOutputType | null
    _max: ConstructionTeamMaxAggregateOutputType | null
  }

  type GetConstructionTeamGroupByPayload<T extends ConstructionTeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConstructionTeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConstructionTeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConstructionTeamGroupByOutputType[P]>
            : GetScalarType<T[P], ConstructionTeamGroupByOutputType[P]>
        }
      >
    >


  export type ConstructionTeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    siteId?: boolean
    name?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    site?: boolean | ConstructionSiteDefaultArgs<ExtArgs>
    workers?: boolean | ConstructionTeam$workersArgs<ExtArgs>
    _count?: boolean | ConstructionTeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constructionTeam"]>

  export type ConstructionTeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    siteId?: boolean
    name?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    site?: boolean | ConstructionSiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constructionTeam"]>

  export type ConstructionTeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    siteId?: boolean
    name?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    site?: boolean | ConstructionSiteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constructionTeam"]>

  export type ConstructionTeamSelectScalar = {
    id?: boolean
    companyId?: boolean
    siteId?: boolean
    name?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConstructionTeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "siteId" | "name" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["constructionTeam"]>
  export type ConstructionTeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    site?: boolean | ConstructionSiteDefaultArgs<ExtArgs>
    workers?: boolean | ConstructionTeam$workersArgs<ExtArgs>
    _count?: boolean | ConstructionTeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConstructionTeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    site?: boolean | ConstructionSiteDefaultArgs<ExtArgs>
  }
  export type ConstructionTeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    site?: boolean | ConstructionSiteDefaultArgs<ExtArgs>
  }

  export type $ConstructionTeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConstructionTeam"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      site: Prisma.$ConstructionSitePayload<ExtArgs>
      workers: Prisma.$ConstructionWorkerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      siteId: string
      name: string
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["constructionTeam"]>
    composites: {}
  }

  type ConstructionTeamGetPayload<S extends boolean | null | undefined | ConstructionTeamDefaultArgs> = $Result.GetResult<Prisma.$ConstructionTeamPayload, S>

  type ConstructionTeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConstructionTeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConstructionTeamCountAggregateInputType | true
    }

  export interface ConstructionTeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConstructionTeam'], meta: { name: 'ConstructionTeam' } }
    /**
     * Find zero or one ConstructionTeam that matches the filter.
     * @param {ConstructionTeamFindUniqueArgs} args - Arguments to find a ConstructionTeam
     * @example
     * // Get one ConstructionTeam
     * const constructionTeam = await prisma.constructionTeam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConstructionTeamFindUniqueArgs>(args: SelectSubset<T, ConstructionTeamFindUniqueArgs<ExtArgs>>): Prisma__ConstructionTeamClient<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConstructionTeam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConstructionTeamFindUniqueOrThrowArgs} args - Arguments to find a ConstructionTeam
     * @example
     * // Get one ConstructionTeam
     * const constructionTeam = await prisma.constructionTeam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConstructionTeamFindUniqueOrThrowArgs>(args: SelectSubset<T, ConstructionTeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConstructionTeamClient<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConstructionTeam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTeamFindFirstArgs} args - Arguments to find a ConstructionTeam
     * @example
     * // Get one ConstructionTeam
     * const constructionTeam = await prisma.constructionTeam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConstructionTeamFindFirstArgs>(args?: SelectSubset<T, ConstructionTeamFindFirstArgs<ExtArgs>>): Prisma__ConstructionTeamClient<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConstructionTeam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTeamFindFirstOrThrowArgs} args - Arguments to find a ConstructionTeam
     * @example
     * // Get one ConstructionTeam
     * const constructionTeam = await prisma.constructionTeam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConstructionTeamFindFirstOrThrowArgs>(args?: SelectSubset<T, ConstructionTeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConstructionTeamClient<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConstructionTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConstructionTeams
     * const constructionTeams = await prisma.constructionTeam.findMany()
     * 
     * // Get first 10 ConstructionTeams
     * const constructionTeams = await prisma.constructionTeam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const constructionTeamWithIdOnly = await prisma.constructionTeam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConstructionTeamFindManyArgs>(args?: SelectSubset<T, ConstructionTeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConstructionTeam.
     * @param {ConstructionTeamCreateArgs} args - Arguments to create a ConstructionTeam.
     * @example
     * // Create one ConstructionTeam
     * const ConstructionTeam = await prisma.constructionTeam.create({
     *   data: {
     *     // ... data to create a ConstructionTeam
     *   }
     * })
     * 
     */
    create<T extends ConstructionTeamCreateArgs>(args: SelectSubset<T, ConstructionTeamCreateArgs<ExtArgs>>): Prisma__ConstructionTeamClient<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConstructionTeams.
     * @param {ConstructionTeamCreateManyArgs} args - Arguments to create many ConstructionTeams.
     * @example
     * // Create many ConstructionTeams
     * const constructionTeam = await prisma.constructionTeam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConstructionTeamCreateManyArgs>(args?: SelectSubset<T, ConstructionTeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConstructionTeams and returns the data saved in the database.
     * @param {ConstructionTeamCreateManyAndReturnArgs} args - Arguments to create many ConstructionTeams.
     * @example
     * // Create many ConstructionTeams
     * const constructionTeam = await prisma.constructionTeam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConstructionTeams and only return the `id`
     * const constructionTeamWithIdOnly = await prisma.constructionTeam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConstructionTeamCreateManyAndReturnArgs>(args?: SelectSubset<T, ConstructionTeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConstructionTeam.
     * @param {ConstructionTeamDeleteArgs} args - Arguments to delete one ConstructionTeam.
     * @example
     * // Delete one ConstructionTeam
     * const ConstructionTeam = await prisma.constructionTeam.delete({
     *   where: {
     *     // ... filter to delete one ConstructionTeam
     *   }
     * })
     * 
     */
    delete<T extends ConstructionTeamDeleteArgs>(args: SelectSubset<T, ConstructionTeamDeleteArgs<ExtArgs>>): Prisma__ConstructionTeamClient<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConstructionTeam.
     * @param {ConstructionTeamUpdateArgs} args - Arguments to update one ConstructionTeam.
     * @example
     * // Update one ConstructionTeam
     * const constructionTeam = await prisma.constructionTeam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConstructionTeamUpdateArgs>(args: SelectSubset<T, ConstructionTeamUpdateArgs<ExtArgs>>): Prisma__ConstructionTeamClient<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConstructionTeams.
     * @param {ConstructionTeamDeleteManyArgs} args - Arguments to filter ConstructionTeams to delete.
     * @example
     * // Delete a few ConstructionTeams
     * const { count } = await prisma.constructionTeam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConstructionTeamDeleteManyArgs>(args?: SelectSubset<T, ConstructionTeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConstructionTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConstructionTeams
     * const constructionTeam = await prisma.constructionTeam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConstructionTeamUpdateManyArgs>(args: SelectSubset<T, ConstructionTeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConstructionTeams and returns the data updated in the database.
     * @param {ConstructionTeamUpdateManyAndReturnArgs} args - Arguments to update many ConstructionTeams.
     * @example
     * // Update many ConstructionTeams
     * const constructionTeam = await prisma.constructionTeam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConstructionTeams and only return the `id`
     * const constructionTeamWithIdOnly = await prisma.constructionTeam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConstructionTeamUpdateManyAndReturnArgs>(args: SelectSubset<T, ConstructionTeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConstructionTeam.
     * @param {ConstructionTeamUpsertArgs} args - Arguments to update or create a ConstructionTeam.
     * @example
     * // Update or create a ConstructionTeam
     * const constructionTeam = await prisma.constructionTeam.upsert({
     *   create: {
     *     // ... data to create a ConstructionTeam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConstructionTeam we want to update
     *   }
     * })
     */
    upsert<T extends ConstructionTeamUpsertArgs>(args: SelectSubset<T, ConstructionTeamUpsertArgs<ExtArgs>>): Prisma__ConstructionTeamClient<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConstructionTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTeamCountArgs} args - Arguments to filter ConstructionTeams to count.
     * @example
     * // Count the number of ConstructionTeams
     * const count = await prisma.constructionTeam.count({
     *   where: {
     *     // ... the filter for the ConstructionTeams we want to count
     *   }
     * })
    **/
    count<T extends ConstructionTeamCountArgs>(
      args?: Subset<T, ConstructionTeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConstructionTeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConstructionTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConstructionTeamAggregateArgs>(args: Subset<T, ConstructionTeamAggregateArgs>): Prisma.PrismaPromise<GetConstructionTeamAggregateType<T>>

    /**
     * Group by ConstructionTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionTeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConstructionTeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConstructionTeamGroupByArgs['orderBy'] }
        : { orderBy?: ConstructionTeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConstructionTeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConstructionTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConstructionTeam model
   */
  readonly fields: ConstructionTeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConstructionTeam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConstructionTeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    site<T extends ConstructionSiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionSiteDefaultArgs<ExtArgs>>): Prisma__ConstructionSiteClient<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workers<T extends ConstructionTeam$workersArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionTeam$workersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConstructionTeam model
   */
  interface ConstructionTeamFieldRefs {
    readonly id: FieldRef<"ConstructionTeam", 'String'>
    readonly companyId: FieldRef<"ConstructionTeam", 'String'>
    readonly siteId: FieldRef<"ConstructionTeam", 'String'>
    readonly name: FieldRef<"ConstructionTeam", 'String'>
    readonly deletedAt: FieldRef<"ConstructionTeam", 'DateTime'>
    readonly createdAt: FieldRef<"ConstructionTeam", 'DateTime'>
    readonly updatedAt: FieldRef<"ConstructionTeam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConstructionTeam findUnique
   */
  export type ConstructionTeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTeam to fetch.
     */
    where: ConstructionTeamWhereUniqueInput
  }

  /**
   * ConstructionTeam findUniqueOrThrow
   */
  export type ConstructionTeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTeam to fetch.
     */
    where: ConstructionTeamWhereUniqueInput
  }

  /**
   * ConstructionTeam findFirst
   */
  export type ConstructionTeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTeam to fetch.
     */
    where?: ConstructionTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionTeams to fetch.
     */
    orderBy?: ConstructionTeamOrderByWithRelationInput | ConstructionTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionTeams.
     */
    cursor?: ConstructionTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionTeams.
     */
    distinct?: ConstructionTeamScalarFieldEnum | ConstructionTeamScalarFieldEnum[]
  }

  /**
   * ConstructionTeam findFirstOrThrow
   */
  export type ConstructionTeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTeam to fetch.
     */
    where?: ConstructionTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionTeams to fetch.
     */
    orderBy?: ConstructionTeamOrderByWithRelationInput | ConstructionTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionTeams.
     */
    cursor?: ConstructionTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionTeams.
     */
    distinct?: ConstructionTeamScalarFieldEnum | ConstructionTeamScalarFieldEnum[]
  }

  /**
   * ConstructionTeam findMany
   */
  export type ConstructionTeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionTeams to fetch.
     */
    where?: ConstructionTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionTeams to fetch.
     */
    orderBy?: ConstructionTeamOrderByWithRelationInput | ConstructionTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConstructionTeams.
     */
    cursor?: ConstructionTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionTeams.
     */
    skip?: number
    distinct?: ConstructionTeamScalarFieldEnum | ConstructionTeamScalarFieldEnum[]
  }

  /**
   * ConstructionTeam create
   */
  export type ConstructionTeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamInclude<ExtArgs> | null
    /**
     * The data needed to create a ConstructionTeam.
     */
    data: XOR<ConstructionTeamCreateInput, ConstructionTeamUncheckedCreateInput>
  }

  /**
   * ConstructionTeam createMany
   */
  export type ConstructionTeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConstructionTeams.
     */
    data: ConstructionTeamCreateManyInput | ConstructionTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConstructionTeam createManyAndReturn
   */
  export type ConstructionTeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * The data used to create many ConstructionTeams.
     */
    data: ConstructionTeamCreateManyInput | ConstructionTeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConstructionTeam update
   */
  export type ConstructionTeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamInclude<ExtArgs> | null
    /**
     * The data needed to update a ConstructionTeam.
     */
    data: XOR<ConstructionTeamUpdateInput, ConstructionTeamUncheckedUpdateInput>
    /**
     * Choose, which ConstructionTeam to update.
     */
    where: ConstructionTeamWhereUniqueInput
  }

  /**
   * ConstructionTeam updateMany
   */
  export type ConstructionTeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConstructionTeams.
     */
    data: XOR<ConstructionTeamUpdateManyMutationInput, ConstructionTeamUncheckedUpdateManyInput>
    /**
     * Filter which ConstructionTeams to update
     */
    where?: ConstructionTeamWhereInput
    /**
     * Limit how many ConstructionTeams to update.
     */
    limit?: number
  }

  /**
   * ConstructionTeam updateManyAndReturn
   */
  export type ConstructionTeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * The data used to update ConstructionTeams.
     */
    data: XOR<ConstructionTeamUpdateManyMutationInput, ConstructionTeamUncheckedUpdateManyInput>
    /**
     * Filter which ConstructionTeams to update
     */
    where?: ConstructionTeamWhereInput
    /**
     * Limit how many ConstructionTeams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConstructionTeam upsert
   */
  export type ConstructionTeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamInclude<ExtArgs> | null
    /**
     * The filter to search for the ConstructionTeam to update in case it exists.
     */
    where: ConstructionTeamWhereUniqueInput
    /**
     * In case the ConstructionTeam found by the `where` argument doesn't exist, create a new ConstructionTeam with this data.
     */
    create: XOR<ConstructionTeamCreateInput, ConstructionTeamUncheckedCreateInput>
    /**
     * In case the ConstructionTeam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConstructionTeamUpdateInput, ConstructionTeamUncheckedUpdateInput>
  }

  /**
   * ConstructionTeam delete
   */
  export type ConstructionTeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamInclude<ExtArgs> | null
    /**
     * Filter which ConstructionTeam to delete.
     */
    where: ConstructionTeamWhereUniqueInput
  }

  /**
   * ConstructionTeam deleteMany
   */
  export type ConstructionTeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionTeams to delete
     */
    where?: ConstructionTeamWhereInput
    /**
     * Limit how many ConstructionTeams to delete.
     */
    limit?: number
  }

  /**
   * ConstructionTeam.workers
   */
  export type ConstructionTeam$workersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerInclude<ExtArgs> | null
    where?: ConstructionWorkerWhereInput
    orderBy?: ConstructionWorkerOrderByWithRelationInput | ConstructionWorkerOrderByWithRelationInput[]
    cursor?: ConstructionWorkerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConstructionWorkerScalarFieldEnum | ConstructionWorkerScalarFieldEnum[]
  }

  /**
   * ConstructionTeam without action
   */
  export type ConstructionTeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionTeam
     */
    select?: ConstructionTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionTeam
     */
    omit?: ConstructionTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionTeamInclude<ExtArgs> | null
  }


  /**
   * Model ConstructionWorker
   */

  export type AggregateConstructionWorker = {
    _count: ConstructionWorkerCountAggregateOutputType | null
    _min: ConstructionWorkerMinAggregateOutputType | null
    _max: ConstructionWorkerMaxAggregateOutputType | null
  }

  export type ConstructionWorkerMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    teamId: string | null
    name: string | null
    email: string | null
    personId: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConstructionWorkerMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    teamId: string | null
    name: string | null
    email: string | null
    personId: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConstructionWorkerCountAggregateOutputType = {
    id: number
    companyId: number
    teamId: number
    name: number
    email: number
    personId: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConstructionWorkerMinAggregateInputType = {
    id?: true
    companyId?: true
    teamId?: true
    name?: true
    email?: true
    personId?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConstructionWorkerMaxAggregateInputType = {
    id?: true
    companyId?: true
    teamId?: true
    name?: true
    email?: true
    personId?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConstructionWorkerCountAggregateInputType = {
    id?: true
    companyId?: true
    teamId?: true
    name?: true
    email?: true
    personId?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConstructionWorkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionWorker to aggregate.
     */
    where?: ConstructionWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionWorkers to fetch.
     */
    orderBy?: ConstructionWorkerOrderByWithRelationInput | ConstructionWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConstructionWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionWorkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConstructionWorkers
    **/
    _count?: true | ConstructionWorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConstructionWorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConstructionWorkerMaxAggregateInputType
  }

  export type GetConstructionWorkerAggregateType<T extends ConstructionWorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateConstructionWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConstructionWorker[P]>
      : GetScalarType<T[P], AggregateConstructionWorker[P]>
  }




  export type ConstructionWorkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConstructionWorkerWhereInput
    orderBy?: ConstructionWorkerOrderByWithAggregationInput | ConstructionWorkerOrderByWithAggregationInput[]
    by: ConstructionWorkerScalarFieldEnum[] | ConstructionWorkerScalarFieldEnum
    having?: ConstructionWorkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConstructionWorkerCountAggregateInputType | true
    _min?: ConstructionWorkerMinAggregateInputType
    _max?: ConstructionWorkerMaxAggregateInputType
  }

  export type ConstructionWorkerGroupByOutputType = {
    id: string
    companyId: string
    teamId: string
    name: string
    email: string | null
    personId: string | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ConstructionWorkerCountAggregateOutputType | null
    _min: ConstructionWorkerMinAggregateOutputType | null
    _max: ConstructionWorkerMaxAggregateOutputType | null
  }

  type GetConstructionWorkerGroupByPayload<T extends ConstructionWorkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConstructionWorkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConstructionWorkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConstructionWorkerGroupByOutputType[P]>
            : GetScalarType<T[P], ConstructionWorkerGroupByOutputType[P]>
        }
      >
    >


  export type ConstructionWorkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    teamId?: boolean
    name?: boolean
    email?: boolean
    personId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    team?: boolean | ConstructionTeamDefaultArgs<ExtArgs>
    person?: boolean | ConstructionWorker$personArgs<ExtArgs>
    attendance?: boolean | ConstructionWorker$attendanceArgs<ExtArgs>
    _count?: boolean | ConstructionWorkerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constructionWorker"]>

  export type ConstructionWorkerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    teamId?: boolean
    name?: boolean
    email?: boolean
    personId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    team?: boolean | ConstructionTeamDefaultArgs<ExtArgs>
    person?: boolean | ConstructionWorker$personArgs<ExtArgs>
  }, ExtArgs["result"]["constructionWorker"]>

  export type ConstructionWorkerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    teamId?: boolean
    name?: boolean
    email?: boolean
    personId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    team?: boolean | ConstructionTeamDefaultArgs<ExtArgs>
    person?: boolean | ConstructionWorker$personArgs<ExtArgs>
  }, ExtArgs["result"]["constructionWorker"]>

  export type ConstructionWorkerSelectScalar = {
    id?: boolean
    companyId?: boolean
    teamId?: boolean
    name?: boolean
    email?: boolean
    personId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConstructionWorkerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "teamId" | "name" | "email" | "personId" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["constructionWorker"]>
  export type ConstructionWorkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    team?: boolean | ConstructionTeamDefaultArgs<ExtArgs>
    person?: boolean | ConstructionWorker$personArgs<ExtArgs>
    attendance?: boolean | ConstructionWorker$attendanceArgs<ExtArgs>
    _count?: boolean | ConstructionWorkerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConstructionWorkerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    team?: boolean | ConstructionTeamDefaultArgs<ExtArgs>
    person?: boolean | ConstructionWorker$personArgs<ExtArgs>
  }
  export type ConstructionWorkerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    team?: boolean | ConstructionTeamDefaultArgs<ExtArgs>
    person?: boolean | ConstructionWorker$personArgs<ExtArgs>
  }

  export type $ConstructionWorkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConstructionWorker"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      team: Prisma.$ConstructionTeamPayload<ExtArgs>
      person: Prisma.$PersonPayload<ExtArgs> | null
      attendance: Prisma.$SiteAttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      teamId: string
      name: string
      email: string | null
      /**
       * Optional link to Person for long-term identity unification.
       */
      personId: string | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["constructionWorker"]>
    composites: {}
  }

  type ConstructionWorkerGetPayload<S extends boolean | null | undefined | ConstructionWorkerDefaultArgs> = $Result.GetResult<Prisma.$ConstructionWorkerPayload, S>

  type ConstructionWorkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConstructionWorkerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConstructionWorkerCountAggregateInputType | true
    }

  export interface ConstructionWorkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConstructionWorker'], meta: { name: 'ConstructionWorker' } }
    /**
     * Find zero or one ConstructionWorker that matches the filter.
     * @param {ConstructionWorkerFindUniqueArgs} args - Arguments to find a ConstructionWorker
     * @example
     * // Get one ConstructionWorker
     * const constructionWorker = await prisma.constructionWorker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConstructionWorkerFindUniqueArgs>(args: SelectSubset<T, ConstructionWorkerFindUniqueArgs<ExtArgs>>): Prisma__ConstructionWorkerClient<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConstructionWorker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConstructionWorkerFindUniqueOrThrowArgs} args - Arguments to find a ConstructionWorker
     * @example
     * // Get one ConstructionWorker
     * const constructionWorker = await prisma.constructionWorker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConstructionWorkerFindUniqueOrThrowArgs>(args: SelectSubset<T, ConstructionWorkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConstructionWorkerClient<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConstructionWorker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionWorkerFindFirstArgs} args - Arguments to find a ConstructionWorker
     * @example
     * // Get one ConstructionWorker
     * const constructionWorker = await prisma.constructionWorker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConstructionWorkerFindFirstArgs>(args?: SelectSubset<T, ConstructionWorkerFindFirstArgs<ExtArgs>>): Prisma__ConstructionWorkerClient<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConstructionWorker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionWorkerFindFirstOrThrowArgs} args - Arguments to find a ConstructionWorker
     * @example
     * // Get one ConstructionWorker
     * const constructionWorker = await prisma.constructionWorker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConstructionWorkerFindFirstOrThrowArgs>(args?: SelectSubset<T, ConstructionWorkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConstructionWorkerClient<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConstructionWorkers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionWorkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConstructionWorkers
     * const constructionWorkers = await prisma.constructionWorker.findMany()
     * 
     * // Get first 10 ConstructionWorkers
     * const constructionWorkers = await prisma.constructionWorker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const constructionWorkerWithIdOnly = await prisma.constructionWorker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConstructionWorkerFindManyArgs>(args?: SelectSubset<T, ConstructionWorkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConstructionWorker.
     * @param {ConstructionWorkerCreateArgs} args - Arguments to create a ConstructionWorker.
     * @example
     * // Create one ConstructionWorker
     * const ConstructionWorker = await prisma.constructionWorker.create({
     *   data: {
     *     // ... data to create a ConstructionWorker
     *   }
     * })
     * 
     */
    create<T extends ConstructionWorkerCreateArgs>(args: SelectSubset<T, ConstructionWorkerCreateArgs<ExtArgs>>): Prisma__ConstructionWorkerClient<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConstructionWorkers.
     * @param {ConstructionWorkerCreateManyArgs} args - Arguments to create many ConstructionWorkers.
     * @example
     * // Create many ConstructionWorkers
     * const constructionWorker = await prisma.constructionWorker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConstructionWorkerCreateManyArgs>(args?: SelectSubset<T, ConstructionWorkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConstructionWorkers and returns the data saved in the database.
     * @param {ConstructionWorkerCreateManyAndReturnArgs} args - Arguments to create many ConstructionWorkers.
     * @example
     * // Create many ConstructionWorkers
     * const constructionWorker = await prisma.constructionWorker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConstructionWorkers and only return the `id`
     * const constructionWorkerWithIdOnly = await prisma.constructionWorker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConstructionWorkerCreateManyAndReturnArgs>(args?: SelectSubset<T, ConstructionWorkerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConstructionWorker.
     * @param {ConstructionWorkerDeleteArgs} args - Arguments to delete one ConstructionWorker.
     * @example
     * // Delete one ConstructionWorker
     * const ConstructionWorker = await prisma.constructionWorker.delete({
     *   where: {
     *     // ... filter to delete one ConstructionWorker
     *   }
     * })
     * 
     */
    delete<T extends ConstructionWorkerDeleteArgs>(args: SelectSubset<T, ConstructionWorkerDeleteArgs<ExtArgs>>): Prisma__ConstructionWorkerClient<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConstructionWorker.
     * @param {ConstructionWorkerUpdateArgs} args - Arguments to update one ConstructionWorker.
     * @example
     * // Update one ConstructionWorker
     * const constructionWorker = await prisma.constructionWorker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConstructionWorkerUpdateArgs>(args: SelectSubset<T, ConstructionWorkerUpdateArgs<ExtArgs>>): Prisma__ConstructionWorkerClient<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConstructionWorkers.
     * @param {ConstructionWorkerDeleteManyArgs} args - Arguments to filter ConstructionWorkers to delete.
     * @example
     * // Delete a few ConstructionWorkers
     * const { count } = await prisma.constructionWorker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConstructionWorkerDeleteManyArgs>(args?: SelectSubset<T, ConstructionWorkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConstructionWorkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionWorkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConstructionWorkers
     * const constructionWorker = await prisma.constructionWorker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConstructionWorkerUpdateManyArgs>(args: SelectSubset<T, ConstructionWorkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConstructionWorkers and returns the data updated in the database.
     * @param {ConstructionWorkerUpdateManyAndReturnArgs} args - Arguments to update many ConstructionWorkers.
     * @example
     * // Update many ConstructionWorkers
     * const constructionWorker = await prisma.constructionWorker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConstructionWorkers and only return the `id`
     * const constructionWorkerWithIdOnly = await prisma.constructionWorker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConstructionWorkerUpdateManyAndReturnArgs>(args: SelectSubset<T, ConstructionWorkerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConstructionWorker.
     * @param {ConstructionWorkerUpsertArgs} args - Arguments to update or create a ConstructionWorker.
     * @example
     * // Update or create a ConstructionWorker
     * const constructionWorker = await prisma.constructionWorker.upsert({
     *   create: {
     *     // ... data to create a ConstructionWorker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConstructionWorker we want to update
     *   }
     * })
     */
    upsert<T extends ConstructionWorkerUpsertArgs>(args: SelectSubset<T, ConstructionWorkerUpsertArgs<ExtArgs>>): Prisma__ConstructionWorkerClient<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConstructionWorkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionWorkerCountArgs} args - Arguments to filter ConstructionWorkers to count.
     * @example
     * // Count the number of ConstructionWorkers
     * const count = await prisma.constructionWorker.count({
     *   where: {
     *     // ... the filter for the ConstructionWorkers we want to count
     *   }
     * })
    **/
    count<T extends ConstructionWorkerCountArgs>(
      args?: Subset<T, ConstructionWorkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConstructionWorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConstructionWorker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionWorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConstructionWorkerAggregateArgs>(args: Subset<T, ConstructionWorkerAggregateArgs>): Prisma.PrismaPromise<GetConstructionWorkerAggregateType<T>>

    /**
     * Group by ConstructionWorker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionWorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConstructionWorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConstructionWorkerGroupByArgs['orderBy'] }
        : { orderBy?: ConstructionWorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConstructionWorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConstructionWorkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConstructionWorker model
   */
  readonly fields: ConstructionWorkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConstructionWorker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConstructionWorkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends ConstructionTeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionTeamDefaultArgs<ExtArgs>>): Prisma__ConstructionTeamClient<$Result.GetResult<Prisma.$ConstructionTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    person<T extends ConstructionWorker$personArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionWorker$personArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attendance<T extends ConstructionWorker$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionWorker$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConstructionWorker model
   */
  interface ConstructionWorkerFieldRefs {
    readonly id: FieldRef<"ConstructionWorker", 'String'>
    readonly companyId: FieldRef<"ConstructionWorker", 'String'>
    readonly teamId: FieldRef<"ConstructionWorker", 'String'>
    readonly name: FieldRef<"ConstructionWorker", 'String'>
    readonly email: FieldRef<"ConstructionWorker", 'String'>
    readonly personId: FieldRef<"ConstructionWorker", 'String'>
    readonly deletedAt: FieldRef<"ConstructionWorker", 'DateTime'>
    readonly createdAt: FieldRef<"ConstructionWorker", 'DateTime'>
    readonly updatedAt: FieldRef<"ConstructionWorker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConstructionWorker findUnique
   */
  export type ConstructionWorkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionWorker to fetch.
     */
    where: ConstructionWorkerWhereUniqueInput
  }

  /**
   * ConstructionWorker findUniqueOrThrow
   */
  export type ConstructionWorkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionWorker to fetch.
     */
    where: ConstructionWorkerWhereUniqueInput
  }

  /**
   * ConstructionWorker findFirst
   */
  export type ConstructionWorkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionWorker to fetch.
     */
    where?: ConstructionWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionWorkers to fetch.
     */
    orderBy?: ConstructionWorkerOrderByWithRelationInput | ConstructionWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionWorkers.
     */
    cursor?: ConstructionWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionWorkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionWorkers.
     */
    distinct?: ConstructionWorkerScalarFieldEnum | ConstructionWorkerScalarFieldEnum[]
  }

  /**
   * ConstructionWorker findFirstOrThrow
   */
  export type ConstructionWorkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionWorker to fetch.
     */
    where?: ConstructionWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionWorkers to fetch.
     */
    orderBy?: ConstructionWorkerOrderByWithRelationInput | ConstructionWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionWorkers.
     */
    cursor?: ConstructionWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionWorkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionWorkers.
     */
    distinct?: ConstructionWorkerScalarFieldEnum | ConstructionWorkerScalarFieldEnum[]
  }

  /**
   * ConstructionWorker findMany
   */
  export type ConstructionWorkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionWorkers to fetch.
     */
    where?: ConstructionWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionWorkers to fetch.
     */
    orderBy?: ConstructionWorkerOrderByWithRelationInput | ConstructionWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConstructionWorkers.
     */
    cursor?: ConstructionWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionWorkers.
     */
    skip?: number
    distinct?: ConstructionWorkerScalarFieldEnum | ConstructionWorkerScalarFieldEnum[]
  }

  /**
   * ConstructionWorker create
   */
  export type ConstructionWorkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerInclude<ExtArgs> | null
    /**
     * The data needed to create a ConstructionWorker.
     */
    data: XOR<ConstructionWorkerCreateInput, ConstructionWorkerUncheckedCreateInput>
  }

  /**
   * ConstructionWorker createMany
   */
  export type ConstructionWorkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConstructionWorkers.
     */
    data: ConstructionWorkerCreateManyInput | ConstructionWorkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConstructionWorker createManyAndReturn
   */
  export type ConstructionWorkerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * The data used to create many ConstructionWorkers.
     */
    data: ConstructionWorkerCreateManyInput | ConstructionWorkerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConstructionWorker update
   */
  export type ConstructionWorkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerInclude<ExtArgs> | null
    /**
     * The data needed to update a ConstructionWorker.
     */
    data: XOR<ConstructionWorkerUpdateInput, ConstructionWorkerUncheckedUpdateInput>
    /**
     * Choose, which ConstructionWorker to update.
     */
    where: ConstructionWorkerWhereUniqueInput
  }

  /**
   * ConstructionWorker updateMany
   */
  export type ConstructionWorkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConstructionWorkers.
     */
    data: XOR<ConstructionWorkerUpdateManyMutationInput, ConstructionWorkerUncheckedUpdateManyInput>
    /**
     * Filter which ConstructionWorkers to update
     */
    where?: ConstructionWorkerWhereInput
    /**
     * Limit how many ConstructionWorkers to update.
     */
    limit?: number
  }

  /**
   * ConstructionWorker updateManyAndReturn
   */
  export type ConstructionWorkerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * The data used to update ConstructionWorkers.
     */
    data: XOR<ConstructionWorkerUpdateManyMutationInput, ConstructionWorkerUncheckedUpdateManyInput>
    /**
     * Filter which ConstructionWorkers to update
     */
    where?: ConstructionWorkerWhereInput
    /**
     * Limit how many ConstructionWorkers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConstructionWorker upsert
   */
  export type ConstructionWorkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerInclude<ExtArgs> | null
    /**
     * The filter to search for the ConstructionWorker to update in case it exists.
     */
    where: ConstructionWorkerWhereUniqueInput
    /**
     * In case the ConstructionWorker found by the `where` argument doesn't exist, create a new ConstructionWorker with this data.
     */
    create: XOR<ConstructionWorkerCreateInput, ConstructionWorkerUncheckedCreateInput>
    /**
     * In case the ConstructionWorker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConstructionWorkerUpdateInput, ConstructionWorkerUncheckedUpdateInput>
  }

  /**
   * ConstructionWorker delete
   */
  export type ConstructionWorkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerInclude<ExtArgs> | null
    /**
     * Filter which ConstructionWorker to delete.
     */
    where: ConstructionWorkerWhereUniqueInput
  }

  /**
   * ConstructionWorker deleteMany
   */
  export type ConstructionWorkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionWorkers to delete
     */
    where?: ConstructionWorkerWhereInput
    /**
     * Limit how many ConstructionWorkers to delete.
     */
    limit?: number
  }

  /**
   * ConstructionWorker.person
   */
  export type ConstructionWorker$personArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    where?: PersonWhereInput
  }

  /**
   * ConstructionWorker.attendance
   */
  export type ConstructionWorker$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceInclude<ExtArgs> | null
    where?: SiteAttendanceWhereInput
    orderBy?: SiteAttendanceOrderByWithRelationInput | SiteAttendanceOrderByWithRelationInput[]
    cursor?: SiteAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteAttendanceScalarFieldEnum | SiteAttendanceScalarFieldEnum[]
  }

  /**
   * ConstructionWorker without action
   */
  export type ConstructionWorkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerInclude<ExtArgs> | null
  }


  /**
   * Model SiteAttendance
   */

  export type AggregateSiteAttendance = {
    _count: SiteAttendanceCountAggregateOutputType | null
    _avg: SiteAttendanceAvgAggregateOutputType | null
    _sum: SiteAttendanceSumAggregateOutputType | null
    _min: SiteAttendanceMinAggregateOutputType | null
    _max: SiteAttendanceMaxAggregateOutputType | null
  }

  export type SiteAttendanceAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type SiteAttendanceSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type SiteAttendanceMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    siteId: string | null
    workerId: string | null
    date: Date | null
    checkInAt: Date | null
    checkOutAt: Date | null
    latitude: number | null
    longitude: number | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteAttendanceMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    siteId: string | null
    workerId: string | null
    date: Date | null
    checkInAt: Date | null
    checkOutAt: Date | null
    latitude: number | null
    longitude: number | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteAttendanceCountAggregateOutputType = {
    id: number
    companyId: number
    siteId: number
    workerId: number
    date: number
    checkInAt: number
    checkOutAt: number
    latitude: number
    longitude: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SiteAttendanceAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type SiteAttendanceSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type SiteAttendanceMinAggregateInputType = {
    id?: true
    companyId?: true
    siteId?: true
    workerId?: true
    date?: true
    checkInAt?: true
    checkOutAt?: true
    latitude?: true
    longitude?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteAttendanceMaxAggregateInputType = {
    id?: true
    companyId?: true
    siteId?: true
    workerId?: true
    date?: true
    checkInAt?: true
    checkOutAt?: true
    latitude?: true
    longitude?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteAttendanceCountAggregateInputType = {
    id?: true
    companyId?: true
    siteId?: true
    workerId?: true
    date?: true
    checkInAt?: true
    checkOutAt?: true
    latitude?: true
    longitude?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteAttendance to aggregate.
     */
    where?: SiteAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteAttendances to fetch.
     */
    orderBy?: SiteAttendanceOrderByWithRelationInput | SiteAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteAttendances
    **/
    _count?: true | SiteAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SiteAttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SiteAttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteAttendanceMaxAggregateInputType
  }

  export type GetSiteAttendanceAggregateType<T extends SiteAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteAttendance[P]>
      : GetScalarType<T[P], AggregateSiteAttendance[P]>
  }




  export type SiteAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteAttendanceWhereInput
    orderBy?: SiteAttendanceOrderByWithAggregationInput | SiteAttendanceOrderByWithAggregationInput[]
    by: SiteAttendanceScalarFieldEnum[] | SiteAttendanceScalarFieldEnum
    having?: SiteAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteAttendanceCountAggregateInputType | true
    _avg?: SiteAttendanceAvgAggregateInputType
    _sum?: SiteAttendanceSumAggregateInputType
    _min?: SiteAttendanceMinAggregateInputType
    _max?: SiteAttendanceMaxAggregateInputType
  }

  export type SiteAttendanceGroupByOutputType = {
    id: string
    companyId: string
    siteId: string
    workerId: string
    date: Date
    checkInAt: Date
    checkOutAt: Date | null
    latitude: number | null
    longitude: number | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SiteAttendanceCountAggregateOutputType | null
    _avg: SiteAttendanceAvgAggregateOutputType | null
    _sum: SiteAttendanceSumAggregateOutputType | null
    _min: SiteAttendanceMinAggregateOutputType | null
    _max: SiteAttendanceMaxAggregateOutputType | null
  }

  type GetSiteAttendanceGroupByPayload<T extends SiteAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], SiteAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type SiteAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    siteId?: boolean
    workerId?: boolean
    date?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    latitude?: boolean
    longitude?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    site?: boolean | ConstructionSiteDefaultArgs<ExtArgs>
    worker?: boolean | ConstructionWorkerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteAttendance"]>

  export type SiteAttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    siteId?: boolean
    workerId?: boolean
    date?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    latitude?: boolean
    longitude?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    site?: boolean | ConstructionSiteDefaultArgs<ExtArgs>
    worker?: boolean | ConstructionWorkerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteAttendance"]>

  export type SiteAttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    siteId?: boolean
    workerId?: boolean
    date?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    latitude?: boolean
    longitude?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    site?: boolean | ConstructionSiteDefaultArgs<ExtArgs>
    worker?: boolean | ConstructionWorkerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteAttendance"]>

  export type SiteAttendanceSelectScalar = {
    id?: boolean
    companyId?: boolean
    siteId?: boolean
    workerId?: boolean
    date?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    latitude?: boolean
    longitude?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SiteAttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "siteId" | "workerId" | "date" | "checkInAt" | "checkOutAt" | "latitude" | "longitude" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["siteAttendance"]>
  export type SiteAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    site?: boolean | ConstructionSiteDefaultArgs<ExtArgs>
    worker?: boolean | ConstructionWorkerDefaultArgs<ExtArgs>
  }
  export type SiteAttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    site?: boolean | ConstructionSiteDefaultArgs<ExtArgs>
    worker?: boolean | ConstructionWorkerDefaultArgs<ExtArgs>
  }
  export type SiteAttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    site?: boolean | ConstructionSiteDefaultArgs<ExtArgs>
    worker?: boolean | ConstructionWorkerDefaultArgs<ExtArgs>
  }

  export type $SiteAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteAttendance"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      site: Prisma.$ConstructionSitePayload<ExtArgs>
      worker: Prisma.$ConstructionWorkerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      siteId: string
      workerId: string
      date: Date
      checkInAt: Date
      checkOutAt: Date | null
      latitude: number | null
      longitude: number | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["siteAttendance"]>
    composites: {}
  }

  type SiteAttendanceGetPayload<S extends boolean | null | undefined | SiteAttendanceDefaultArgs> = $Result.GetResult<Prisma.$SiteAttendancePayload, S>

  type SiteAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteAttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteAttendanceCountAggregateInputType | true
    }

  export interface SiteAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteAttendance'], meta: { name: 'SiteAttendance' } }
    /**
     * Find zero or one SiteAttendance that matches the filter.
     * @param {SiteAttendanceFindUniqueArgs} args - Arguments to find a SiteAttendance
     * @example
     * // Get one SiteAttendance
     * const siteAttendance = await prisma.siteAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteAttendanceFindUniqueArgs>(args: SelectSubset<T, SiteAttendanceFindUniqueArgs<ExtArgs>>): Prisma__SiteAttendanceClient<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteAttendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteAttendanceFindUniqueOrThrowArgs} args - Arguments to find a SiteAttendance
     * @example
     * // Get one SiteAttendance
     * const siteAttendance = await prisma.siteAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteAttendanceClient<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteAttendanceFindFirstArgs} args - Arguments to find a SiteAttendance
     * @example
     * // Get one SiteAttendance
     * const siteAttendance = await prisma.siteAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteAttendanceFindFirstArgs>(args?: SelectSubset<T, SiteAttendanceFindFirstArgs<ExtArgs>>): Prisma__SiteAttendanceClient<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteAttendanceFindFirstOrThrowArgs} args - Arguments to find a SiteAttendance
     * @example
     * // Get one SiteAttendance
     * const siteAttendance = await prisma.siteAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteAttendanceClient<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteAttendances
     * const siteAttendances = await prisma.siteAttendance.findMany()
     * 
     * // Get first 10 SiteAttendances
     * const siteAttendances = await prisma.siteAttendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteAttendanceWithIdOnly = await prisma.siteAttendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteAttendanceFindManyArgs>(args?: SelectSubset<T, SiteAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteAttendance.
     * @param {SiteAttendanceCreateArgs} args - Arguments to create a SiteAttendance.
     * @example
     * // Create one SiteAttendance
     * const SiteAttendance = await prisma.siteAttendance.create({
     *   data: {
     *     // ... data to create a SiteAttendance
     *   }
     * })
     * 
     */
    create<T extends SiteAttendanceCreateArgs>(args: SelectSubset<T, SiteAttendanceCreateArgs<ExtArgs>>): Prisma__SiteAttendanceClient<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteAttendances.
     * @param {SiteAttendanceCreateManyArgs} args - Arguments to create many SiteAttendances.
     * @example
     * // Create many SiteAttendances
     * const siteAttendance = await prisma.siteAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteAttendanceCreateManyArgs>(args?: SelectSubset<T, SiteAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteAttendances and returns the data saved in the database.
     * @param {SiteAttendanceCreateManyAndReturnArgs} args - Arguments to create many SiteAttendances.
     * @example
     * // Create many SiteAttendances
     * const siteAttendance = await prisma.siteAttendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteAttendances and only return the `id`
     * const siteAttendanceWithIdOnly = await prisma.siteAttendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteAttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteAttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteAttendance.
     * @param {SiteAttendanceDeleteArgs} args - Arguments to delete one SiteAttendance.
     * @example
     * // Delete one SiteAttendance
     * const SiteAttendance = await prisma.siteAttendance.delete({
     *   where: {
     *     // ... filter to delete one SiteAttendance
     *   }
     * })
     * 
     */
    delete<T extends SiteAttendanceDeleteArgs>(args: SelectSubset<T, SiteAttendanceDeleteArgs<ExtArgs>>): Prisma__SiteAttendanceClient<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteAttendance.
     * @param {SiteAttendanceUpdateArgs} args - Arguments to update one SiteAttendance.
     * @example
     * // Update one SiteAttendance
     * const siteAttendance = await prisma.siteAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteAttendanceUpdateArgs>(args: SelectSubset<T, SiteAttendanceUpdateArgs<ExtArgs>>): Prisma__SiteAttendanceClient<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteAttendances.
     * @param {SiteAttendanceDeleteManyArgs} args - Arguments to filter SiteAttendances to delete.
     * @example
     * // Delete a few SiteAttendances
     * const { count } = await prisma.siteAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteAttendanceDeleteManyArgs>(args?: SelectSubset<T, SiteAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteAttendances
     * const siteAttendance = await prisma.siteAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteAttendanceUpdateManyArgs>(args: SelectSubset<T, SiteAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteAttendances and returns the data updated in the database.
     * @param {SiteAttendanceUpdateManyAndReturnArgs} args - Arguments to update many SiteAttendances.
     * @example
     * // Update many SiteAttendances
     * const siteAttendance = await prisma.siteAttendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteAttendances and only return the `id`
     * const siteAttendanceWithIdOnly = await prisma.siteAttendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteAttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteAttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteAttendance.
     * @param {SiteAttendanceUpsertArgs} args - Arguments to update or create a SiteAttendance.
     * @example
     * // Update or create a SiteAttendance
     * const siteAttendance = await prisma.siteAttendance.upsert({
     *   create: {
     *     // ... data to create a SiteAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteAttendance we want to update
     *   }
     * })
     */
    upsert<T extends SiteAttendanceUpsertArgs>(args: SelectSubset<T, SiteAttendanceUpsertArgs<ExtArgs>>): Prisma__SiteAttendanceClient<$Result.GetResult<Prisma.$SiteAttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteAttendanceCountArgs} args - Arguments to filter SiteAttendances to count.
     * @example
     * // Count the number of SiteAttendances
     * const count = await prisma.siteAttendance.count({
     *   where: {
     *     // ... the filter for the SiteAttendances we want to count
     *   }
     * })
    **/
    count<T extends SiteAttendanceCountArgs>(
      args?: Subset<T, SiteAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteAttendanceAggregateArgs>(args: Subset<T, SiteAttendanceAggregateArgs>): Prisma.PrismaPromise<GetSiteAttendanceAggregateType<T>>

    /**
     * Group by SiteAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: SiteAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteAttendance model
   */
  readonly fields: SiteAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    site<T extends ConstructionSiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionSiteDefaultArgs<ExtArgs>>): Prisma__ConstructionSiteClient<$Result.GetResult<Prisma.$ConstructionSitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    worker<T extends ConstructionWorkerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionWorkerDefaultArgs<ExtArgs>>): Prisma__ConstructionWorkerClient<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteAttendance model
   */
  interface SiteAttendanceFieldRefs {
    readonly id: FieldRef<"SiteAttendance", 'String'>
    readonly companyId: FieldRef<"SiteAttendance", 'String'>
    readonly siteId: FieldRef<"SiteAttendance", 'String'>
    readonly workerId: FieldRef<"SiteAttendance", 'String'>
    readonly date: FieldRef<"SiteAttendance", 'DateTime'>
    readonly checkInAt: FieldRef<"SiteAttendance", 'DateTime'>
    readonly checkOutAt: FieldRef<"SiteAttendance", 'DateTime'>
    readonly latitude: FieldRef<"SiteAttendance", 'Float'>
    readonly longitude: FieldRef<"SiteAttendance", 'Float'>
    readonly deletedAt: FieldRef<"SiteAttendance", 'DateTime'>
    readonly createdAt: FieldRef<"SiteAttendance", 'DateTime'>
    readonly updatedAt: FieldRef<"SiteAttendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SiteAttendance findUnique
   */
  export type SiteAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which SiteAttendance to fetch.
     */
    where: SiteAttendanceWhereUniqueInput
  }

  /**
   * SiteAttendance findUniqueOrThrow
   */
  export type SiteAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which SiteAttendance to fetch.
     */
    where: SiteAttendanceWhereUniqueInput
  }

  /**
   * SiteAttendance findFirst
   */
  export type SiteAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which SiteAttendance to fetch.
     */
    where?: SiteAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteAttendances to fetch.
     */
    orderBy?: SiteAttendanceOrderByWithRelationInput | SiteAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteAttendances.
     */
    cursor?: SiteAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteAttendances.
     */
    distinct?: SiteAttendanceScalarFieldEnum | SiteAttendanceScalarFieldEnum[]
  }

  /**
   * SiteAttendance findFirstOrThrow
   */
  export type SiteAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which SiteAttendance to fetch.
     */
    where?: SiteAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteAttendances to fetch.
     */
    orderBy?: SiteAttendanceOrderByWithRelationInput | SiteAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteAttendances.
     */
    cursor?: SiteAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteAttendances.
     */
    distinct?: SiteAttendanceScalarFieldEnum | SiteAttendanceScalarFieldEnum[]
  }

  /**
   * SiteAttendance findMany
   */
  export type SiteAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which SiteAttendances to fetch.
     */
    where?: SiteAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteAttendances to fetch.
     */
    orderBy?: SiteAttendanceOrderByWithRelationInput | SiteAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteAttendances.
     */
    cursor?: SiteAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteAttendances.
     */
    skip?: number
    distinct?: SiteAttendanceScalarFieldEnum | SiteAttendanceScalarFieldEnum[]
  }

  /**
   * SiteAttendance create
   */
  export type SiteAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a SiteAttendance.
     */
    data: XOR<SiteAttendanceCreateInput, SiteAttendanceUncheckedCreateInput>
  }

  /**
   * SiteAttendance createMany
   */
  export type SiteAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteAttendances.
     */
    data: SiteAttendanceCreateManyInput | SiteAttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteAttendance createManyAndReturn
   */
  export type SiteAttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many SiteAttendances.
     */
    data: SiteAttendanceCreateManyInput | SiteAttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteAttendance update
   */
  export type SiteAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a SiteAttendance.
     */
    data: XOR<SiteAttendanceUpdateInput, SiteAttendanceUncheckedUpdateInput>
    /**
     * Choose, which SiteAttendance to update.
     */
    where: SiteAttendanceWhereUniqueInput
  }

  /**
   * SiteAttendance updateMany
   */
  export type SiteAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteAttendances.
     */
    data: XOR<SiteAttendanceUpdateManyMutationInput, SiteAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which SiteAttendances to update
     */
    where?: SiteAttendanceWhereInput
    /**
     * Limit how many SiteAttendances to update.
     */
    limit?: number
  }

  /**
   * SiteAttendance updateManyAndReturn
   */
  export type SiteAttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * The data used to update SiteAttendances.
     */
    data: XOR<SiteAttendanceUpdateManyMutationInput, SiteAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which SiteAttendances to update
     */
    where?: SiteAttendanceWhereInput
    /**
     * Limit how many SiteAttendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteAttendance upsert
   */
  export type SiteAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the SiteAttendance to update in case it exists.
     */
    where: SiteAttendanceWhereUniqueInput
    /**
     * In case the SiteAttendance found by the `where` argument doesn't exist, create a new SiteAttendance with this data.
     */
    create: XOR<SiteAttendanceCreateInput, SiteAttendanceUncheckedCreateInput>
    /**
     * In case the SiteAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteAttendanceUpdateInput, SiteAttendanceUncheckedUpdateInput>
  }

  /**
   * SiteAttendance delete
   */
  export type SiteAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceInclude<ExtArgs> | null
    /**
     * Filter which SiteAttendance to delete.
     */
    where: SiteAttendanceWhereUniqueInput
  }

  /**
   * SiteAttendance deleteMany
   */
  export type SiteAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteAttendances to delete
     */
    where?: SiteAttendanceWhereInput
    /**
     * Limit how many SiteAttendances to delete.
     */
    limit?: number
  }

  /**
   * SiteAttendance without action
   */
  export type SiteAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteAttendance
     */
    select?: SiteAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteAttendance
     */
    omit?: SiteAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteAttendanceInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    actionType: $Enums.AuditAction | null
    entityType: $Enums.AuditEntity | null
    ip: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    actionType: $Enums.AuditAction | null
    entityType: $Enums.AuditEntity | null
    ip: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    companyId: number
    action: number
    entity: number
    entityId: number
    actionType: number
    entityType: number
    ip: number
    userId: number
    data: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    companyId?: true
    action?: true
    entity?: true
    entityId?: true
    actionType?: true
    entityType?: true
    ip?: true
    userId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    companyId?: true
    action?: true
    entity?: true
    entityId?: true
    actionType?: true
    entityType?: true
    ip?: true
    userId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    companyId?: true
    action?: true
    entity?: true
    entityId?: true
    actionType?: true
    entityType?: true
    ip?: true
    userId?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    companyId: string
    action: string
    entity: string
    entityId: string
    actionType: $Enums.AuditAction | null
    entityType: $Enums.AuditEntity | null
    ip: string | null
    userId: string | null
    data: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    actionType?: boolean
    entityType?: boolean
    ip?: boolean
    userId?: boolean
    data?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    actionType?: boolean
    entityType?: boolean
    ip?: boolean
    userId?: boolean
    data?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    actionType?: boolean
    entityType?: boolean
    ip?: boolean
    userId?: boolean
    data?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    companyId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    actionType?: boolean
    entityType?: boolean
    ip?: boolean
    userId?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "action" | "entity" | "entityId" | "actionType" | "entityType" | "ip" | "userId" | "data" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      action: string
      entity: string
      entityId: string
      /**
       * Structured audit fields for long-term analytics.
       */
      actionType: $Enums.AuditAction | null
      entityType: $Enums.AuditEntity | null
      ip: string | null
      userId: string | null
      data: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly companyId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly actionType: FieldRef<"AuditLog", 'AuditAction'>
    readonly entityType: FieldRef<"AuditLog", 'AuditEntity'>
    readonly ip: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly data: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    role: $Enums.Role | null
    userId: string | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    role: $Enums.Role | null
    userId: string | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    companyId: number
    role: number
    userId: number
    deletedAt: number
    createdAt: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    companyId?: true
    role?: true
    userId?: true
    deletedAt?: true
    createdAt?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    companyId?: true
    role?: true
    userId?: true
    deletedAt?: true
    createdAt?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    companyId?: true
    role?: true
    userId?: true
    deletedAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    companyId: string
    role: $Enums.Role
    userId: string
    deletedAt: Date | null
    createdAt: Date
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    role?: boolean
    userId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    role?: boolean
    userId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    role?: boolean
    userId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    companyId?: boolean
    role?: boolean
    userId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "role" | "userId" | "deletedAt" | "createdAt", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      role: $Enums.Role
      userId: string
      deletedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly companyId: FieldRef<"UserRole", 'String'>
    readonly role: FieldRef<"UserRole", 'Role'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly deletedAt: FieldRef<"UserRole", 'DateTime'>
    readonly createdAt: FieldRef<"UserRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Person
   */

  export type AggregatePerson = {
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  export type PersonMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PersonMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PersonCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    phone: number
    companyId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PersonMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PersonMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PersonCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PersonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Person to aggregate.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned People
    **/
    _count?: true | PersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonMaxAggregateInputType
  }

  export type GetPersonAggregateType<T extends PersonAggregateArgs> = {
        [P in keyof T & keyof AggregatePerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerson[P]>
      : GetScalarType<T[P], AggregatePerson[P]>
  }




  export type PersonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
    orderBy?: PersonOrderByWithAggregationInput | PersonOrderByWithAggregationInput[]
    by: PersonScalarFieldEnum[] | PersonScalarFieldEnum
    having?: PersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonCountAggregateInputType | true
    _min?: PersonMinAggregateInputType
    _max?: PersonMaxAggregateInputType
  }

  export type PersonGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    phone: string | null
    companyId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  type GetPersonGroupByPayload<T extends PersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonGroupByOutputType[P]>
            : GetScalarType<T[P], PersonGroupByOutputType[P]>
        }
      >
    >


  export type PersonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | Person$userArgs<ExtArgs>
    employee?: boolean | Person$employeeArgs<ExtArgs>
    student?: boolean | Person$studentArgs<ExtArgs>
    worker?: boolean | Person$workerArgs<ExtArgs>
    constructionWorker?: boolean | Person$constructionWorkerArgs<ExtArgs>
    devices?: boolean | Person$devicesArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>

  export type PersonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>

  export type PersonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>

  export type PersonSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PersonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "phone" | "companyId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["person"]>
  export type PersonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | Person$userArgs<ExtArgs>
    employee?: boolean | Person$employeeArgs<ExtArgs>
    student?: boolean | Person$studentArgs<ExtArgs>
    worker?: boolean | Person$workerArgs<ExtArgs>
    constructionWorker?: boolean | Person$constructionWorkerArgs<ExtArgs>
    devices?: boolean | Person$devicesArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type PersonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PersonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Person"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
      worker: Prisma.$WorkerPayload<ExtArgs> | null
      constructionWorker: Prisma.$ConstructionWorkerPayload<ExtArgs> | null
      devices: Prisma.$DevicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      phone: string | null
      companyId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["person"]>
    composites: {}
  }

  type PersonGetPayload<S extends boolean | null | undefined | PersonDefaultArgs> = $Result.GetResult<Prisma.$PersonPayload, S>

  type PersonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonCountAggregateInputType | true
    }

  export interface PersonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Person'], meta: { name: 'Person' } }
    /**
     * Find zero or one Person that matches the filter.
     * @param {PersonFindUniqueArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonFindUniqueArgs>(args: SelectSubset<T, PersonFindUniqueArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Person that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonFindUniqueOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonFindFirstArgs>(args?: SelectSubset<T, PersonFindFirstArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Person that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all People
     * const people = await prisma.person.findMany()
     * 
     * // Get first 10 People
     * const people = await prisma.person.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personWithIdOnly = await prisma.person.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonFindManyArgs>(args?: SelectSubset<T, PersonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Person.
     * @param {PersonCreateArgs} args - Arguments to create a Person.
     * @example
     * // Create one Person
     * const Person = await prisma.person.create({
     *   data: {
     *     // ... data to create a Person
     *   }
     * })
     * 
     */
    create<T extends PersonCreateArgs>(args: SelectSubset<T, PersonCreateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many People.
     * @param {PersonCreateManyArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonCreateManyArgs>(args?: SelectSubset<T, PersonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many People and returns the data saved in the database.
     * @param {PersonCreateManyAndReturnArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many People and only return the `id`
     * const personWithIdOnly = await prisma.person.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Person.
     * @param {PersonDeleteArgs} args - Arguments to delete one Person.
     * @example
     * // Delete one Person
     * const Person = await prisma.person.delete({
     *   where: {
     *     // ... filter to delete one Person
     *   }
     * })
     * 
     */
    delete<T extends PersonDeleteArgs>(args: SelectSubset<T, PersonDeleteArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Person.
     * @param {PersonUpdateArgs} args - Arguments to update one Person.
     * @example
     * // Update one Person
     * const person = await prisma.person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonUpdateArgs>(args: SelectSubset<T, PersonUpdateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more People.
     * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
     * @example
     * // Delete a few People
     * const { count } = await prisma.person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonDeleteManyArgs>(args?: SelectSubset<T, PersonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many People
     * const person = await prisma.person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonUpdateManyArgs>(args: SelectSubset<T, PersonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People and returns the data updated in the database.
     * @param {PersonUpdateManyAndReturnArgs} args - Arguments to update many People.
     * @example
     * // Update many People
     * const person = await prisma.person.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more People and only return the `id`
     * const personWithIdOnly = await prisma.person.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Person.
     * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
     * @example
     * // Update or create a Person
     * const person = await prisma.person.upsert({
     *   create: {
     *     // ... data to create a Person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Person we want to update
     *   }
     * })
     */
    upsert<T extends PersonUpsertArgs>(args: SelectSubset<T, PersonUpsertArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonCountArgs} args - Arguments to filter People to count.
     * @example
     * // Count the number of People
     * const count = await prisma.person.count({
     *   where: {
     *     // ... the filter for the People we want to count
     *   }
     * })
    **/
    count<T extends PersonCountArgs>(
      args?: Subset<T, PersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonAggregateArgs>(args: Subset<T, PersonAggregateArgs>): Prisma.PrismaPromise<GetPersonAggregateType<T>>

    /**
     * Group by Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonGroupByArgs['orderBy'] }
        : { orderBy?: PersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Person model
   */
  readonly fields: PersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Person$userArgs<ExtArgs> = {}>(args?: Subset<T, Person$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employee<T extends Person$employeeArgs<ExtArgs> = {}>(args?: Subset<T, Person$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends Person$studentArgs<ExtArgs> = {}>(args?: Subset<T, Person$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    worker<T extends Person$workerArgs<ExtArgs> = {}>(args?: Subset<T, Person$workerArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    constructionWorker<T extends Person$constructionWorkerArgs<ExtArgs> = {}>(args?: Subset<T, Person$constructionWorkerArgs<ExtArgs>>): Prisma__ConstructionWorkerClient<$Result.GetResult<Prisma.$ConstructionWorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    devices<T extends Person$devicesArgs<ExtArgs> = {}>(args?: Subset<T, Person$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Person model
   */
  interface PersonFieldRefs {
    readonly id: FieldRef<"Person", 'String'>
    readonly firstName: FieldRef<"Person", 'String'>
    readonly lastName: FieldRef<"Person", 'String'>
    readonly phone: FieldRef<"Person", 'String'>
    readonly companyId: FieldRef<"Person", 'String'>
    readonly createdAt: FieldRef<"Person", 'DateTime'>
    readonly updatedAt: FieldRef<"Person", 'DateTime'>
    readonly deletedAt: FieldRef<"Person", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Person findUnique
   */
  export type PersonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findUniqueOrThrow
   */
  export type PersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findFirst
   */
  export type PersonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findFirstOrThrow
   */
  export type PersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findMany
   */
  export type PersonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person create
   */
  export type PersonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to create a Person.
     */
    data: XOR<PersonCreateInput, PersonUncheckedCreateInput>
  }

  /**
   * Person createMany
   */
  export type PersonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Person createManyAndReturn
   */
  export type PersonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Person update
   */
  export type PersonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to update a Person.
     */
    data: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
    /**
     * Choose, which Person to update.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person updateMany
   */
  export type PersonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to update.
     */
    limit?: number
  }

  /**
   * Person updateManyAndReturn
   */
  export type PersonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Person upsert
   */
  export type PersonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The filter to search for the Person to update in case it exists.
     */
    where: PersonWhereUniqueInput
    /**
     * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
     */
    create: XOR<PersonCreateInput, PersonUncheckedCreateInput>
    /**
     * In case the Person was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
  }

  /**
   * Person delete
   */
  export type PersonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter which Person to delete.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person deleteMany
   */
  export type PersonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which People to delete
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to delete.
     */
    limit?: number
  }

  /**
   * Person.user
   */
  export type Person$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Person.employee
   */
  export type Person$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Person.student
   */
  export type Person$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * Person.worker
   */
  export type Person$workerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
  }

  /**
   * Person.constructionWorker
   */
  export type Person$constructionWorkerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionWorker
     */
    select?: ConstructionWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionWorker
     */
    omit?: ConstructionWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionWorkerInclude<ExtArgs> | null
    where?: ConstructionWorkerWhereInput
  }

  /**
   * Person.devices
   */
  export type Person$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Person without action
   */
  export type PersonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    personId: string | null
    userId: string | null
    scheduleId: string | null
    matricule: string | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    personId: string | null
    userId: string | null
    scheduleId: string | null
    matricule: string | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    companyId: number
    personId: number
    userId: number
    scheduleId: number
    matricule: number
    deletedAt: number
    createdAt: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    companyId?: true
    personId?: true
    userId?: true
    scheduleId?: true
    matricule?: true
    deletedAt?: true
    createdAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    companyId?: true
    personId?: true
    userId?: true
    scheduleId?: true
    matricule?: true
    deletedAt?: true
    createdAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    companyId?: true
    personId?: true
    userId?: true
    scheduleId?: true
    matricule?: true
    deletedAt?: true
    createdAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    companyId: string
    personId: string
    userId: string | null
    scheduleId: string | null
    matricule: string | null
    deletedAt: Date | null
    createdAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    personId?: boolean
    userId?: boolean
    scheduleId?: boolean
    matricule?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
    schedule?: boolean | Employee$scheduleArgs<ExtArgs>
    attendances?: boolean | Employee$attendancesArgs<ExtArgs>
    dailySummaries?: boolean | Employee$dailySummariesArgs<ExtArgs>
    payrollLines?: boolean | Employee$payrollLinesArgs<ExtArgs>
    contracts?: boolean | Employee$contractsArgs<ExtArgs>
    leaveBalances?: boolean | Employee$leaveBalancesArgs<ExtArgs>
    leaveRequests?: boolean | Employee$leaveRequestsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    personId?: boolean
    userId?: boolean
    scheduleId?: boolean
    matricule?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
    schedule?: boolean | Employee$scheduleArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    personId?: boolean
    userId?: boolean
    scheduleId?: boolean
    matricule?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
    schedule?: boolean | Employee$scheduleArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    companyId?: boolean
    personId?: boolean
    userId?: boolean
    scheduleId?: boolean
    matricule?: boolean
    deletedAt?: boolean
    createdAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "personId" | "userId" | "scheduleId" | "matricule" | "deletedAt" | "createdAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
    schedule?: boolean | Employee$scheduleArgs<ExtArgs>
    attendances?: boolean | Employee$attendancesArgs<ExtArgs>
    dailySummaries?: boolean | Employee$dailySummariesArgs<ExtArgs>
    payrollLines?: boolean | Employee$payrollLinesArgs<ExtArgs>
    contracts?: boolean | Employee$contractsArgs<ExtArgs>
    leaveBalances?: boolean | Employee$leaveBalancesArgs<ExtArgs>
    leaveRequests?: boolean | Employee$leaveRequestsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
    schedule?: boolean | Employee$scheduleArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
    schedule?: boolean | Employee$scheduleArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      person: Prisma.$PersonPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      schedule: Prisma.$SchedulePayload<ExtArgs> | null
      attendances: Prisma.$AttendanceEventPayload<ExtArgs>[]
      dailySummaries: Prisma.$AttendanceDailySummaryPayload<ExtArgs>[]
      payrollLines: Prisma.$PayrollLinePayload<ExtArgs>[]
      contracts: Prisma.$ContractPayload<ExtArgs>[]
      leaveBalances: Prisma.$LeaveBalancePayload<ExtArgs>[]
      leaveRequests: Prisma.$LeaveRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      personId: string
      userId: string | null
      scheduleId: string | null
      matricule: string | null
      deletedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Employee$userArgs<ExtArgs> = {}>(args?: Subset<T, Employee$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    schedule<T extends Employee$scheduleArgs<ExtArgs> = {}>(args?: Subset<T, Employee$scheduleArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attendances<T extends Employee$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailySummaries<T extends Employee$dailySummariesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$dailySummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrollLines<T extends Employee$payrollLinesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$payrollLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contracts<T extends Employee$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaveBalances<T extends Employee$leaveBalancesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$leaveBalancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaveRequests<T extends Employee$leaveRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$leaveRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly companyId: FieldRef<"Employee", 'String'>
    readonly personId: FieldRef<"Employee", 'String'>
    readonly userId: FieldRef<"Employee", 'String'>
    readonly scheduleId: FieldRef<"Employee", 'String'>
    readonly matricule: FieldRef<"Employee", 'String'>
    readonly deletedAt: FieldRef<"Employee", 'DateTime'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.user
   */
  export type Employee$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Employee.schedule
   */
  export type Employee$scheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
  }

  /**
   * Employee.attendances
   */
  export type Employee$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    where?: AttendanceEventWhereInput
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    cursor?: AttendanceEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * Employee.dailySummaries
   */
  export type Employee$dailySummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    where?: AttendanceDailySummaryWhereInput
    orderBy?: AttendanceDailySummaryOrderByWithRelationInput | AttendanceDailySummaryOrderByWithRelationInput[]
    cursor?: AttendanceDailySummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceDailySummaryScalarFieldEnum | AttendanceDailySummaryScalarFieldEnum[]
  }

  /**
   * Employee.payrollLines
   */
  export type Employee$payrollLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    where?: PayrollLineWhereInput
    orderBy?: PayrollLineOrderByWithRelationInput | PayrollLineOrderByWithRelationInput[]
    cursor?: PayrollLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollLineScalarFieldEnum | PayrollLineScalarFieldEnum[]
  }

  /**
   * Employee.contracts
   */
  export type Employee$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Employee.leaveBalances
   */
  export type Employee$leaveBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    where?: LeaveBalanceWhereInput
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    cursor?: LeaveBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * Employee.leaveRequests
   */
  export type Employee$leaveRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Worker
   */

  export type AggregateWorker = {
    _count: WorkerCountAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  export type WorkerMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    personId: string | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type WorkerMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    personId: string | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type WorkerCountAggregateOutputType = {
    id: number
    companyId: number
    personId: number
    deletedAt: number
    createdAt: number
    _all: number
  }


  export type WorkerMinAggregateInputType = {
    id?: true
    companyId?: true
    personId?: true
    deletedAt?: true
    createdAt?: true
  }

  export type WorkerMaxAggregateInputType = {
    id?: true
    companyId?: true
    personId?: true
    deletedAt?: true
    createdAt?: true
  }

  export type WorkerCountAggregateInputType = {
    id?: true
    companyId?: true
    personId?: true
    deletedAt?: true
    createdAt?: true
    _all?: true
  }

  export type WorkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Worker to aggregate.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workers
    **/
    _count?: true | WorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerMaxAggregateInputType
  }

  export type GetWorkerAggregateType<T extends WorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorker[P]>
      : GetScalarType<T[P], AggregateWorker[P]>
  }




  export type WorkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithAggregationInput | WorkerOrderByWithAggregationInput[]
    by: WorkerScalarFieldEnum[] | WorkerScalarFieldEnum
    having?: WorkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerCountAggregateInputType | true
    _min?: WorkerMinAggregateInputType
    _max?: WorkerMaxAggregateInputType
  }

  export type WorkerGroupByOutputType = {
    id: string
    companyId: string
    personId: string
    deletedAt: Date | null
    createdAt: Date
    _count: WorkerCountAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  type GetWorkerGroupByPayload<T extends WorkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerGroupByOutputType[P]>
        }
      >
    >


  export type WorkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    personId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
    attendances?: boolean | Worker$attendancesArgs<ExtArgs>
    dailySummaries?: boolean | Worker$dailySummariesArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    personId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    personId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectScalar = {
    id?: boolean
    companyId?: boolean
    personId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
  }

  export type WorkerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "personId" | "deletedAt" | "createdAt", ExtArgs["result"]["worker"]>
  export type WorkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
    attendances?: boolean | Worker$attendancesArgs<ExtArgs>
    dailySummaries?: boolean | Worker$dailySummariesArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type WorkerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $WorkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Worker"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      person: Prisma.$PersonPayload<ExtArgs>
      attendances: Prisma.$AttendanceEventPayload<ExtArgs>[]
      dailySummaries: Prisma.$AttendanceDailySummaryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      personId: string
      deletedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["worker"]>
    composites: {}
  }

  type WorkerGetPayload<S extends boolean | null | undefined | WorkerDefaultArgs> = $Result.GetResult<Prisma.$WorkerPayload, S>

  type WorkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkerCountAggregateInputType | true
    }

  export interface WorkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Worker'], meta: { name: 'Worker' } }
    /**
     * Find zero or one Worker that matches the filter.
     * @param {WorkerFindUniqueArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerFindUniqueArgs>(args: SelectSubset<T, WorkerFindUniqueArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Worker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkerFindUniqueOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Worker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerFindFirstArgs>(args?: SelectSubset<T, WorkerFindFirstArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Worker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workers
     * const workers = await prisma.worker.findMany()
     * 
     * // Get first 10 Workers
     * const workers = await prisma.worker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerWithIdOnly = await prisma.worker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerFindManyArgs>(args?: SelectSubset<T, WorkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Worker.
     * @param {WorkerCreateArgs} args - Arguments to create a Worker.
     * @example
     * // Create one Worker
     * const Worker = await prisma.worker.create({
     *   data: {
     *     // ... data to create a Worker
     *   }
     * })
     * 
     */
    create<T extends WorkerCreateArgs>(args: SelectSubset<T, WorkerCreateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workers.
     * @param {WorkerCreateManyArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerCreateManyArgs>(args?: SelectSubset<T, WorkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workers and returns the data saved in the database.
     * @param {WorkerCreateManyAndReturnArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workers and only return the `id`
     * const workerWithIdOnly = await prisma.worker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Worker.
     * @param {WorkerDeleteArgs} args - Arguments to delete one Worker.
     * @example
     * // Delete one Worker
     * const Worker = await prisma.worker.delete({
     *   where: {
     *     // ... filter to delete one Worker
     *   }
     * })
     * 
     */
    delete<T extends WorkerDeleteArgs>(args: SelectSubset<T, WorkerDeleteArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Worker.
     * @param {WorkerUpdateArgs} args - Arguments to update one Worker.
     * @example
     * // Update one Worker
     * const worker = await prisma.worker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerUpdateArgs>(args: SelectSubset<T, WorkerUpdateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workers.
     * @param {WorkerDeleteManyArgs} args - Arguments to filter Workers to delete.
     * @example
     * // Delete a few Workers
     * const { count } = await prisma.worker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerDeleteManyArgs>(args?: SelectSubset<T, WorkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workers
     * const worker = await prisma.worker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerUpdateManyArgs>(args: SelectSubset<T, WorkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workers and returns the data updated in the database.
     * @param {WorkerUpdateManyAndReturnArgs} args - Arguments to update many Workers.
     * @example
     * // Update many Workers
     * const worker = await prisma.worker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workers and only return the `id`
     * const workerWithIdOnly = await prisma.worker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkerUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Worker.
     * @param {WorkerUpsertArgs} args - Arguments to update or create a Worker.
     * @example
     * // Update or create a Worker
     * const worker = await prisma.worker.upsert({
     *   create: {
     *     // ... data to create a Worker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Worker we want to update
     *   }
     * })
     */
    upsert<T extends WorkerUpsertArgs>(args: SelectSubset<T, WorkerUpsertArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerCountArgs} args - Arguments to filter Workers to count.
     * @example
     * // Count the number of Workers
     * const count = await prisma.worker.count({
     *   where: {
     *     // ... the filter for the Workers we want to count
     *   }
     * })
    **/
    count<T extends WorkerCountArgs>(
      args?: Subset<T, WorkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerAggregateArgs>(args: Subset<T, WorkerAggregateArgs>): Prisma.PrismaPromise<GetWorkerAggregateType<T>>

    /**
     * Group by Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerGroupByArgs['orderBy'] }
        : { orderBy?: WorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Worker model
   */
  readonly fields: WorkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Worker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendances<T extends Worker$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Worker$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailySummaries<T extends Worker$dailySummariesArgs<ExtArgs> = {}>(args?: Subset<T, Worker$dailySummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Worker model
   */
  interface WorkerFieldRefs {
    readonly id: FieldRef<"Worker", 'String'>
    readonly companyId: FieldRef<"Worker", 'String'>
    readonly personId: FieldRef<"Worker", 'String'>
    readonly deletedAt: FieldRef<"Worker", 'DateTime'>
    readonly createdAt: FieldRef<"Worker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Worker findUnique
   */
  export type WorkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findUniqueOrThrow
   */
  export type WorkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findFirst
   */
  export type WorkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findFirstOrThrow
   */
  export type WorkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findMany
   */
  export type WorkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Workers to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker create
   */
  export type WorkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to create a Worker.
     */
    data: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
  }

  /**
   * Worker createMany
   */
  export type WorkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Worker createManyAndReturn
   */
  export type WorkerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Worker update
   */
  export type WorkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to update a Worker.
     */
    data: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
    /**
     * Choose, which Worker to update.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker updateMany
   */
  export type WorkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workers.
     */
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyInput>
    /**
     * Filter which Workers to update
     */
    where?: WorkerWhereInput
    /**
     * Limit how many Workers to update.
     */
    limit?: number
  }

  /**
   * Worker updateManyAndReturn
   */
  export type WorkerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * The data used to update Workers.
     */
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyInput>
    /**
     * Filter which Workers to update
     */
    where?: WorkerWhereInput
    /**
     * Limit how many Workers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Worker upsert
   */
  export type WorkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The filter to search for the Worker to update in case it exists.
     */
    where: WorkerWhereUniqueInput
    /**
     * In case the Worker found by the `where` argument doesn't exist, create a new Worker with this data.
     */
    create: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
    /**
     * In case the Worker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
  }

  /**
   * Worker delete
   */
  export type WorkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter which Worker to delete.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker deleteMany
   */
  export type WorkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workers to delete
     */
    where?: WorkerWhereInput
    /**
     * Limit how many Workers to delete.
     */
    limit?: number
  }

  /**
   * Worker.attendances
   */
  export type Worker$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    where?: AttendanceEventWhereInput
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    cursor?: AttendanceEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * Worker.dailySummaries
   */
  export type Worker$dailySummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    where?: AttendanceDailySummaryWhereInput
    orderBy?: AttendanceDailySummaryOrderByWithRelationInput | AttendanceDailySummaryOrderByWithRelationInput[]
    cursor?: AttendanceDailySummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceDailySummaryScalarFieldEnum | AttendanceDailySummaryScalarFieldEnum[]
  }

  /**
   * Worker without action
   */
  export type WorkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceEvent
   */

  export type AggregateAttendanceEvent = {
    _count: AttendanceEventCountAggregateOutputType | null
    _min: AttendanceEventMinAggregateOutputType | null
    _max: AttendanceEventMaxAggregateOutputType | null
  }

  export type AttendanceEventMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    type: $Enums.AttendanceType | null
    timestamp: Date | null
    date: Date | null
    personType: $Enums.PersonType | null
    employeeId: string | null
    studentId: string | null
    workerId: string | null
    deviceId: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type AttendanceEventMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    type: $Enums.AttendanceType | null
    timestamp: Date | null
    date: Date | null
    personType: $Enums.PersonType | null
    employeeId: string | null
    studentId: string | null
    workerId: string | null
    deviceId: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type AttendanceEventCountAggregateOutputType = {
    id: number
    companyId: number
    type: number
    timestamp: number
    date: number
    personType: number
    employeeId: number
    studentId: number
    workerId: number
    deviceId: number
    createdAt: number
    deletedAt: number
    _all: number
  }


  export type AttendanceEventMinAggregateInputType = {
    id?: true
    companyId?: true
    type?: true
    timestamp?: true
    date?: true
    personType?: true
    employeeId?: true
    studentId?: true
    workerId?: true
    deviceId?: true
    createdAt?: true
    deletedAt?: true
  }

  export type AttendanceEventMaxAggregateInputType = {
    id?: true
    companyId?: true
    type?: true
    timestamp?: true
    date?: true
    personType?: true
    employeeId?: true
    studentId?: true
    workerId?: true
    deviceId?: true
    createdAt?: true
    deletedAt?: true
  }

  export type AttendanceEventCountAggregateInputType = {
    id?: true
    companyId?: true
    type?: true
    timestamp?: true
    date?: true
    personType?: true
    employeeId?: true
    studentId?: true
    workerId?: true
    deviceId?: true
    createdAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AttendanceEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceEvent to aggregate.
     */
    where?: AttendanceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceEvents to fetch.
     */
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceEvents
    **/
    _count?: true | AttendanceEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceEventMaxAggregateInputType
  }

  export type GetAttendanceEventAggregateType<T extends AttendanceEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceEvent[P]>
      : GetScalarType<T[P], AggregateAttendanceEvent[P]>
  }




  export type AttendanceEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceEventWhereInput
    orderBy?: AttendanceEventOrderByWithAggregationInput | AttendanceEventOrderByWithAggregationInput[]
    by: AttendanceEventScalarFieldEnum[] | AttendanceEventScalarFieldEnum
    having?: AttendanceEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceEventCountAggregateInputType | true
    _min?: AttendanceEventMinAggregateInputType
    _max?: AttendanceEventMaxAggregateInputType
  }

  export type AttendanceEventGroupByOutputType = {
    id: string
    companyId: string
    type: $Enums.AttendanceType
    timestamp: Date
    date: Date
    personType: $Enums.PersonType
    employeeId: string | null
    studentId: string | null
    workerId: string | null
    deviceId: string | null
    createdAt: Date
    deletedAt: Date | null
    _count: AttendanceEventCountAggregateOutputType | null
    _min: AttendanceEventMinAggregateOutputType | null
    _max: AttendanceEventMaxAggregateOutputType | null
  }

  type GetAttendanceEventGroupByPayload<T extends AttendanceEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceEventGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceEventGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    type?: boolean
    timestamp?: boolean
    date?: boolean
    personType?: boolean
    employeeId?: boolean
    studentId?: boolean
    workerId?: boolean
    deviceId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | AttendanceEvent$employeeArgs<ExtArgs>
    student?: boolean | AttendanceEvent$studentArgs<ExtArgs>
    worker?: boolean | AttendanceEvent$workerArgs<ExtArgs>
    device?: boolean | AttendanceEvent$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceEvent"]>

  export type AttendanceEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    type?: boolean
    timestamp?: boolean
    date?: boolean
    personType?: boolean
    employeeId?: boolean
    studentId?: boolean
    workerId?: boolean
    deviceId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | AttendanceEvent$employeeArgs<ExtArgs>
    student?: boolean | AttendanceEvent$studentArgs<ExtArgs>
    worker?: boolean | AttendanceEvent$workerArgs<ExtArgs>
    device?: boolean | AttendanceEvent$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceEvent"]>

  export type AttendanceEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    type?: boolean
    timestamp?: boolean
    date?: boolean
    personType?: boolean
    employeeId?: boolean
    studentId?: boolean
    workerId?: boolean
    deviceId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | AttendanceEvent$employeeArgs<ExtArgs>
    student?: boolean | AttendanceEvent$studentArgs<ExtArgs>
    worker?: boolean | AttendanceEvent$workerArgs<ExtArgs>
    device?: boolean | AttendanceEvent$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceEvent"]>

  export type AttendanceEventSelectScalar = {
    id?: boolean
    companyId?: boolean
    type?: boolean
    timestamp?: boolean
    date?: boolean
    personType?: boolean
    employeeId?: boolean
    studentId?: boolean
    workerId?: boolean
    deviceId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
  }

  export type AttendanceEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "type" | "timestamp" | "date" | "personType" | "employeeId" | "studentId" | "workerId" | "deviceId" | "createdAt" | "deletedAt", ExtArgs["result"]["attendanceEvent"]>
  export type AttendanceEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | AttendanceEvent$employeeArgs<ExtArgs>
    student?: boolean | AttendanceEvent$studentArgs<ExtArgs>
    worker?: boolean | AttendanceEvent$workerArgs<ExtArgs>
    device?: boolean | AttendanceEvent$deviceArgs<ExtArgs>
  }
  export type AttendanceEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | AttendanceEvent$employeeArgs<ExtArgs>
    student?: boolean | AttendanceEvent$studentArgs<ExtArgs>
    worker?: boolean | AttendanceEvent$workerArgs<ExtArgs>
    device?: boolean | AttendanceEvent$deviceArgs<ExtArgs>
  }
  export type AttendanceEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | AttendanceEvent$employeeArgs<ExtArgs>
    student?: boolean | AttendanceEvent$studentArgs<ExtArgs>
    worker?: boolean | AttendanceEvent$workerArgs<ExtArgs>
    device?: boolean | AttendanceEvent$deviceArgs<ExtArgs>
  }

  export type $AttendanceEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceEvent"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
      worker: Prisma.$WorkerPayload<ExtArgs> | null
      device: Prisma.$DevicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      type: $Enums.AttendanceType
      timestamp: Date
      date: Date
      personType: $Enums.PersonType
      employeeId: string | null
      studentId: string | null
      workerId: string | null
      deviceId: string | null
      createdAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["attendanceEvent"]>
    composites: {}
  }

  type AttendanceEventGetPayload<S extends boolean | null | undefined | AttendanceEventDefaultArgs> = $Result.GetResult<Prisma.$AttendanceEventPayload, S>

  type AttendanceEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceEventCountAggregateInputType | true
    }

  export interface AttendanceEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceEvent'], meta: { name: 'AttendanceEvent' } }
    /**
     * Find zero or one AttendanceEvent that matches the filter.
     * @param {AttendanceEventFindUniqueArgs} args - Arguments to find a AttendanceEvent
     * @example
     * // Get one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceEventFindUniqueArgs>(args: SelectSubset<T, AttendanceEventFindUniqueArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceEventFindUniqueOrThrowArgs} args - Arguments to find a AttendanceEvent
     * @example
     * // Get one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventFindFirstArgs} args - Arguments to find a AttendanceEvent
     * @example
     * // Get one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceEventFindFirstArgs>(args?: SelectSubset<T, AttendanceEventFindFirstArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventFindFirstOrThrowArgs} args - Arguments to find a AttendanceEvent
     * @example
     * // Get one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceEvents
     * const attendanceEvents = await prisma.attendanceEvent.findMany()
     * 
     * // Get first 10 AttendanceEvents
     * const attendanceEvents = await prisma.attendanceEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceEventWithIdOnly = await prisma.attendanceEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceEventFindManyArgs>(args?: SelectSubset<T, AttendanceEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceEvent.
     * @param {AttendanceEventCreateArgs} args - Arguments to create a AttendanceEvent.
     * @example
     * // Create one AttendanceEvent
     * const AttendanceEvent = await prisma.attendanceEvent.create({
     *   data: {
     *     // ... data to create a AttendanceEvent
     *   }
     * })
     * 
     */
    create<T extends AttendanceEventCreateArgs>(args: SelectSubset<T, AttendanceEventCreateArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceEvents.
     * @param {AttendanceEventCreateManyArgs} args - Arguments to create many AttendanceEvents.
     * @example
     * // Create many AttendanceEvents
     * const attendanceEvent = await prisma.attendanceEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceEventCreateManyArgs>(args?: SelectSubset<T, AttendanceEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceEvents and returns the data saved in the database.
     * @param {AttendanceEventCreateManyAndReturnArgs} args - Arguments to create many AttendanceEvents.
     * @example
     * // Create many AttendanceEvents
     * const attendanceEvent = await prisma.attendanceEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceEvents and only return the `id`
     * const attendanceEventWithIdOnly = await prisma.attendanceEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceEvent.
     * @param {AttendanceEventDeleteArgs} args - Arguments to delete one AttendanceEvent.
     * @example
     * // Delete one AttendanceEvent
     * const AttendanceEvent = await prisma.attendanceEvent.delete({
     *   where: {
     *     // ... filter to delete one AttendanceEvent
     *   }
     * })
     * 
     */
    delete<T extends AttendanceEventDeleteArgs>(args: SelectSubset<T, AttendanceEventDeleteArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceEvent.
     * @param {AttendanceEventUpdateArgs} args - Arguments to update one AttendanceEvent.
     * @example
     * // Update one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceEventUpdateArgs>(args: SelectSubset<T, AttendanceEventUpdateArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceEvents.
     * @param {AttendanceEventDeleteManyArgs} args - Arguments to filter AttendanceEvents to delete.
     * @example
     * // Delete a few AttendanceEvents
     * const { count } = await prisma.attendanceEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceEventDeleteManyArgs>(args?: SelectSubset<T, AttendanceEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceEvents
     * const attendanceEvent = await prisma.attendanceEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceEventUpdateManyArgs>(args: SelectSubset<T, AttendanceEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceEvents and returns the data updated in the database.
     * @param {AttendanceEventUpdateManyAndReturnArgs} args - Arguments to update many AttendanceEvents.
     * @example
     * // Update many AttendanceEvents
     * const attendanceEvent = await prisma.attendanceEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceEvents and only return the `id`
     * const attendanceEventWithIdOnly = await prisma.attendanceEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceEvent.
     * @param {AttendanceEventUpsertArgs} args - Arguments to update or create a AttendanceEvent.
     * @example
     * // Update or create a AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.upsert({
     *   create: {
     *     // ... data to create a AttendanceEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceEvent we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceEventUpsertArgs>(args: SelectSubset<T, AttendanceEventUpsertArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventCountArgs} args - Arguments to filter AttendanceEvents to count.
     * @example
     * // Count the number of AttendanceEvents
     * const count = await prisma.attendanceEvent.count({
     *   where: {
     *     // ... the filter for the AttendanceEvents we want to count
     *   }
     * })
    **/
    count<T extends AttendanceEventCountArgs>(
      args?: Subset<T, AttendanceEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceEventAggregateArgs>(args: Subset<T, AttendanceEventAggregateArgs>): Prisma.PrismaPromise<GetAttendanceEventAggregateType<T>>

    /**
     * Group by AttendanceEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceEventGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceEvent model
   */
  readonly fields: AttendanceEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends AttendanceEvent$employeeArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceEvent$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends AttendanceEvent$studentArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceEvent$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    worker<T extends AttendanceEvent$workerArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceEvent$workerArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    device<T extends AttendanceEvent$deviceArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceEvent$deviceArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceEvent model
   */
  interface AttendanceEventFieldRefs {
    readonly id: FieldRef<"AttendanceEvent", 'String'>
    readonly companyId: FieldRef<"AttendanceEvent", 'String'>
    readonly type: FieldRef<"AttendanceEvent", 'AttendanceType'>
    readonly timestamp: FieldRef<"AttendanceEvent", 'DateTime'>
    readonly date: FieldRef<"AttendanceEvent", 'DateTime'>
    readonly personType: FieldRef<"AttendanceEvent", 'PersonType'>
    readonly employeeId: FieldRef<"AttendanceEvent", 'String'>
    readonly studentId: FieldRef<"AttendanceEvent", 'String'>
    readonly workerId: FieldRef<"AttendanceEvent", 'String'>
    readonly deviceId: FieldRef<"AttendanceEvent", 'String'>
    readonly createdAt: FieldRef<"AttendanceEvent", 'DateTime'>
    readonly deletedAt: FieldRef<"AttendanceEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceEvent findUnique
   */
  export type AttendanceEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvent to fetch.
     */
    where: AttendanceEventWhereUniqueInput
  }

  /**
   * AttendanceEvent findUniqueOrThrow
   */
  export type AttendanceEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvent to fetch.
     */
    where: AttendanceEventWhereUniqueInput
  }

  /**
   * AttendanceEvent findFirst
   */
  export type AttendanceEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvent to fetch.
     */
    where?: AttendanceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceEvents to fetch.
     */
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceEvents.
     */
    cursor?: AttendanceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceEvents.
     */
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * AttendanceEvent findFirstOrThrow
   */
  export type AttendanceEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvent to fetch.
     */
    where?: AttendanceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceEvents to fetch.
     */
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceEvents.
     */
    cursor?: AttendanceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceEvents.
     */
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * AttendanceEvent findMany
   */
  export type AttendanceEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvents to fetch.
     */
    where?: AttendanceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceEvents to fetch.
     */
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceEvents.
     */
    cursor?: AttendanceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceEvents.
     */
    skip?: number
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * AttendanceEvent create
   */
  export type AttendanceEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceEvent.
     */
    data: XOR<AttendanceEventCreateInput, AttendanceEventUncheckedCreateInput>
  }

  /**
   * AttendanceEvent createMany
   */
  export type AttendanceEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceEvents.
     */
    data: AttendanceEventCreateManyInput | AttendanceEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceEvent createManyAndReturn
   */
  export type AttendanceEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceEvents.
     */
    data: AttendanceEventCreateManyInput | AttendanceEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceEvent update
   */
  export type AttendanceEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceEvent.
     */
    data: XOR<AttendanceEventUpdateInput, AttendanceEventUncheckedUpdateInput>
    /**
     * Choose, which AttendanceEvent to update.
     */
    where: AttendanceEventWhereUniqueInput
  }

  /**
   * AttendanceEvent updateMany
   */
  export type AttendanceEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceEvents.
     */
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceEvents to update
     */
    where?: AttendanceEventWhereInput
    /**
     * Limit how many AttendanceEvents to update.
     */
    limit?: number
  }

  /**
   * AttendanceEvent updateManyAndReturn
   */
  export type AttendanceEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceEvents.
     */
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceEvents to update
     */
    where?: AttendanceEventWhereInput
    /**
     * Limit how many AttendanceEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceEvent upsert
   */
  export type AttendanceEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceEvent to update in case it exists.
     */
    where: AttendanceEventWhereUniqueInput
    /**
     * In case the AttendanceEvent found by the `where` argument doesn't exist, create a new AttendanceEvent with this data.
     */
    create: XOR<AttendanceEventCreateInput, AttendanceEventUncheckedCreateInput>
    /**
     * In case the AttendanceEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceEventUpdateInput, AttendanceEventUncheckedUpdateInput>
  }

  /**
   * AttendanceEvent delete
   */
  export type AttendanceEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter which AttendanceEvent to delete.
     */
    where: AttendanceEventWhereUniqueInput
  }

  /**
   * AttendanceEvent deleteMany
   */
  export type AttendanceEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceEvents to delete
     */
    where?: AttendanceEventWhereInput
    /**
     * Limit how many AttendanceEvents to delete.
     */
    limit?: number
  }

  /**
   * AttendanceEvent.employee
   */
  export type AttendanceEvent$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * AttendanceEvent.student
   */
  export type AttendanceEvent$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * AttendanceEvent.worker
   */
  export type AttendanceEvent$workerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
  }

  /**
   * AttendanceEvent.device
   */
  export type AttendanceEvent$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
  }

  /**
   * AttendanceEvent without action
   */
  export type AttendanceEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceDailySummary
   */

  export type AggregateAttendanceDailySummary = {
    _count: AttendanceDailySummaryCountAggregateOutputType | null
    _avg: AttendanceDailySummaryAvgAggregateOutputType | null
    _sum: AttendanceDailySummarySumAggregateOutputType | null
    _min: AttendanceDailySummaryMinAggregateOutputType | null
    _max: AttendanceDailySummaryMaxAggregateOutputType | null
  }

  export type AttendanceDailySummaryAvgAggregateOutputType = {
    lateMinutes: number | null
    earlyMinutes: number | null
    workedMinutes: number | null
  }

  export type AttendanceDailySummarySumAggregateOutputType = {
    lateMinutes: number | null
    earlyMinutes: number | null
    workedMinutes: number | null
  }

  export type AttendanceDailySummaryMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    lateMinutes: number | null
    earlyMinutes: number | null
    workedMinutes: number | null
    employeeId: string | null
    studentId: string | null
    workerId: string | null
    validatedByUserId: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type AttendanceDailySummaryMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    lateMinutes: number | null
    earlyMinutes: number | null
    workedMinutes: number | null
    employeeId: string | null
    studentId: string | null
    workerId: string | null
    validatedByUserId: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type AttendanceDailySummaryCountAggregateOutputType = {
    id: number
    companyId: number
    date: number
    status: number
    lateMinutes: number
    earlyMinutes: number
    workedMinutes: number
    employeeId: number
    studentId: number
    workerId: number
    validatedByUserId: number
    createdAt: number
    deletedAt: number
    _all: number
  }


  export type AttendanceDailySummaryAvgAggregateInputType = {
    lateMinutes?: true
    earlyMinutes?: true
    workedMinutes?: true
  }

  export type AttendanceDailySummarySumAggregateInputType = {
    lateMinutes?: true
    earlyMinutes?: true
    workedMinutes?: true
  }

  export type AttendanceDailySummaryMinAggregateInputType = {
    id?: true
    companyId?: true
    date?: true
    status?: true
    lateMinutes?: true
    earlyMinutes?: true
    workedMinutes?: true
    employeeId?: true
    studentId?: true
    workerId?: true
    validatedByUserId?: true
    createdAt?: true
    deletedAt?: true
  }

  export type AttendanceDailySummaryMaxAggregateInputType = {
    id?: true
    companyId?: true
    date?: true
    status?: true
    lateMinutes?: true
    earlyMinutes?: true
    workedMinutes?: true
    employeeId?: true
    studentId?: true
    workerId?: true
    validatedByUserId?: true
    createdAt?: true
    deletedAt?: true
  }

  export type AttendanceDailySummaryCountAggregateInputType = {
    id?: true
    companyId?: true
    date?: true
    status?: true
    lateMinutes?: true
    earlyMinutes?: true
    workedMinutes?: true
    employeeId?: true
    studentId?: true
    workerId?: true
    validatedByUserId?: true
    createdAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AttendanceDailySummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceDailySummary to aggregate.
     */
    where?: AttendanceDailySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDailySummaries to fetch.
     */
    orderBy?: AttendanceDailySummaryOrderByWithRelationInput | AttendanceDailySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceDailySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDailySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDailySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceDailySummaries
    **/
    _count?: true | AttendanceDailySummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceDailySummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceDailySummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceDailySummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceDailySummaryMaxAggregateInputType
  }

  export type GetAttendanceDailySummaryAggregateType<T extends AttendanceDailySummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceDailySummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceDailySummary[P]>
      : GetScalarType<T[P], AggregateAttendanceDailySummary[P]>
  }




  export type AttendanceDailySummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDailySummaryWhereInput
    orderBy?: AttendanceDailySummaryOrderByWithAggregationInput | AttendanceDailySummaryOrderByWithAggregationInput[]
    by: AttendanceDailySummaryScalarFieldEnum[] | AttendanceDailySummaryScalarFieldEnum
    having?: AttendanceDailySummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceDailySummaryCountAggregateInputType | true
    _avg?: AttendanceDailySummaryAvgAggregateInputType
    _sum?: AttendanceDailySummarySumAggregateInputType
    _min?: AttendanceDailySummaryMinAggregateInputType
    _max?: AttendanceDailySummaryMaxAggregateInputType
  }

  export type AttendanceDailySummaryGroupByOutputType = {
    id: string
    companyId: string
    date: Date
    status: $Enums.AttendanceStatus
    lateMinutes: number | null
    earlyMinutes: number | null
    workedMinutes: number | null
    employeeId: string | null
    studentId: string | null
    workerId: string | null
    validatedByUserId: string | null
    createdAt: Date
    deletedAt: Date | null
    _count: AttendanceDailySummaryCountAggregateOutputType | null
    _avg: AttendanceDailySummaryAvgAggregateOutputType | null
    _sum: AttendanceDailySummarySumAggregateOutputType | null
    _min: AttendanceDailySummaryMinAggregateOutputType | null
    _max: AttendanceDailySummaryMaxAggregateOutputType | null
  }

  type GetAttendanceDailySummaryGroupByPayload<T extends AttendanceDailySummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceDailySummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceDailySummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceDailySummaryGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceDailySummaryGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceDailySummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    date?: boolean
    status?: boolean
    lateMinutes?: boolean
    earlyMinutes?: boolean
    workedMinutes?: boolean
    employeeId?: boolean
    studentId?: boolean
    workerId?: boolean
    validatedByUserId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | AttendanceDailySummary$employeeArgs<ExtArgs>
    student?: boolean | AttendanceDailySummary$studentArgs<ExtArgs>
    worker?: boolean | AttendanceDailySummary$workerArgs<ExtArgs>
    validatedBy?: boolean | AttendanceDailySummary$validatedByArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceDailySummary"]>

  export type AttendanceDailySummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    date?: boolean
    status?: boolean
    lateMinutes?: boolean
    earlyMinutes?: boolean
    workedMinutes?: boolean
    employeeId?: boolean
    studentId?: boolean
    workerId?: boolean
    validatedByUserId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | AttendanceDailySummary$employeeArgs<ExtArgs>
    student?: boolean | AttendanceDailySummary$studentArgs<ExtArgs>
    worker?: boolean | AttendanceDailySummary$workerArgs<ExtArgs>
    validatedBy?: boolean | AttendanceDailySummary$validatedByArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceDailySummary"]>

  export type AttendanceDailySummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    date?: boolean
    status?: boolean
    lateMinutes?: boolean
    earlyMinutes?: boolean
    workedMinutes?: boolean
    employeeId?: boolean
    studentId?: boolean
    workerId?: boolean
    validatedByUserId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | AttendanceDailySummary$employeeArgs<ExtArgs>
    student?: boolean | AttendanceDailySummary$studentArgs<ExtArgs>
    worker?: boolean | AttendanceDailySummary$workerArgs<ExtArgs>
    validatedBy?: boolean | AttendanceDailySummary$validatedByArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceDailySummary"]>

  export type AttendanceDailySummarySelectScalar = {
    id?: boolean
    companyId?: boolean
    date?: boolean
    status?: boolean
    lateMinutes?: boolean
    earlyMinutes?: boolean
    workedMinutes?: boolean
    employeeId?: boolean
    studentId?: boolean
    workerId?: boolean
    validatedByUserId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
  }

  export type AttendanceDailySummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "date" | "status" | "lateMinutes" | "earlyMinutes" | "workedMinutes" | "employeeId" | "studentId" | "workerId" | "validatedByUserId" | "createdAt" | "deletedAt", ExtArgs["result"]["attendanceDailySummary"]>
  export type AttendanceDailySummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | AttendanceDailySummary$employeeArgs<ExtArgs>
    student?: boolean | AttendanceDailySummary$studentArgs<ExtArgs>
    worker?: boolean | AttendanceDailySummary$workerArgs<ExtArgs>
    validatedBy?: boolean | AttendanceDailySummary$validatedByArgs<ExtArgs>
  }
  export type AttendanceDailySummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | AttendanceDailySummary$employeeArgs<ExtArgs>
    student?: boolean | AttendanceDailySummary$studentArgs<ExtArgs>
    worker?: boolean | AttendanceDailySummary$workerArgs<ExtArgs>
    validatedBy?: boolean | AttendanceDailySummary$validatedByArgs<ExtArgs>
  }
  export type AttendanceDailySummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | AttendanceDailySummary$employeeArgs<ExtArgs>
    student?: boolean | AttendanceDailySummary$studentArgs<ExtArgs>
    worker?: boolean | AttendanceDailySummary$workerArgs<ExtArgs>
    validatedBy?: boolean | AttendanceDailySummary$validatedByArgs<ExtArgs>
  }

  export type $AttendanceDailySummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceDailySummary"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
      worker: Prisma.$WorkerPayload<ExtArgs> | null
      validatedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      date: Date
      status: $Enums.AttendanceStatus
      lateMinutes: number | null
      earlyMinutes: number | null
      workedMinutes: number | null
      employeeId: string | null
      studentId: string | null
      workerId: string | null
      validatedByUserId: string | null
      createdAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["attendanceDailySummary"]>
    composites: {}
  }

  type AttendanceDailySummaryGetPayload<S extends boolean | null | undefined | AttendanceDailySummaryDefaultArgs> = $Result.GetResult<Prisma.$AttendanceDailySummaryPayload, S>

  type AttendanceDailySummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceDailySummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceDailySummaryCountAggregateInputType | true
    }

  export interface AttendanceDailySummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceDailySummary'], meta: { name: 'AttendanceDailySummary' } }
    /**
     * Find zero or one AttendanceDailySummary that matches the filter.
     * @param {AttendanceDailySummaryFindUniqueArgs} args - Arguments to find a AttendanceDailySummary
     * @example
     * // Get one AttendanceDailySummary
     * const attendanceDailySummary = await prisma.attendanceDailySummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceDailySummaryFindUniqueArgs>(args: SelectSubset<T, AttendanceDailySummaryFindUniqueArgs<ExtArgs>>): Prisma__AttendanceDailySummaryClient<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceDailySummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceDailySummaryFindUniqueOrThrowArgs} args - Arguments to find a AttendanceDailySummary
     * @example
     * // Get one AttendanceDailySummary
     * const attendanceDailySummary = await prisma.attendanceDailySummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceDailySummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceDailySummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceDailySummaryClient<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceDailySummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailySummaryFindFirstArgs} args - Arguments to find a AttendanceDailySummary
     * @example
     * // Get one AttendanceDailySummary
     * const attendanceDailySummary = await prisma.attendanceDailySummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceDailySummaryFindFirstArgs>(args?: SelectSubset<T, AttendanceDailySummaryFindFirstArgs<ExtArgs>>): Prisma__AttendanceDailySummaryClient<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceDailySummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailySummaryFindFirstOrThrowArgs} args - Arguments to find a AttendanceDailySummary
     * @example
     * // Get one AttendanceDailySummary
     * const attendanceDailySummary = await prisma.attendanceDailySummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceDailySummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceDailySummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceDailySummaryClient<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceDailySummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailySummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceDailySummaries
     * const attendanceDailySummaries = await prisma.attendanceDailySummary.findMany()
     * 
     * // Get first 10 AttendanceDailySummaries
     * const attendanceDailySummaries = await prisma.attendanceDailySummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceDailySummaryWithIdOnly = await prisma.attendanceDailySummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceDailySummaryFindManyArgs>(args?: SelectSubset<T, AttendanceDailySummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceDailySummary.
     * @param {AttendanceDailySummaryCreateArgs} args - Arguments to create a AttendanceDailySummary.
     * @example
     * // Create one AttendanceDailySummary
     * const AttendanceDailySummary = await prisma.attendanceDailySummary.create({
     *   data: {
     *     // ... data to create a AttendanceDailySummary
     *   }
     * })
     * 
     */
    create<T extends AttendanceDailySummaryCreateArgs>(args: SelectSubset<T, AttendanceDailySummaryCreateArgs<ExtArgs>>): Prisma__AttendanceDailySummaryClient<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceDailySummaries.
     * @param {AttendanceDailySummaryCreateManyArgs} args - Arguments to create many AttendanceDailySummaries.
     * @example
     * // Create many AttendanceDailySummaries
     * const attendanceDailySummary = await prisma.attendanceDailySummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceDailySummaryCreateManyArgs>(args?: SelectSubset<T, AttendanceDailySummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceDailySummaries and returns the data saved in the database.
     * @param {AttendanceDailySummaryCreateManyAndReturnArgs} args - Arguments to create many AttendanceDailySummaries.
     * @example
     * // Create many AttendanceDailySummaries
     * const attendanceDailySummary = await prisma.attendanceDailySummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceDailySummaries and only return the `id`
     * const attendanceDailySummaryWithIdOnly = await prisma.attendanceDailySummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceDailySummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceDailySummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceDailySummary.
     * @param {AttendanceDailySummaryDeleteArgs} args - Arguments to delete one AttendanceDailySummary.
     * @example
     * // Delete one AttendanceDailySummary
     * const AttendanceDailySummary = await prisma.attendanceDailySummary.delete({
     *   where: {
     *     // ... filter to delete one AttendanceDailySummary
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDailySummaryDeleteArgs>(args: SelectSubset<T, AttendanceDailySummaryDeleteArgs<ExtArgs>>): Prisma__AttendanceDailySummaryClient<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceDailySummary.
     * @param {AttendanceDailySummaryUpdateArgs} args - Arguments to update one AttendanceDailySummary.
     * @example
     * // Update one AttendanceDailySummary
     * const attendanceDailySummary = await prisma.attendanceDailySummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceDailySummaryUpdateArgs>(args: SelectSubset<T, AttendanceDailySummaryUpdateArgs<ExtArgs>>): Prisma__AttendanceDailySummaryClient<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceDailySummaries.
     * @param {AttendanceDailySummaryDeleteManyArgs} args - Arguments to filter AttendanceDailySummaries to delete.
     * @example
     * // Delete a few AttendanceDailySummaries
     * const { count } = await prisma.attendanceDailySummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDailySummaryDeleteManyArgs>(args?: SelectSubset<T, AttendanceDailySummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceDailySummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailySummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceDailySummaries
     * const attendanceDailySummary = await prisma.attendanceDailySummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceDailySummaryUpdateManyArgs>(args: SelectSubset<T, AttendanceDailySummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceDailySummaries and returns the data updated in the database.
     * @param {AttendanceDailySummaryUpdateManyAndReturnArgs} args - Arguments to update many AttendanceDailySummaries.
     * @example
     * // Update many AttendanceDailySummaries
     * const attendanceDailySummary = await prisma.attendanceDailySummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceDailySummaries and only return the `id`
     * const attendanceDailySummaryWithIdOnly = await prisma.attendanceDailySummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceDailySummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceDailySummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceDailySummary.
     * @param {AttendanceDailySummaryUpsertArgs} args - Arguments to update or create a AttendanceDailySummary.
     * @example
     * // Update or create a AttendanceDailySummary
     * const attendanceDailySummary = await prisma.attendanceDailySummary.upsert({
     *   create: {
     *     // ... data to create a AttendanceDailySummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceDailySummary we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceDailySummaryUpsertArgs>(args: SelectSubset<T, AttendanceDailySummaryUpsertArgs<ExtArgs>>): Prisma__AttendanceDailySummaryClient<$Result.GetResult<Prisma.$AttendanceDailySummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceDailySummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailySummaryCountArgs} args - Arguments to filter AttendanceDailySummaries to count.
     * @example
     * // Count the number of AttendanceDailySummaries
     * const count = await prisma.attendanceDailySummary.count({
     *   where: {
     *     // ... the filter for the AttendanceDailySummaries we want to count
     *   }
     * })
    **/
    count<T extends AttendanceDailySummaryCountArgs>(
      args?: Subset<T, AttendanceDailySummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceDailySummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceDailySummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailySummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceDailySummaryAggregateArgs>(args: Subset<T, AttendanceDailySummaryAggregateArgs>): Prisma.PrismaPromise<GetAttendanceDailySummaryAggregateType<T>>

    /**
     * Group by AttendanceDailySummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailySummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceDailySummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceDailySummaryGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceDailySummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceDailySummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceDailySummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceDailySummary model
   */
  readonly fields: AttendanceDailySummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceDailySummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceDailySummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends AttendanceDailySummary$employeeArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceDailySummary$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends AttendanceDailySummary$studentArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceDailySummary$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    worker<T extends AttendanceDailySummary$workerArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceDailySummary$workerArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    validatedBy<T extends AttendanceDailySummary$validatedByArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceDailySummary$validatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceDailySummary model
   */
  interface AttendanceDailySummaryFieldRefs {
    readonly id: FieldRef<"AttendanceDailySummary", 'String'>
    readonly companyId: FieldRef<"AttendanceDailySummary", 'String'>
    readonly date: FieldRef<"AttendanceDailySummary", 'DateTime'>
    readonly status: FieldRef<"AttendanceDailySummary", 'AttendanceStatus'>
    readonly lateMinutes: FieldRef<"AttendanceDailySummary", 'Int'>
    readonly earlyMinutes: FieldRef<"AttendanceDailySummary", 'Int'>
    readonly workedMinutes: FieldRef<"AttendanceDailySummary", 'Int'>
    readonly employeeId: FieldRef<"AttendanceDailySummary", 'String'>
    readonly studentId: FieldRef<"AttendanceDailySummary", 'String'>
    readonly workerId: FieldRef<"AttendanceDailySummary", 'String'>
    readonly validatedByUserId: FieldRef<"AttendanceDailySummary", 'String'>
    readonly createdAt: FieldRef<"AttendanceDailySummary", 'DateTime'>
    readonly deletedAt: FieldRef<"AttendanceDailySummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceDailySummary findUnique
   */
  export type AttendanceDailySummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDailySummary to fetch.
     */
    where: AttendanceDailySummaryWhereUniqueInput
  }

  /**
   * AttendanceDailySummary findUniqueOrThrow
   */
  export type AttendanceDailySummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDailySummary to fetch.
     */
    where: AttendanceDailySummaryWhereUniqueInput
  }

  /**
   * AttendanceDailySummary findFirst
   */
  export type AttendanceDailySummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDailySummary to fetch.
     */
    where?: AttendanceDailySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDailySummaries to fetch.
     */
    orderBy?: AttendanceDailySummaryOrderByWithRelationInput | AttendanceDailySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceDailySummaries.
     */
    cursor?: AttendanceDailySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDailySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDailySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceDailySummaries.
     */
    distinct?: AttendanceDailySummaryScalarFieldEnum | AttendanceDailySummaryScalarFieldEnum[]
  }

  /**
   * AttendanceDailySummary findFirstOrThrow
   */
  export type AttendanceDailySummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDailySummary to fetch.
     */
    where?: AttendanceDailySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDailySummaries to fetch.
     */
    orderBy?: AttendanceDailySummaryOrderByWithRelationInput | AttendanceDailySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceDailySummaries.
     */
    cursor?: AttendanceDailySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDailySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDailySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceDailySummaries.
     */
    distinct?: AttendanceDailySummaryScalarFieldEnum | AttendanceDailySummaryScalarFieldEnum[]
  }

  /**
   * AttendanceDailySummary findMany
   */
  export type AttendanceDailySummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDailySummaries to fetch.
     */
    where?: AttendanceDailySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDailySummaries to fetch.
     */
    orderBy?: AttendanceDailySummaryOrderByWithRelationInput | AttendanceDailySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceDailySummaries.
     */
    cursor?: AttendanceDailySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDailySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDailySummaries.
     */
    skip?: number
    distinct?: AttendanceDailySummaryScalarFieldEnum | AttendanceDailySummaryScalarFieldEnum[]
  }

  /**
   * AttendanceDailySummary create
   */
  export type AttendanceDailySummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceDailySummary.
     */
    data: XOR<AttendanceDailySummaryCreateInput, AttendanceDailySummaryUncheckedCreateInput>
  }

  /**
   * AttendanceDailySummary createMany
   */
  export type AttendanceDailySummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceDailySummaries.
     */
    data: AttendanceDailySummaryCreateManyInput | AttendanceDailySummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceDailySummary createManyAndReturn
   */
  export type AttendanceDailySummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceDailySummaries.
     */
    data: AttendanceDailySummaryCreateManyInput | AttendanceDailySummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceDailySummary update
   */
  export type AttendanceDailySummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceDailySummary.
     */
    data: XOR<AttendanceDailySummaryUpdateInput, AttendanceDailySummaryUncheckedUpdateInput>
    /**
     * Choose, which AttendanceDailySummary to update.
     */
    where: AttendanceDailySummaryWhereUniqueInput
  }

  /**
   * AttendanceDailySummary updateMany
   */
  export type AttendanceDailySummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceDailySummaries.
     */
    data: XOR<AttendanceDailySummaryUpdateManyMutationInput, AttendanceDailySummaryUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceDailySummaries to update
     */
    where?: AttendanceDailySummaryWhereInput
    /**
     * Limit how many AttendanceDailySummaries to update.
     */
    limit?: number
  }

  /**
   * AttendanceDailySummary updateManyAndReturn
   */
  export type AttendanceDailySummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceDailySummaries.
     */
    data: XOR<AttendanceDailySummaryUpdateManyMutationInput, AttendanceDailySummaryUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceDailySummaries to update
     */
    where?: AttendanceDailySummaryWhereInput
    /**
     * Limit how many AttendanceDailySummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceDailySummary upsert
   */
  export type AttendanceDailySummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceDailySummary to update in case it exists.
     */
    where: AttendanceDailySummaryWhereUniqueInput
    /**
     * In case the AttendanceDailySummary found by the `where` argument doesn't exist, create a new AttendanceDailySummary with this data.
     */
    create: XOR<AttendanceDailySummaryCreateInput, AttendanceDailySummaryUncheckedCreateInput>
    /**
     * In case the AttendanceDailySummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceDailySummaryUpdateInput, AttendanceDailySummaryUncheckedUpdateInput>
  }

  /**
   * AttendanceDailySummary delete
   */
  export type AttendanceDailySummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
    /**
     * Filter which AttendanceDailySummary to delete.
     */
    where: AttendanceDailySummaryWhereUniqueInput
  }

  /**
   * AttendanceDailySummary deleteMany
   */
  export type AttendanceDailySummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceDailySummaries to delete
     */
    where?: AttendanceDailySummaryWhereInput
    /**
     * Limit how many AttendanceDailySummaries to delete.
     */
    limit?: number
  }

  /**
   * AttendanceDailySummary.employee
   */
  export type AttendanceDailySummary$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * AttendanceDailySummary.student
   */
  export type AttendanceDailySummary$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * AttendanceDailySummary.worker
   */
  export type AttendanceDailySummary$workerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
  }

  /**
   * AttendanceDailySummary.validatedBy
   */
  export type AttendanceDailySummary$validatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AttendanceDailySummary without action
   */
  export type AttendanceDailySummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDailySummary
     */
    select?: AttendanceDailySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceDailySummary
     */
    omit?: AttendanceDailySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailySummaryInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    platform: string | null
    model: string | null
    personId: string | null
    companyId: string | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    platform: string | null
    model: string | null
    personId: string | null
    companyId: string | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    uuid: number
    platform: number
    model: number
    personId: number
    companyId: number
    deletedAt: number
    createdAt: number
    _all: number
  }


  export type DeviceMinAggregateInputType = {
    id?: true
    uuid?: true
    platform?: true
    model?: true
    personId?: true
    companyId?: true
    deletedAt?: true
    createdAt?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    uuid?: true
    platform?: true
    model?: true
    personId?: true
    companyId?: true
    deletedAt?: true
    createdAt?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    uuid?: true
    platform?: true
    model?: true
    personId?: true
    companyId?: true
    deletedAt?: true
    createdAt?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: string
    uuid: string
    platform: string
    model: string
    personId: string
    companyId: string
    deletedAt: Date | null
    createdAt: Date
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    platform?: boolean
    model?: boolean
    personId?: boolean
    companyId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    attendanceEvents?: boolean | Device$attendanceEventsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    platform?: boolean
    model?: boolean
    personId?: boolean
    companyId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    platform?: boolean
    model?: boolean
    personId?: boolean
    companyId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    person?: boolean | PersonDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectScalar = {
    id?: boolean
    uuid?: boolean
    platform?: boolean
    model?: boolean
    personId?: boolean
    companyId?: boolean
    deletedAt?: boolean
    createdAt?: boolean
  }

  export type DeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "platform" | "model" | "personId" | "companyId" | "deletedAt" | "createdAt", ExtArgs["result"]["device"]>
  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    attendanceEvents?: boolean | Device$attendanceEventsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | DeviceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    person?: boolean | PersonDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      person: Prisma.$PersonPayload<ExtArgs>
      attendanceEvents: Prisma.$AttendanceEventPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      platform: string
      model: string
      personId: string
      companyId: string
      deletedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {DeviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices and returns the data updated in the database.
     * @param {DeviceUpdateManyAndReturnArgs} args - Arguments to update many Devices.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendanceEvents<T extends Device$attendanceEventsArgs<ExtArgs> = {}>(args?: Subset<T, Device$attendanceEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'String'>
    readonly uuid: FieldRef<"Device", 'String'>
    readonly platform: FieldRef<"Device", 'String'>
    readonly model: FieldRef<"Device", 'String'>
    readonly personId: FieldRef<"Device", 'String'>
    readonly companyId: FieldRef<"Device", 'String'>
    readonly deletedAt: FieldRef<"Device", 'DateTime'>
    readonly createdAt: FieldRef<"Device", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device createManyAndReturn
   */
  export type DeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
  }

  /**
   * Device updateManyAndReturn
   */
  export type DeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to delete.
     */
    limit?: number
  }

  /**
   * Device.attendanceEvents
   */
  export type Device$attendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    where?: AttendanceEventWhereInput
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    cursor?: AttendanceEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model LeaveType
   */

  export type AggregateLeaveType = {
    _count: LeaveTypeCountAggregateOutputType | null
    _avg: LeaveTypeAvgAggregateOutputType | null
    _sum: LeaveTypeSumAggregateOutputType | null
    _min: LeaveTypeMinAggregateOutputType | null
    _max: LeaveTypeMaxAggregateOutputType | null
  }

  export type LeaveTypeAvgAggregateOutputType = {
    maxDaysYear: number | null
  }

  export type LeaveTypeSumAggregateOutputType = {
    maxDaysYear: number | null
  }

  export type LeaveTypeMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    code: string | null
    isPaid: boolean | null
    maxDaysYear: number | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type LeaveTypeMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    code: string | null
    isPaid: boolean | null
    maxDaysYear: number | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type LeaveTypeCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    code: number
    isPaid: number
    maxDaysYear: number
    createdAt: number
    deletedAt: number
    _all: number
  }


  export type LeaveTypeAvgAggregateInputType = {
    maxDaysYear?: true
  }

  export type LeaveTypeSumAggregateInputType = {
    maxDaysYear?: true
  }

  export type LeaveTypeMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    code?: true
    isPaid?: true
    maxDaysYear?: true
    createdAt?: true
    deletedAt?: true
  }

  export type LeaveTypeMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    code?: true
    isPaid?: true
    maxDaysYear?: true
    createdAt?: true
    deletedAt?: true
  }

  export type LeaveTypeCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    code?: true
    isPaid?: true
    maxDaysYear?: true
    createdAt?: true
    deletedAt?: true
    _all?: true
  }

  export type LeaveTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveType to aggregate.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveTypes
    **/
    _count?: true | LeaveTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveTypeMaxAggregateInputType
  }

  export type GetLeaveTypeAggregateType<T extends LeaveTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveType[P]>
      : GetScalarType<T[P], AggregateLeaveType[P]>
  }




  export type LeaveTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveTypeWhereInput
    orderBy?: LeaveTypeOrderByWithAggregationInput | LeaveTypeOrderByWithAggregationInput[]
    by: LeaveTypeScalarFieldEnum[] | LeaveTypeScalarFieldEnum
    having?: LeaveTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveTypeCountAggregateInputType | true
    _avg?: LeaveTypeAvgAggregateInputType
    _sum?: LeaveTypeSumAggregateInputType
    _min?: LeaveTypeMinAggregateInputType
    _max?: LeaveTypeMaxAggregateInputType
  }

  export type LeaveTypeGroupByOutputType = {
    id: string
    companyId: string
    name: string
    code: string
    isPaid: boolean
    maxDaysYear: number | null
    createdAt: Date
    deletedAt: Date | null
    _count: LeaveTypeCountAggregateOutputType | null
    _avg: LeaveTypeAvgAggregateOutputType | null
    _sum: LeaveTypeSumAggregateOutputType | null
    _min: LeaveTypeMinAggregateOutputType | null
    _max: LeaveTypeMaxAggregateOutputType | null
  }

  type GetLeaveTypeGroupByPayload<T extends LeaveTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveTypeGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveTypeGroupByOutputType[P]>
        }
      >
    >


  export type LeaveTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    code?: boolean
    isPaid?: boolean
    maxDaysYear?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    balances?: boolean | LeaveType$balancesArgs<ExtArgs>
    requests?: boolean | LeaveType$requestsArgs<ExtArgs>
    _count?: boolean | LeaveTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveType"]>

  export type LeaveTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    code?: boolean
    isPaid?: boolean
    maxDaysYear?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveType"]>

  export type LeaveTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    code?: boolean
    isPaid?: boolean
    maxDaysYear?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveType"]>

  export type LeaveTypeSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    code?: boolean
    isPaid?: boolean
    maxDaysYear?: boolean
    createdAt?: boolean
    deletedAt?: boolean
  }

  export type LeaveTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "name" | "code" | "isPaid" | "maxDaysYear" | "createdAt" | "deletedAt", ExtArgs["result"]["leaveType"]>
  export type LeaveTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    balances?: boolean | LeaveType$balancesArgs<ExtArgs>
    requests?: boolean | LeaveType$requestsArgs<ExtArgs>
    _count?: boolean | LeaveTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeaveTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type LeaveTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $LeaveTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveType"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      balances: Prisma.$LeaveBalancePayload<ExtArgs>[]
      requests: Prisma.$LeaveRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      code: string
      isPaid: boolean
      maxDaysYear: number | null
      createdAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["leaveType"]>
    composites: {}
  }

  type LeaveTypeGetPayload<S extends boolean | null | undefined | LeaveTypeDefaultArgs> = $Result.GetResult<Prisma.$LeaveTypePayload, S>

  type LeaveTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveTypeCountAggregateInputType | true
    }

  export interface LeaveTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveType'], meta: { name: 'LeaveType' } }
    /**
     * Find zero or one LeaveType that matches the filter.
     * @param {LeaveTypeFindUniqueArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveTypeFindUniqueArgs>(args: SelectSubset<T, LeaveTypeFindUniqueArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaveType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveTypeFindUniqueOrThrowArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindFirstArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveTypeFindFirstArgs>(args?: SelectSubset<T, LeaveTypeFindFirstArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindFirstOrThrowArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaveTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveTypes
     * const leaveTypes = await prisma.leaveType.findMany()
     * 
     * // Get first 10 LeaveTypes
     * const leaveTypes = await prisma.leaveType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveTypeWithIdOnly = await prisma.leaveType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveTypeFindManyArgs>(args?: SelectSubset<T, LeaveTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaveType.
     * @param {LeaveTypeCreateArgs} args - Arguments to create a LeaveType.
     * @example
     * // Create one LeaveType
     * const LeaveType = await prisma.leaveType.create({
     *   data: {
     *     // ... data to create a LeaveType
     *   }
     * })
     * 
     */
    create<T extends LeaveTypeCreateArgs>(args: SelectSubset<T, LeaveTypeCreateArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaveTypes.
     * @param {LeaveTypeCreateManyArgs} args - Arguments to create many LeaveTypes.
     * @example
     * // Create many LeaveTypes
     * const leaveType = await prisma.leaveType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveTypeCreateManyArgs>(args?: SelectSubset<T, LeaveTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveTypes and returns the data saved in the database.
     * @param {LeaveTypeCreateManyAndReturnArgs} args - Arguments to create many LeaveTypes.
     * @example
     * // Create many LeaveTypes
     * const leaveType = await prisma.leaveType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveTypes and only return the `id`
     * const leaveTypeWithIdOnly = await prisma.leaveType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaveType.
     * @param {LeaveTypeDeleteArgs} args - Arguments to delete one LeaveType.
     * @example
     * // Delete one LeaveType
     * const LeaveType = await prisma.leaveType.delete({
     *   where: {
     *     // ... filter to delete one LeaveType
     *   }
     * })
     * 
     */
    delete<T extends LeaveTypeDeleteArgs>(args: SelectSubset<T, LeaveTypeDeleteArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaveType.
     * @param {LeaveTypeUpdateArgs} args - Arguments to update one LeaveType.
     * @example
     * // Update one LeaveType
     * const leaveType = await prisma.leaveType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveTypeUpdateArgs>(args: SelectSubset<T, LeaveTypeUpdateArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaveTypes.
     * @param {LeaveTypeDeleteManyArgs} args - Arguments to filter LeaveTypes to delete.
     * @example
     * // Delete a few LeaveTypes
     * const { count } = await prisma.leaveType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveTypeDeleteManyArgs>(args?: SelectSubset<T, LeaveTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveTypes
     * const leaveType = await prisma.leaveType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveTypeUpdateManyArgs>(args: SelectSubset<T, LeaveTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveTypes and returns the data updated in the database.
     * @param {LeaveTypeUpdateManyAndReturnArgs} args - Arguments to update many LeaveTypes.
     * @example
     * // Update many LeaveTypes
     * const leaveType = await prisma.leaveType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaveTypes and only return the `id`
     * const leaveTypeWithIdOnly = await prisma.leaveType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaveType.
     * @param {LeaveTypeUpsertArgs} args - Arguments to update or create a LeaveType.
     * @example
     * // Update or create a LeaveType
     * const leaveType = await prisma.leaveType.upsert({
     *   create: {
     *     // ... data to create a LeaveType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveType we want to update
     *   }
     * })
     */
    upsert<T extends LeaveTypeUpsertArgs>(args: SelectSubset<T, LeaveTypeUpsertArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaveTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeCountArgs} args - Arguments to filter LeaveTypes to count.
     * @example
     * // Count the number of LeaveTypes
     * const count = await prisma.leaveType.count({
     *   where: {
     *     // ... the filter for the LeaveTypes we want to count
     *   }
     * })
    **/
    count<T extends LeaveTypeCountArgs>(
      args?: Subset<T, LeaveTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveTypeAggregateArgs>(args: Subset<T, LeaveTypeAggregateArgs>): Prisma.PrismaPromise<GetLeaveTypeAggregateType<T>>

    /**
     * Group by LeaveType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveTypeGroupByArgs['orderBy'] }
        : { orderBy?: LeaveTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveType model
   */
  readonly fields: LeaveTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    balances<T extends LeaveType$balancesArgs<ExtArgs> = {}>(args?: Subset<T, LeaveType$balancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requests<T extends LeaveType$requestsArgs<ExtArgs> = {}>(args?: Subset<T, LeaveType$requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveType model
   */
  interface LeaveTypeFieldRefs {
    readonly id: FieldRef<"LeaveType", 'String'>
    readonly companyId: FieldRef<"LeaveType", 'String'>
    readonly name: FieldRef<"LeaveType", 'String'>
    readonly code: FieldRef<"LeaveType", 'String'>
    readonly isPaid: FieldRef<"LeaveType", 'Boolean'>
    readonly maxDaysYear: FieldRef<"LeaveType", 'Int'>
    readonly createdAt: FieldRef<"LeaveType", 'DateTime'>
    readonly deletedAt: FieldRef<"LeaveType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveType findUnique
   */
  export type LeaveTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType findUniqueOrThrow
   */
  export type LeaveTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType findFirst
   */
  export type LeaveTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveTypes.
     */
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * LeaveType findFirstOrThrow
   */
  export type LeaveTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveTypes.
     */
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * LeaveType findMany
   */
  export type LeaveTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveTypes to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * LeaveType create
   */
  export type LeaveTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveType.
     */
    data: XOR<LeaveTypeCreateInput, LeaveTypeUncheckedCreateInput>
  }

  /**
   * LeaveType createMany
   */
  export type LeaveTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveTypes.
     */
    data: LeaveTypeCreateManyInput | LeaveTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveType createManyAndReturn
   */
  export type LeaveTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * The data used to create many LeaveTypes.
     */
    data: LeaveTypeCreateManyInput | LeaveTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveType update
   */
  export type LeaveTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveType.
     */
    data: XOR<LeaveTypeUpdateInput, LeaveTypeUncheckedUpdateInput>
    /**
     * Choose, which LeaveType to update.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType updateMany
   */
  export type LeaveTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveTypes.
     */
    data: XOR<LeaveTypeUpdateManyMutationInput, LeaveTypeUncheckedUpdateManyInput>
    /**
     * Filter which LeaveTypes to update
     */
    where?: LeaveTypeWhereInput
    /**
     * Limit how many LeaveTypes to update.
     */
    limit?: number
  }

  /**
   * LeaveType updateManyAndReturn
   */
  export type LeaveTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * The data used to update LeaveTypes.
     */
    data: XOR<LeaveTypeUpdateManyMutationInput, LeaveTypeUncheckedUpdateManyInput>
    /**
     * Filter which LeaveTypes to update
     */
    where?: LeaveTypeWhereInput
    /**
     * Limit how many LeaveTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveType upsert
   */
  export type LeaveTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveType to update in case it exists.
     */
    where: LeaveTypeWhereUniqueInput
    /**
     * In case the LeaveType found by the `where` argument doesn't exist, create a new LeaveType with this data.
     */
    create: XOR<LeaveTypeCreateInput, LeaveTypeUncheckedCreateInput>
    /**
     * In case the LeaveType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveTypeUpdateInput, LeaveTypeUncheckedUpdateInput>
  }

  /**
   * LeaveType delete
   */
  export type LeaveTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter which LeaveType to delete.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType deleteMany
   */
  export type LeaveTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveTypes to delete
     */
    where?: LeaveTypeWhereInput
    /**
     * Limit how many LeaveTypes to delete.
     */
    limit?: number
  }

  /**
   * LeaveType.balances
   */
  export type LeaveType$balancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    where?: LeaveBalanceWhereInput
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    cursor?: LeaveBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * LeaveType.requests
   */
  export type LeaveType$requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveType without action
   */
  export type LeaveTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
  }


  /**
   * Model LeaveBalance
   */

  export type AggregateLeaveBalance = {
    _count: LeaveBalanceCountAggregateOutputType | null
    _avg: LeaveBalanceAvgAggregateOutputType | null
    _sum: LeaveBalanceSumAggregateOutputType | null
    _min: LeaveBalanceMinAggregateOutputType | null
    _max: LeaveBalanceMaxAggregateOutputType | null
  }

  export type LeaveBalanceAvgAggregateOutputType = {
    year: number | null
    totalDays: number | null
    usedDays: number | null
  }

  export type LeaveBalanceSumAggregateOutputType = {
    year: number | null
    totalDays: number | null
    usedDays: number | null
  }

  export type LeaveBalanceMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    employeeId: string | null
    leaveTypeId: string | null
    year: number | null
    totalDays: number | null
    usedDays: number | null
    deletedAt: Date | null
  }

  export type LeaveBalanceMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    employeeId: string | null
    leaveTypeId: string | null
    year: number | null
    totalDays: number | null
    usedDays: number | null
    deletedAt: Date | null
  }

  export type LeaveBalanceCountAggregateOutputType = {
    id: number
    companyId: number
    employeeId: number
    leaveTypeId: number
    year: number
    totalDays: number
    usedDays: number
    deletedAt: number
    _all: number
  }


  export type LeaveBalanceAvgAggregateInputType = {
    year?: true
    totalDays?: true
    usedDays?: true
  }

  export type LeaveBalanceSumAggregateInputType = {
    year?: true
    totalDays?: true
    usedDays?: true
  }

  export type LeaveBalanceMinAggregateInputType = {
    id?: true
    companyId?: true
    employeeId?: true
    leaveTypeId?: true
    year?: true
    totalDays?: true
    usedDays?: true
    deletedAt?: true
  }

  export type LeaveBalanceMaxAggregateInputType = {
    id?: true
    companyId?: true
    employeeId?: true
    leaveTypeId?: true
    year?: true
    totalDays?: true
    usedDays?: true
    deletedAt?: true
  }

  export type LeaveBalanceCountAggregateInputType = {
    id?: true
    companyId?: true
    employeeId?: true
    leaveTypeId?: true
    year?: true
    totalDays?: true
    usedDays?: true
    deletedAt?: true
    _all?: true
  }

  export type LeaveBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveBalance to aggregate.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveBalances
    **/
    _count?: true | LeaveBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveBalanceMaxAggregateInputType
  }

  export type GetLeaveBalanceAggregateType<T extends LeaveBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveBalance[P]>
      : GetScalarType<T[P], AggregateLeaveBalance[P]>
  }




  export type LeaveBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveBalanceWhereInput
    orderBy?: LeaveBalanceOrderByWithAggregationInput | LeaveBalanceOrderByWithAggregationInput[]
    by: LeaveBalanceScalarFieldEnum[] | LeaveBalanceScalarFieldEnum
    having?: LeaveBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveBalanceCountAggregateInputType | true
    _avg?: LeaveBalanceAvgAggregateInputType
    _sum?: LeaveBalanceSumAggregateInputType
    _min?: LeaveBalanceMinAggregateInputType
    _max?: LeaveBalanceMaxAggregateInputType
  }

  export type LeaveBalanceGroupByOutputType = {
    id: string
    companyId: string
    employeeId: string
    leaveTypeId: string
    year: number
    totalDays: number
    usedDays: number
    deletedAt: Date | null
    _count: LeaveBalanceCountAggregateOutputType | null
    _avg: LeaveBalanceAvgAggregateOutputType | null
    _sum: LeaveBalanceSumAggregateOutputType | null
    _min: LeaveBalanceMinAggregateOutputType | null
    _max: LeaveBalanceMaxAggregateOutputType | null
  }

  type GetLeaveBalanceGroupByPayload<T extends LeaveBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveBalanceGroupByOutputType[P]>
        }
      >
    >


  export type LeaveBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    year?: boolean
    totalDays?: boolean
    usedDays?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveBalance"]>

  export type LeaveBalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    year?: boolean
    totalDays?: boolean
    usedDays?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveBalance"]>

  export type LeaveBalanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    year?: boolean
    totalDays?: boolean
    usedDays?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveBalance"]>

  export type LeaveBalanceSelectScalar = {
    id?: boolean
    companyId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    year?: boolean
    totalDays?: boolean
    usedDays?: boolean
    deletedAt?: boolean
  }

  export type LeaveBalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "employeeId" | "leaveTypeId" | "year" | "totalDays" | "usedDays" | "deletedAt", ExtArgs["result"]["leaveBalance"]>
  export type LeaveBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }
  export type LeaveBalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }
  export type LeaveBalanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }

  export type $LeaveBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveBalance"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
      leaveType: Prisma.$LeaveTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      employeeId: string
      leaveTypeId: string
      year: number
      totalDays: number
      usedDays: number
      deletedAt: Date | null
    }, ExtArgs["result"]["leaveBalance"]>
    composites: {}
  }

  type LeaveBalanceGetPayload<S extends boolean | null | undefined | LeaveBalanceDefaultArgs> = $Result.GetResult<Prisma.$LeaveBalancePayload, S>

  type LeaveBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveBalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveBalanceCountAggregateInputType | true
    }

  export interface LeaveBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveBalance'], meta: { name: 'LeaveBalance' } }
    /**
     * Find zero or one LeaveBalance that matches the filter.
     * @param {LeaveBalanceFindUniqueArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveBalanceFindUniqueArgs>(args: SelectSubset<T, LeaveBalanceFindUniqueArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaveBalance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveBalanceFindUniqueOrThrowArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceFindFirstArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveBalanceFindFirstArgs>(args?: SelectSubset<T, LeaveBalanceFindFirstArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceFindFirstOrThrowArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaveBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveBalances
     * const leaveBalances = await prisma.leaveBalance.findMany()
     * 
     * // Get first 10 LeaveBalances
     * const leaveBalances = await prisma.leaveBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveBalanceWithIdOnly = await prisma.leaveBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveBalanceFindManyArgs>(args?: SelectSubset<T, LeaveBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaveBalance.
     * @param {LeaveBalanceCreateArgs} args - Arguments to create a LeaveBalance.
     * @example
     * // Create one LeaveBalance
     * const LeaveBalance = await prisma.leaveBalance.create({
     *   data: {
     *     // ... data to create a LeaveBalance
     *   }
     * })
     * 
     */
    create<T extends LeaveBalanceCreateArgs>(args: SelectSubset<T, LeaveBalanceCreateArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaveBalances.
     * @param {LeaveBalanceCreateManyArgs} args - Arguments to create many LeaveBalances.
     * @example
     * // Create many LeaveBalances
     * const leaveBalance = await prisma.leaveBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveBalanceCreateManyArgs>(args?: SelectSubset<T, LeaveBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveBalances and returns the data saved in the database.
     * @param {LeaveBalanceCreateManyAndReturnArgs} args - Arguments to create many LeaveBalances.
     * @example
     * // Create many LeaveBalances
     * const leaveBalance = await prisma.leaveBalance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveBalances and only return the `id`
     * const leaveBalanceWithIdOnly = await prisma.leaveBalance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveBalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveBalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaveBalance.
     * @param {LeaveBalanceDeleteArgs} args - Arguments to delete one LeaveBalance.
     * @example
     * // Delete one LeaveBalance
     * const LeaveBalance = await prisma.leaveBalance.delete({
     *   where: {
     *     // ... filter to delete one LeaveBalance
     *   }
     * })
     * 
     */
    delete<T extends LeaveBalanceDeleteArgs>(args: SelectSubset<T, LeaveBalanceDeleteArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaveBalance.
     * @param {LeaveBalanceUpdateArgs} args - Arguments to update one LeaveBalance.
     * @example
     * // Update one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveBalanceUpdateArgs>(args: SelectSubset<T, LeaveBalanceUpdateArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaveBalances.
     * @param {LeaveBalanceDeleteManyArgs} args - Arguments to filter LeaveBalances to delete.
     * @example
     * // Delete a few LeaveBalances
     * const { count } = await prisma.leaveBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveBalanceDeleteManyArgs>(args?: SelectSubset<T, LeaveBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveBalances
     * const leaveBalance = await prisma.leaveBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveBalanceUpdateManyArgs>(args: SelectSubset<T, LeaveBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveBalances and returns the data updated in the database.
     * @param {LeaveBalanceUpdateManyAndReturnArgs} args - Arguments to update many LeaveBalances.
     * @example
     * // Update many LeaveBalances
     * const leaveBalance = await prisma.leaveBalance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaveBalances and only return the `id`
     * const leaveBalanceWithIdOnly = await prisma.leaveBalance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveBalanceUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveBalanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaveBalance.
     * @param {LeaveBalanceUpsertArgs} args - Arguments to update or create a LeaveBalance.
     * @example
     * // Update or create a LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.upsert({
     *   create: {
     *     // ... data to create a LeaveBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveBalance we want to update
     *   }
     * })
     */
    upsert<T extends LeaveBalanceUpsertArgs>(args: SelectSubset<T, LeaveBalanceUpsertArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaveBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceCountArgs} args - Arguments to filter LeaveBalances to count.
     * @example
     * // Count the number of LeaveBalances
     * const count = await prisma.leaveBalance.count({
     *   where: {
     *     // ... the filter for the LeaveBalances we want to count
     *   }
     * })
    **/
    count<T extends LeaveBalanceCountArgs>(
      args?: Subset<T, LeaveBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveBalanceAggregateArgs>(args: Subset<T, LeaveBalanceAggregateArgs>): Prisma.PrismaPromise<GetLeaveBalanceAggregateType<T>>

    /**
     * Group by LeaveBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveBalanceGroupByArgs['orderBy'] }
        : { orderBy?: LeaveBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveBalance model
   */
  readonly fields: LeaveBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leaveType<T extends LeaveTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaveTypeDefaultArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveBalance model
   */
  interface LeaveBalanceFieldRefs {
    readonly id: FieldRef<"LeaveBalance", 'String'>
    readonly companyId: FieldRef<"LeaveBalance", 'String'>
    readonly employeeId: FieldRef<"LeaveBalance", 'String'>
    readonly leaveTypeId: FieldRef<"LeaveBalance", 'String'>
    readonly year: FieldRef<"LeaveBalance", 'Int'>
    readonly totalDays: FieldRef<"LeaveBalance", 'Int'>
    readonly usedDays: FieldRef<"LeaveBalance", 'Int'>
    readonly deletedAt: FieldRef<"LeaveBalance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveBalance findUnique
   */
  export type LeaveBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where: LeaveBalanceWhereUniqueInput
  }

  /**
   * LeaveBalance findUniqueOrThrow
   */
  export type LeaveBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where: LeaveBalanceWhereUniqueInput
  }

  /**
   * LeaveBalance findFirst
   */
  export type LeaveBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveBalances.
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveBalances.
     */
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * LeaveBalance findFirstOrThrow
   */
  export type LeaveBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveBalances.
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveBalances.
     */
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * LeaveBalance findMany
   */
  export type LeaveBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalances to fetch.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveBalances.
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * LeaveBalance create
   */
  export type LeaveBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveBalance.
     */
    data: XOR<LeaveBalanceCreateInput, LeaveBalanceUncheckedCreateInput>
  }

  /**
   * LeaveBalance createMany
   */
  export type LeaveBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveBalances.
     */
    data: LeaveBalanceCreateManyInput | LeaveBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveBalance createManyAndReturn
   */
  export type LeaveBalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * The data used to create many LeaveBalances.
     */
    data: LeaveBalanceCreateManyInput | LeaveBalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveBalance update
   */
  export type LeaveBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveBalance.
     */
    data: XOR<LeaveBalanceUpdateInput, LeaveBalanceUncheckedUpdateInput>
    /**
     * Choose, which LeaveBalance to update.
     */
    where: LeaveBalanceWhereUniqueInput
  }

  /**
   * LeaveBalance updateMany
   */
  export type LeaveBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveBalances.
     */
    data: XOR<LeaveBalanceUpdateManyMutationInput, LeaveBalanceUncheckedUpdateManyInput>
    /**
     * Filter which LeaveBalances to update
     */
    where?: LeaveBalanceWhereInput
    /**
     * Limit how many LeaveBalances to update.
     */
    limit?: number
  }

  /**
   * LeaveBalance updateManyAndReturn
   */
  export type LeaveBalanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * The data used to update LeaveBalances.
     */
    data: XOR<LeaveBalanceUpdateManyMutationInput, LeaveBalanceUncheckedUpdateManyInput>
    /**
     * Filter which LeaveBalances to update
     */
    where?: LeaveBalanceWhereInput
    /**
     * Limit how many LeaveBalances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveBalance upsert
   */
  export type LeaveBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveBalance to update in case it exists.
     */
    where: LeaveBalanceWhereUniqueInput
    /**
     * In case the LeaveBalance found by the `where` argument doesn't exist, create a new LeaveBalance with this data.
     */
    create: XOR<LeaveBalanceCreateInput, LeaveBalanceUncheckedCreateInput>
    /**
     * In case the LeaveBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveBalanceUpdateInput, LeaveBalanceUncheckedUpdateInput>
  }

  /**
   * LeaveBalance delete
   */
  export type LeaveBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter which LeaveBalance to delete.
     */
    where: LeaveBalanceWhereUniqueInput
  }

  /**
   * LeaveBalance deleteMany
   */
  export type LeaveBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveBalances to delete
     */
    where?: LeaveBalanceWhereInput
    /**
     * Limit how many LeaveBalances to delete.
     */
    limit?: number
  }

  /**
   * LeaveBalance without action
   */
  export type LeaveBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveBalance
     */
    omit?: LeaveBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
  }


  /**
   * Model LeaveRequest
   */

  export type AggregateLeaveRequest = {
    _count: LeaveRequestCountAggregateOutputType | null
    _avg: LeaveRequestAvgAggregateOutputType | null
    _sum: LeaveRequestSumAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  export type LeaveRequestAvgAggregateOutputType = {
    days: number | null
  }

  export type LeaveRequestSumAggregateOutputType = {
    days: number | null
  }

  export type LeaveRequestMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    employeeId: string | null
    leaveTypeId: string | null
    startDate: Date | null
    endDate: Date | null
    days: number | null
    status: $Enums.LeaveStatus | null
    reason: string | null
    requestedAt: Date | null
    validatedAt: Date | null
    validatedByUserId: string | null
    deletedAt: Date | null
  }

  export type LeaveRequestMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    employeeId: string | null
    leaveTypeId: string | null
    startDate: Date | null
    endDate: Date | null
    days: number | null
    status: $Enums.LeaveStatus | null
    reason: string | null
    requestedAt: Date | null
    validatedAt: Date | null
    validatedByUserId: string | null
    deletedAt: Date | null
  }

  export type LeaveRequestCountAggregateOutputType = {
    id: number
    companyId: number
    employeeId: number
    leaveTypeId: number
    startDate: number
    endDate: number
    days: number
    status: number
    reason: number
    requestedAt: number
    validatedAt: number
    validatedByUserId: number
    deletedAt: number
    _all: number
  }


  export type LeaveRequestAvgAggregateInputType = {
    days?: true
  }

  export type LeaveRequestSumAggregateInputType = {
    days?: true
  }

  export type LeaveRequestMinAggregateInputType = {
    id?: true
    companyId?: true
    employeeId?: true
    leaveTypeId?: true
    startDate?: true
    endDate?: true
    days?: true
    status?: true
    reason?: true
    requestedAt?: true
    validatedAt?: true
    validatedByUserId?: true
    deletedAt?: true
  }

  export type LeaveRequestMaxAggregateInputType = {
    id?: true
    companyId?: true
    employeeId?: true
    leaveTypeId?: true
    startDate?: true
    endDate?: true
    days?: true
    status?: true
    reason?: true
    requestedAt?: true
    validatedAt?: true
    validatedByUserId?: true
    deletedAt?: true
  }

  export type LeaveRequestCountAggregateInputType = {
    id?: true
    companyId?: true
    employeeId?: true
    leaveTypeId?: true
    startDate?: true
    endDate?: true
    days?: true
    status?: true
    reason?: true
    requestedAt?: true
    validatedAt?: true
    validatedByUserId?: true
    deletedAt?: true
    _all?: true
  }

  export type LeaveRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequest to aggregate.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveRequests
    **/
    _count?: true | LeaveRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type GetLeaveRequestAggregateType<T extends LeaveRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveRequest[P]>
      : GetScalarType<T[P], AggregateLeaveRequest[P]>
  }




  export type LeaveRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithAggregationInput | LeaveRequestOrderByWithAggregationInput[]
    by: LeaveRequestScalarFieldEnum[] | LeaveRequestScalarFieldEnum
    having?: LeaveRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveRequestCountAggregateInputType | true
    _avg?: LeaveRequestAvgAggregateInputType
    _sum?: LeaveRequestSumAggregateInputType
    _min?: LeaveRequestMinAggregateInputType
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type LeaveRequestGroupByOutputType = {
    id: string
    companyId: string
    employeeId: string
    leaveTypeId: string
    startDate: Date
    endDate: Date
    days: number
    status: $Enums.LeaveStatus
    reason: string | null
    requestedAt: Date
    validatedAt: Date | null
    validatedByUserId: string | null
    deletedAt: Date | null
    _count: LeaveRequestCountAggregateOutputType | null
    _avg: LeaveRequestAvgAggregateOutputType | null
    _sum: LeaveRequestSumAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  type GetLeaveRequestGroupByPayload<T extends LeaveRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
        }
      >
    >


  export type LeaveRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    status?: boolean
    reason?: boolean
    requestedAt?: boolean
    validatedAt?: boolean
    validatedByUserId?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
    validatedBy?: boolean | LeaveRequest$validatedByArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    status?: boolean
    reason?: boolean
    requestedAt?: boolean
    validatedAt?: boolean
    validatedByUserId?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
    validatedBy?: boolean | LeaveRequest$validatedByArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    status?: boolean
    reason?: boolean
    requestedAt?: boolean
    validatedAt?: boolean
    validatedByUserId?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
    validatedBy?: boolean | LeaveRequest$validatedByArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectScalar = {
    id?: boolean
    companyId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    startDate?: boolean
    endDate?: boolean
    days?: boolean
    status?: boolean
    reason?: boolean
    requestedAt?: boolean
    validatedAt?: boolean
    validatedByUserId?: boolean
    deletedAt?: boolean
  }

  export type LeaveRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "employeeId" | "leaveTypeId" | "startDate" | "endDate" | "days" | "status" | "reason" | "requestedAt" | "validatedAt" | "validatedByUserId" | "deletedAt", ExtArgs["result"]["leaveRequest"]>
  export type LeaveRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
    validatedBy?: boolean | LeaveRequest$validatedByArgs<ExtArgs>
  }
  export type LeaveRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
    validatedBy?: boolean | LeaveRequest$validatedByArgs<ExtArgs>
  }
  export type LeaveRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
    validatedBy?: boolean | LeaveRequest$validatedByArgs<ExtArgs>
  }

  export type $LeaveRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveRequest"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
      leaveType: Prisma.$LeaveTypePayload<ExtArgs>
      validatedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      employeeId: string
      leaveTypeId: string
      startDate: Date
      endDate: Date
      days: number
      status: $Enums.LeaveStatus
      reason: string | null
      requestedAt: Date
      validatedAt: Date | null
      validatedByUserId: string | null
      deletedAt: Date | null
    }, ExtArgs["result"]["leaveRequest"]>
    composites: {}
  }

  type LeaveRequestGetPayload<S extends boolean | null | undefined | LeaveRequestDefaultArgs> = $Result.GetResult<Prisma.$LeaveRequestPayload, S>

  type LeaveRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveRequestCountAggregateInputType | true
    }

  export interface LeaveRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveRequest'], meta: { name: 'LeaveRequest' } }
    /**
     * Find zero or one LeaveRequest that matches the filter.
     * @param {LeaveRequestFindUniqueArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveRequestFindUniqueArgs>(args: SelectSubset<T, LeaveRequestFindUniqueArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaveRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveRequestFindUniqueOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveRequestFindFirstArgs>(args?: SelectSubset<T, LeaveRequestFindFirstArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaveRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany()
     * 
     * // Get first 10 LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveRequestFindManyArgs>(args?: SelectSubset<T, LeaveRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaveRequest.
     * @param {LeaveRequestCreateArgs} args - Arguments to create a LeaveRequest.
     * @example
     * // Create one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.create({
     *   data: {
     *     // ... data to create a LeaveRequest
     *   }
     * })
     * 
     */
    create<T extends LeaveRequestCreateArgs>(args: SelectSubset<T, LeaveRequestCreateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaveRequests.
     * @param {LeaveRequestCreateManyArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveRequestCreateManyArgs>(args?: SelectSubset<T, LeaveRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveRequests and returns the data saved in the database.
     * @param {LeaveRequestCreateManyAndReturnArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveRequests and only return the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaveRequest.
     * @param {LeaveRequestDeleteArgs} args - Arguments to delete one LeaveRequest.
     * @example
     * // Delete one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.delete({
     *   where: {
     *     // ... filter to delete one LeaveRequest
     *   }
     * })
     * 
     */
    delete<T extends LeaveRequestDeleteArgs>(args: SelectSubset<T, LeaveRequestDeleteArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaveRequest.
     * @param {LeaveRequestUpdateArgs} args - Arguments to update one LeaveRequest.
     * @example
     * // Update one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveRequestUpdateArgs>(args: SelectSubset<T, LeaveRequestUpdateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaveRequests.
     * @param {LeaveRequestDeleteManyArgs} args - Arguments to filter LeaveRequests to delete.
     * @example
     * // Delete a few LeaveRequests
     * const { count } = await prisma.leaveRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveRequestDeleteManyArgs>(args?: SelectSubset<T, LeaveRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveRequestUpdateManyArgs>(args: SelectSubset<T, LeaveRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests and returns the data updated in the database.
     * @param {LeaveRequestUpdateManyAndReturnArgs} args - Arguments to update many LeaveRequests.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaveRequests and only return the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaveRequest.
     * @param {LeaveRequestUpsertArgs} args - Arguments to update or create a LeaveRequest.
     * @example
     * // Update or create a LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.upsert({
     *   create: {
     *     // ... data to create a LeaveRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveRequest we want to update
     *   }
     * })
     */
    upsert<T extends LeaveRequestUpsertArgs>(args: SelectSubset<T, LeaveRequestUpsertArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestCountArgs} args - Arguments to filter LeaveRequests to count.
     * @example
     * // Count the number of LeaveRequests
     * const count = await prisma.leaveRequest.count({
     *   where: {
     *     // ... the filter for the LeaveRequests we want to count
     *   }
     * })
    **/
    count<T extends LeaveRequestCountArgs>(
      args?: Subset<T, LeaveRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveRequestAggregateArgs>(args: Subset<T, LeaveRequestAggregateArgs>): Prisma.PrismaPromise<GetLeaveRequestAggregateType<T>>

    /**
     * Group by LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveRequestGroupByArgs['orderBy'] }
        : { orderBy?: LeaveRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveRequest model
   */
  readonly fields: LeaveRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leaveType<T extends LeaveTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaveTypeDefaultArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    validatedBy<T extends LeaveRequest$validatedByArgs<ExtArgs> = {}>(args?: Subset<T, LeaveRequest$validatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveRequest model
   */
  interface LeaveRequestFieldRefs {
    readonly id: FieldRef<"LeaveRequest", 'String'>
    readonly companyId: FieldRef<"LeaveRequest", 'String'>
    readonly employeeId: FieldRef<"LeaveRequest", 'String'>
    readonly leaveTypeId: FieldRef<"LeaveRequest", 'String'>
    readonly startDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly endDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly days: FieldRef<"LeaveRequest", 'Int'>
    readonly status: FieldRef<"LeaveRequest", 'LeaveStatus'>
    readonly reason: FieldRef<"LeaveRequest", 'String'>
    readonly requestedAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly validatedAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly validatedByUserId: FieldRef<"LeaveRequest", 'String'>
    readonly deletedAt: FieldRef<"LeaveRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveRequest findUnique
   */
  export type LeaveRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findUniqueOrThrow
   */
  export type LeaveRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findFirst
   */
  export type LeaveRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findFirstOrThrow
   */
  export type LeaveRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findMany
   */
  export type LeaveRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequests to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest create
   */
  export type LeaveRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveRequest.
     */
    data: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
  }

  /**
   * LeaveRequest createMany
   */
  export type LeaveRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveRequest createManyAndReturn
   */
  export type LeaveRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveRequest update
   */
  export type LeaveRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveRequest.
     */
    data: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
    /**
     * Choose, which LeaveRequest to update.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest updateMany
   */
  export type LeaveRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
    /**
     * Limit how many LeaveRequests to update.
     */
    limit?: number
  }

  /**
   * LeaveRequest updateManyAndReturn
   */
  export type LeaveRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
    /**
     * Limit how many LeaveRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveRequest upsert
   */
  export type LeaveRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveRequest to update in case it exists.
     */
    where: LeaveRequestWhereUniqueInput
    /**
     * In case the LeaveRequest found by the `where` argument doesn't exist, create a new LeaveRequest with this data.
     */
    create: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
    /**
     * In case the LeaveRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
  }

  /**
   * LeaveRequest delete
   */
  export type LeaveRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter which LeaveRequest to delete.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest deleteMany
   */
  export type LeaveRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequests to delete
     */
    where?: LeaveRequestWhereInput
    /**
     * Limit how many LeaveRequests to delete.
     */
    limit?: number
  }

  /**
   * LeaveRequest.validatedBy
   */
  export type LeaveRequest$validatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LeaveRequest without action
   */
  export type LeaveRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveRequest
     */
    omit?: LeaveRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
  }


  /**
   * Model PublicHoliday
   */

  export type AggregatePublicHoliday = {
    _count: PublicHolidayCountAggregateOutputType | null
    _min: PublicHolidayMinAggregateOutputType | null
    _max: PublicHolidayMaxAggregateOutputType | null
  }

  export type PublicHolidayMinAggregateOutputType = {
    id: string | null
    date: Date | null
    name: string | null
    country: string | null
    companyId: string | null
    deletedAt: Date | null
  }

  export type PublicHolidayMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    name: string | null
    country: string | null
    companyId: string | null
    deletedAt: Date | null
  }

  export type PublicHolidayCountAggregateOutputType = {
    id: number
    date: number
    name: number
    country: number
    companyId: number
    deletedAt: number
    _all: number
  }


  export type PublicHolidayMinAggregateInputType = {
    id?: true
    date?: true
    name?: true
    country?: true
    companyId?: true
    deletedAt?: true
  }

  export type PublicHolidayMaxAggregateInputType = {
    id?: true
    date?: true
    name?: true
    country?: true
    companyId?: true
    deletedAt?: true
  }

  export type PublicHolidayCountAggregateInputType = {
    id?: true
    date?: true
    name?: true
    country?: true
    companyId?: true
    deletedAt?: true
    _all?: true
  }

  export type PublicHolidayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicHoliday to aggregate.
     */
    where?: PublicHolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicHolidays to fetch.
     */
    orderBy?: PublicHolidayOrderByWithRelationInput | PublicHolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublicHolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicHolidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicHolidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PublicHolidays
    **/
    _count?: true | PublicHolidayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicHolidayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicHolidayMaxAggregateInputType
  }

  export type GetPublicHolidayAggregateType<T extends PublicHolidayAggregateArgs> = {
        [P in keyof T & keyof AggregatePublicHoliday]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublicHoliday[P]>
      : GetScalarType<T[P], AggregatePublicHoliday[P]>
  }




  export type PublicHolidayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicHolidayWhereInput
    orderBy?: PublicHolidayOrderByWithAggregationInput | PublicHolidayOrderByWithAggregationInput[]
    by: PublicHolidayScalarFieldEnum[] | PublicHolidayScalarFieldEnum
    having?: PublicHolidayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicHolidayCountAggregateInputType | true
    _min?: PublicHolidayMinAggregateInputType
    _max?: PublicHolidayMaxAggregateInputType
  }

  export type PublicHolidayGroupByOutputType = {
    id: string
    date: Date
    name: string
    country: string
    companyId: string | null
    deletedAt: Date | null
    _count: PublicHolidayCountAggregateOutputType | null
    _min: PublicHolidayMinAggregateOutputType | null
    _max: PublicHolidayMaxAggregateOutputType | null
  }

  type GetPublicHolidayGroupByPayload<T extends PublicHolidayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicHolidayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicHolidayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicHolidayGroupByOutputType[P]>
            : GetScalarType<T[P], PublicHolidayGroupByOutputType[P]>
        }
      >
    >


  export type PublicHolidaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    name?: boolean
    country?: boolean
    companyId?: boolean
    deletedAt?: boolean
    company?: boolean | PublicHoliday$companyArgs<ExtArgs>
  }, ExtArgs["result"]["publicHoliday"]>

  export type PublicHolidaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    name?: boolean
    country?: boolean
    companyId?: boolean
    deletedAt?: boolean
    company?: boolean | PublicHoliday$companyArgs<ExtArgs>
  }, ExtArgs["result"]["publicHoliday"]>

  export type PublicHolidaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    name?: boolean
    country?: boolean
    companyId?: boolean
    deletedAt?: boolean
    company?: boolean | PublicHoliday$companyArgs<ExtArgs>
  }, ExtArgs["result"]["publicHoliday"]>

  export type PublicHolidaySelectScalar = {
    id?: boolean
    date?: boolean
    name?: boolean
    country?: boolean
    companyId?: boolean
    deletedAt?: boolean
  }

  export type PublicHolidayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "name" | "country" | "companyId" | "deletedAt", ExtArgs["result"]["publicHoliday"]>
  export type PublicHolidayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | PublicHoliday$companyArgs<ExtArgs>
  }
  export type PublicHolidayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | PublicHoliday$companyArgs<ExtArgs>
  }
  export type PublicHolidayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | PublicHoliday$companyArgs<ExtArgs>
  }

  export type $PublicHolidayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PublicHoliday"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      name: string
      country: string
      companyId: string | null
      deletedAt: Date | null
    }, ExtArgs["result"]["publicHoliday"]>
    composites: {}
  }

  type PublicHolidayGetPayload<S extends boolean | null | undefined | PublicHolidayDefaultArgs> = $Result.GetResult<Prisma.$PublicHolidayPayload, S>

  type PublicHolidayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PublicHolidayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PublicHolidayCountAggregateInputType | true
    }

  export interface PublicHolidayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PublicHoliday'], meta: { name: 'PublicHoliday' } }
    /**
     * Find zero or one PublicHoliday that matches the filter.
     * @param {PublicHolidayFindUniqueArgs} args - Arguments to find a PublicHoliday
     * @example
     * // Get one PublicHoliday
     * const publicHoliday = await prisma.publicHoliday.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublicHolidayFindUniqueArgs>(args: SelectSubset<T, PublicHolidayFindUniqueArgs<ExtArgs>>): Prisma__PublicHolidayClient<$Result.GetResult<Prisma.$PublicHolidayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PublicHoliday that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PublicHolidayFindUniqueOrThrowArgs} args - Arguments to find a PublicHoliday
     * @example
     * // Get one PublicHoliday
     * const publicHoliday = await prisma.publicHoliday.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublicHolidayFindUniqueOrThrowArgs>(args: SelectSubset<T, PublicHolidayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PublicHolidayClient<$Result.GetResult<Prisma.$PublicHolidayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PublicHoliday that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicHolidayFindFirstArgs} args - Arguments to find a PublicHoliday
     * @example
     * // Get one PublicHoliday
     * const publicHoliday = await prisma.publicHoliday.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublicHolidayFindFirstArgs>(args?: SelectSubset<T, PublicHolidayFindFirstArgs<ExtArgs>>): Prisma__PublicHolidayClient<$Result.GetResult<Prisma.$PublicHolidayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PublicHoliday that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicHolidayFindFirstOrThrowArgs} args - Arguments to find a PublicHoliday
     * @example
     * // Get one PublicHoliday
     * const publicHoliday = await prisma.publicHoliday.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublicHolidayFindFirstOrThrowArgs>(args?: SelectSubset<T, PublicHolidayFindFirstOrThrowArgs<ExtArgs>>): Prisma__PublicHolidayClient<$Result.GetResult<Prisma.$PublicHolidayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PublicHolidays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicHolidayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PublicHolidays
     * const publicHolidays = await prisma.publicHoliday.findMany()
     * 
     * // Get first 10 PublicHolidays
     * const publicHolidays = await prisma.publicHoliday.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicHolidayWithIdOnly = await prisma.publicHoliday.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PublicHolidayFindManyArgs>(args?: SelectSubset<T, PublicHolidayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicHolidayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PublicHoliday.
     * @param {PublicHolidayCreateArgs} args - Arguments to create a PublicHoliday.
     * @example
     * // Create one PublicHoliday
     * const PublicHoliday = await prisma.publicHoliday.create({
     *   data: {
     *     // ... data to create a PublicHoliday
     *   }
     * })
     * 
     */
    create<T extends PublicHolidayCreateArgs>(args: SelectSubset<T, PublicHolidayCreateArgs<ExtArgs>>): Prisma__PublicHolidayClient<$Result.GetResult<Prisma.$PublicHolidayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PublicHolidays.
     * @param {PublicHolidayCreateManyArgs} args - Arguments to create many PublicHolidays.
     * @example
     * // Create many PublicHolidays
     * const publicHoliday = await prisma.publicHoliday.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PublicHolidayCreateManyArgs>(args?: SelectSubset<T, PublicHolidayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PublicHolidays and returns the data saved in the database.
     * @param {PublicHolidayCreateManyAndReturnArgs} args - Arguments to create many PublicHolidays.
     * @example
     * // Create many PublicHolidays
     * const publicHoliday = await prisma.publicHoliday.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PublicHolidays and only return the `id`
     * const publicHolidayWithIdOnly = await prisma.publicHoliday.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PublicHolidayCreateManyAndReturnArgs>(args?: SelectSubset<T, PublicHolidayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicHolidayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PublicHoliday.
     * @param {PublicHolidayDeleteArgs} args - Arguments to delete one PublicHoliday.
     * @example
     * // Delete one PublicHoliday
     * const PublicHoliday = await prisma.publicHoliday.delete({
     *   where: {
     *     // ... filter to delete one PublicHoliday
     *   }
     * })
     * 
     */
    delete<T extends PublicHolidayDeleteArgs>(args: SelectSubset<T, PublicHolidayDeleteArgs<ExtArgs>>): Prisma__PublicHolidayClient<$Result.GetResult<Prisma.$PublicHolidayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PublicHoliday.
     * @param {PublicHolidayUpdateArgs} args - Arguments to update one PublicHoliday.
     * @example
     * // Update one PublicHoliday
     * const publicHoliday = await prisma.publicHoliday.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PublicHolidayUpdateArgs>(args: SelectSubset<T, PublicHolidayUpdateArgs<ExtArgs>>): Prisma__PublicHolidayClient<$Result.GetResult<Prisma.$PublicHolidayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PublicHolidays.
     * @param {PublicHolidayDeleteManyArgs} args - Arguments to filter PublicHolidays to delete.
     * @example
     * // Delete a few PublicHolidays
     * const { count } = await prisma.publicHoliday.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PublicHolidayDeleteManyArgs>(args?: SelectSubset<T, PublicHolidayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PublicHolidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicHolidayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PublicHolidays
     * const publicHoliday = await prisma.publicHoliday.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PublicHolidayUpdateManyArgs>(args: SelectSubset<T, PublicHolidayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PublicHolidays and returns the data updated in the database.
     * @param {PublicHolidayUpdateManyAndReturnArgs} args - Arguments to update many PublicHolidays.
     * @example
     * // Update many PublicHolidays
     * const publicHoliday = await prisma.publicHoliday.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PublicHolidays and only return the `id`
     * const publicHolidayWithIdOnly = await prisma.publicHoliday.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PublicHolidayUpdateManyAndReturnArgs>(args: SelectSubset<T, PublicHolidayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicHolidayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PublicHoliday.
     * @param {PublicHolidayUpsertArgs} args - Arguments to update or create a PublicHoliday.
     * @example
     * // Update or create a PublicHoliday
     * const publicHoliday = await prisma.publicHoliday.upsert({
     *   create: {
     *     // ... data to create a PublicHoliday
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PublicHoliday we want to update
     *   }
     * })
     */
    upsert<T extends PublicHolidayUpsertArgs>(args: SelectSubset<T, PublicHolidayUpsertArgs<ExtArgs>>): Prisma__PublicHolidayClient<$Result.GetResult<Prisma.$PublicHolidayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PublicHolidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicHolidayCountArgs} args - Arguments to filter PublicHolidays to count.
     * @example
     * // Count the number of PublicHolidays
     * const count = await prisma.publicHoliday.count({
     *   where: {
     *     // ... the filter for the PublicHolidays we want to count
     *   }
     * })
    **/
    count<T extends PublicHolidayCountArgs>(
      args?: Subset<T, PublicHolidayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicHolidayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PublicHoliday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicHolidayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicHolidayAggregateArgs>(args: Subset<T, PublicHolidayAggregateArgs>): Prisma.PrismaPromise<GetPublicHolidayAggregateType<T>>

    /**
     * Group by PublicHoliday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicHolidayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicHolidayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicHolidayGroupByArgs['orderBy'] }
        : { orderBy?: PublicHolidayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicHolidayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicHolidayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PublicHoliday model
   */
  readonly fields: PublicHolidayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PublicHoliday.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicHolidayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends PublicHoliday$companyArgs<ExtArgs> = {}>(args?: Subset<T, PublicHoliday$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PublicHoliday model
   */
  interface PublicHolidayFieldRefs {
    readonly id: FieldRef<"PublicHoliday", 'String'>
    readonly date: FieldRef<"PublicHoliday", 'DateTime'>
    readonly name: FieldRef<"PublicHoliday", 'String'>
    readonly country: FieldRef<"PublicHoliday", 'String'>
    readonly companyId: FieldRef<"PublicHoliday", 'String'>
    readonly deletedAt: FieldRef<"PublicHoliday", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PublicHoliday findUnique
   */
  export type PublicHolidayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicHoliday
     */
    select?: PublicHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicHoliday
     */
    omit?: PublicHolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicHolidayInclude<ExtArgs> | null
    /**
     * Filter, which PublicHoliday to fetch.
     */
    where: PublicHolidayWhereUniqueInput
  }

  /**
   * PublicHoliday findUniqueOrThrow
   */
  export type PublicHolidayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicHoliday
     */
    select?: PublicHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicHoliday
     */
    omit?: PublicHolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicHolidayInclude<ExtArgs> | null
    /**
     * Filter, which PublicHoliday to fetch.
     */
    where: PublicHolidayWhereUniqueInput
  }

  /**
   * PublicHoliday findFirst
   */
  export type PublicHolidayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicHoliday
     */
    select?: PublicHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicHoliday
     */
    omit?: PublicHolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicHolidayInclude<ExtArgs> | null
    /**
     * Filter, which PublicHoliday to fetch.
     */
    where?: PublicHolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicHolidays to fetch.
     */
    orderBy?: PublicHolidayOrderByWithRelationInput | PublicHolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicHolidays.
     */
    cursor?: PublicHolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicHolidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicHolidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicHolidays.
     */
    distinct?: PublicHolidayScalarFieldEnum | PublicHolidayScalarFieldEnum[]
  }

  /**
   * PublicHoliday findFirstOrThrow
   */
  export type PublicHolidayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicHoliday
     */
    select?: PublicHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicHoliday
     */
    omit?: PublicHolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicHolidayInclude<ExtArgs> | null
    /**
     * Filter, which PublicHoliday to fetch.
     */
    where?: PublicHolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicHolidays to fetch.
     */
    orderBy?: PublicHolidayOrderByWithRelationInput | PublicHolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicHolidays.
     */
    cursor?: PublicHolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicHolidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicHolidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicHolidays.
     */
    distinct?: PublicHolidayScalarFieldEnum | PublicHolidayScalarFieldEnum[]
  }

  /**
   * PublicHoliday findMany
   */
  export type PublicHolidayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicHoliday
     */
    select?: PublicHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicHoliday
     */
    omit?: PublicHolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicHolidayInclude<ExtArgs> | null
    /**
     * Filter, which PublicHolidays to fetch.
     */
    where?: PublicHolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicHolidays to fetch.
     */
    orderBy?: PublicHolidayOrderByWithRelationInput | PublicHolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PublicHolidays.
     */
    cursor?: PublicHolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicHolidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicHolidays.
     */
    skip?: number
    distinct?: PublicHolidayScalarFieldEnum | PublicHolidayScalarFieldEnum[]
  }

  /**
   * PublicHoliday create
   */
  export type PublicHolidayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicHoliday
     */
    select?: PublicHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicHoliday
     */
    omit?: PublicHolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicHolidayInclude<ExtArgs> | null
    /**
     * The data needed to create a PublicHoliday.
     */
    data: XOR<PublicHolidayCreateInput, PublicHolidayUncheckedCreateInput>
  }

  /**
   * PublicHoliday createMany
   */
  export type PublicHolidayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PublicHolidays.
     */
    data: PublicHolidayCreateManyInput | PublicHolidayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PublicHoliday createManyAndReturn
   */
  export type PublicHolidayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicHoliday
     */
    select?: PublicHolidaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PublicHoliday
     */
    omit?: PublicHolidayOmit<ExtArgs> | null
    /**
     * The data used to create many PublicHolidays.
     */
    data: PublicHolidayCreateManyInput | PublicHolidayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicHolidayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PublicHoliday update
   */
  export type PublicHolidayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicHoliday
     */
    select?: PublicHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicHoliday
     */
    omit?: PublicHolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicHolidayInclude<ExtArgs> | null
    /**
     * The data needed to update a PublicHoliday.
     */
    data: XOR<PublicHolidayUpdateInput, PublicHolidayUncheckedUpdateInput>
    /**
     * Choose, which PublicHoliday to update.
     */
    where: PublicHolidayWhereUniqueInput
  }

  /**
   * PublicHoliday updateMany
   */
  export type PublicHolidayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PublicHolidays.
     */
    data: XOR<PublicHolidayUpdateManyMutationInput, PublicHolidayUncheckedUpdateManyInput>
    /**
     * Filter which PublicHolidays to update
     */
    where?: PublicHolidayWhereInput
    /**
     * Limit how many PublicHolidays to update.
     */
    limit?: number
  }

  /**
   * PublicHoliday updateManyAndReturn
   */
  export type PublicHolidayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicHoliday
     */
    select?: PublicHolidaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PublicHoliday
     */
    omit?: PublicHolidayOmit<ExtArgs> | null
    /**
     * The data used to update PublicHolidays.
     */
    data: XOR<PublicHolidayUpdateManyMutationInput, PublicHolidayUncheckedUpdateManyInput>
    /**
     * Filter which PublicHolidays to update
     */
    where?: PublicHolidayWhereInput
    /**
     * Limit how many PublicHolidays to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicHolidayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PublicHoliday upsert
   */
  export type PublicHolidayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicHoliday
     */
    select?: PublicHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicHoliday
     */
    omit?: PublicHolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicHolidayInclude<ExtArgs> | null
    /**
     * The filter to search for the PublicHoliday to update in case it exists.
     */
    where: PublicHolidayWhereUniqueInput
    /**
     * In case the PublicHoliday found by the `where` argument doesn't exist, create a new PublicHoliday with this data.
     */
    create: XOR<PublicHolidayCreateInput, PublicHolidayUncheckedCreateInput>
    /**
     * In case the PublicHoliday was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicHolidayUpdateInput, PublicHolidayUncheckedUpdateInput>
  }

  /**
   * PublicHoliday delete
   */
  export type PublicHolidayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicHoliday
     */
    select?: PublicHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicHoliday
     */
    omit?: PublicHolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicHolidayInclude<ExtArgs> | null
    /**
     * Filter which PublicHoliday to delete.
     */
    where: PublicHolidayWhereUniqueInput
  }

  /**
   * PublicHoliday deleteMany
   */
  export type PublicHolidayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicHolidays to delete
     */
    where?: PublicHolidayWhereInput
    /**
     * Limit how many PublicHolidays to delete.
     */
    limit?: number
  }

  /**
   * PublicHoliday.company
   */
  export type PublicHoliday$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * PublicHoliday without action
   */
  export type PublicHolidayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicHoliday
     */
    select?: PublicHolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicHoliday
     */
    omit?: PublicHolidayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicHolidayInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    baseSalary: number | null
    hourlyRate: number | null
  }

  export type ContractSumAggregateOutputType = {
    baseSalary: number | null
    hourlyRate: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    employeeId: string | null
    salaryType: $Enums.SalaryType | null
    baseSalary: number | null
    hourlyRate: number | null
    startDate: Date | null
    endDate: Date | null
    deletedAt: Date | null
  }

  export type ContractMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    employeeId: string | null
    salaryType: $Enums.SalaryType | null
    baseSalary: number | null
    hourlyRate: number | null
    startDate: Date | null
    endDate: Date | null
    deletedAt: Date | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    companyId: number
    employeeId: number
    salaryType: number
    baseSalary: number
    hourlyRate: number
    startDate: number
    endDate: number
    deletedAt: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    baseSalary?: true
    hourlyRate?: true
  }

  export type ContractSumAggregateInputType = {
    baseSalary?: true
    hourlyRate?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    companyId?: true
    employeeId?: true
    salaryType?: true
    baseSalary?: true
    hourlyRate?: true
    startDate?: true
    endDate?: true
    deletedAt?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    companyId?: true
    employeeId?: true
    salaryType?: true
    baseSalary?: true
    hourlyRate?: true
    startDate?: true
    endDate?: true
    deletedAt?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    companyId?: true
    employeeId?: true
    salaryType?: true
    baseSalary?: true
    hourlyRate?: true
    startDate?: true
    endDate?: true
    deletedAt?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: string
    companyId: string
    employeeId: string
    salaryType: $Enums.SalaryType
    baseSalary: number
    hourlyRate: number | null
    startDate: Date
    endDate: Date | null
    deletedAt: Date | null
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    employeeId?: boolean
    salaryType?: boolean
    baseSalary?: boolean
    hourlyRate?: boolean
    startDate?: boolean
    endDate?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    employeeId?: boolean
    salaryType?: boolean
    baseSalary?: boolean
    hourlyRate?: boolean
    startDate?: boolean
    endDate?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    employeeId?: boolean
    salaryType?: boolean
    baseSalary?: boolean
    hourlyRate?: boolean
    startDate?: boolean
    endDate?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectScalar = {
    id?: boolean
    companyId?: boolean
    employeeId?: boolean
    salaryType?: boolean
    baseSalary?: boolean
    hourlyRate?: boolean
    startDate?: boolean
    endDate?: boolean
    deletedAt?: boolean
  }

  export type ContractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "employeeId" | "salaryType" | "baseSalary" | "hourlyRate" | "startDate" | "endDate" | "deletedAt", ExtArgs["result"]["contract"]>
  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type ContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type ContractIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      employeeId: string
      salaryType: $Enums.SalaryType
      baseSalary: number
      hourlyRate: number | null
      startDate: Date
      endDate: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contracts and returns the data saved in the database.
     * @param {ContractCreateManyAndReturnArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts and returns the data updated in the database.
     * @param {ContractUpdateManyAndReturnArgs} args - Arguments to update many Contracts.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'String'>
    readonly companyId: FieldRef<"Contract", 'String'>
    readonly employeeId: FieldRef<"Contract", 'String'>
    readonly salaryType: FieldRef<"Contract", 'SalaryType'>
    readonly baseSalary: FieldRef<"Contract", 'Float'>
    readonly hourlyRate: FieldRef<"Contract", 'Float'>
    readonly startDate: FieldRef<"Contract", 'DateTime'>
    readonly endDate: FieldRef<"Contract", 'DateTime'>
    readonly deletedAt: FieldRef<"Contract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contract createManyAndReturn
   */
  export type ContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
  }

  /**
   * Contract updateManyAndReturn
   */
  export type ContractUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to delete.
     */
    limit?: number
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model PayrollPeriod
   */

  export type AggregatePayrollPeriod = {
    _count: PayrollPeriodCountAggregateOutputType | null
    _avg: PayrollPeriodAvgAggregateOutputType | null
    _sum: PayrollPeriodSumAggregateOutputType | null
    _min: PayrollPeriodMinAggregateOutputType | null
    _max: PayrollPeriodMaxAggregateOutputType | null
  }

  export type PayrollPeriodAvgAggregateOutputType = {
    month: number | null
    year: number | null
  }

  export type PayrollPeriodSumAggregateOutputType = {
    month: number | null
    year: number | null
  }

  export type PayrollPeriodMinAggregateOutputType = {
    id: string | null
    month: number | null
    year: number | null
    companyId: string | null
    isClosed: boolean | null
    closedAt: Date | null
    closedByUserId: string | null
    deletedAt: Date | null
  }

  export type PayrollPeriodMaxAggregateOutputType = {
    id: string | null
    month: number | null
    year: number | null
    companyId: string | null
    isClosed: boolean | null
    closedAt: Date | null
    closedByUserId: string | null
    deletedAt: Date | null
  }

  export type PayrollPeriodCountAggregateOutputType = {
    id: number
    month: number
    year: number
    companyId: number
    isClosed: number
    closedAt: number
    closedByUserId: number
    deletedAt: number
    _all: number
  }


  export type PayrollPeriodAvgAggregateInputType = {
    month?: true
    year?: true
  }

  export type PayrollPeriodSumAggregateInputType = {
    month?: true
    year?: true
  }

  export type PayrollPeriodMinAggregateInputType = {
    id?: true
    month?: true
    year?: true
    companyId?: true
    isClosed?: true
    closedAt?: true
    closedByUserId?: true
    deletedAt?: true
  }

  export type PayrollPeriodMaxAggregateInputType = {
    id?: true
    month?: true
    year?: true
    companyId?: true
    isClosed?: true
    closedAt?: true
    closedByUserId?: true
    deletedAt?: true
  }

  export type PayrollPeriodCountAggregateInputType = {
    id?: true
    month?: true
    year?: true
    companyId?: true
    isClosed?: true
    closedAt?: true
    closedByUserId?: true
    deletedAt?: true
    _all?: true
  }

  export type PayrollPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollPeriod to aggregate.
     */
    where?: PayrollPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollPeriods to fetch.
     */
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollPeriods
    **/
    _count?: true | PayrollPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollPeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollPeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollPeriodMaxAggregateInputType
  }

  export type GetPayrollPeriodAggregateType<T extends PayrollPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollPeriod[P]>
      : GetScalarType<T[P], AggregatePayrollPeriod[P]>
  }




  export type PayrollPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollPeriodWhereInput
    orderBy?: PayrollPeriodOrderByWithAggregationInput | PayrollPeriodOrderByWithAggregationInput[]
    by: PayrollPeriodScalarFieldEnum[] | PayrollPeriodScalarFieldEnum
    having?: PayrollPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollPeriodCountAggregateInputType | true
    _avg?: PayrollPeriodAvgAggregateInputType
    _sum?: PayrollPeriodSumAggregateInputType
    _min?: PayrollPeriodMinAggregateInputType
    _max?: PayrollPeriodMaxAggregateInputType
  }

  export type PayrollPeriodGroupByOutputType = {
    id: string
    month: number
    year: number
    companyId: string
    isClosed: boolean
    closedAt: Date | null
    closedByUserId: string | null
    deletedAt: Date | null
    _count: PayrollPeriodCountAggregateOutputType | null
    _avg: PayrollPeriodAvgAggregateOutputType | null
    _sum: PayrollPeriodSumAggregateOutputType | null
    _min: PayrollPeriodMinAggregateOutputType | null
    _max: PayrollPeriodMaxAggregateOutputType | null
  }

  type GetPayrollPeriodGroupByPayload<T extends PayrollPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollPeriodGroupByOutputType[P]>
        }
      >
    >


  export type PayrollPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    year?: boolean
    companyId?: boolean
    isClosed?: boolean
    closedAt?: boolean
    closedByUserId?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    closedBy?: boolean | PayrollPeriod$closedByArgs<ExtArgs>
    lines?: boolean | PayrollPeriod$linesArgs<ExtArgs>
    _count?: boolean | PayrollPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollPeriod"]>

  export type PayrollPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    year?: boolean
    companyId?: boolean
    isClosed?: boolean
    closedAt?: boolean
    closedByUserId?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    closedBy?: boolean | PayrollPeriod$closedByArgs<ExtArgs>
  }, ExtArgs["result"]["payrollPeriod"]>

  export type PayrollPeriodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    year?: boolean
    companyId?: boolean
    isClosed?: boolean
    closedAt?: boolean
    closedByUserId?: boolean
    deletedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    closedBy?: boolean | PayrollPeriod$closedByArgs<ExtArgs>
  }, ExtArgs["result"]["payrollPeriod"]>

  export type PayrollPeriodSelectScalar = {
    id?: boolean
    month?: boolean
    year?: boolean
    companyId?: boolean
    isClosed?: boolean
    closedAt?: boolean
    closedByUserId?: boolean
    deletedAt?: boolean
  }

  export type PayrollPeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "year" | "companyId" | "isClosed" | "closedAt" | "closedByUserId" | "deletedAt", ExtArgs["result"]["payrollPeriod"]>
  export type PayrollPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    closedBy?: boolean | PayrollPeriod$closedByArgs<ExtArgs>
    lines?: boolean | PayrollPeriod$linesArgs<ExtArgs>
    _count?: boolean | PayrollPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PayrollPeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    closedBy?: boolean | PayrollPeriod$closedByArgs<ExtArgs>
  }
  export type PayrollPeriodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    closedBy?: boolean | PayrollPeriod$closedByArgs<ExtArgs>
  }

  export type $PayrollPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayrollPeriod"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      closedBy: Prisma.$UserPayload<ExtArgs> | null
      lines: Prisma.$PayrollLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      month: number
      year: number
      companyId: string
      isClosed: boolean
      closedAt: Date | null
      closedByUserId: string | null
      deletedAt: Date | null
    }, ExtArgs["result"]["payrollPeriod"]>
    composites: {}
  }

  type PayrollPeriodGetPayload<S extends boolean | null | undefined | PayrollPeriodDefaultArgs> = $Result.GetResult<Prisma.$PayrollPeriodPayload, S>

  type PayrollPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollPeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollPeriodCountAggregateInputType | true
    }

  export interface PayrollPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollPeriod'], meta: { name: 'PayrollPeriod' } }
    /**
     * Find zero or one PayrollPeriod that matches the filter.
     * @param {PayrollPeriodFindUniqueArgs} args - Arguments to find a PayrollPeriod
     * @example
     * // Get one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollPeriodFindUniqueArgs>(args: SelectSubset<T, PayrollPeriodFindUniqueArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayrollPeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollPeriodFindUniqueOrThrowArgs} args - Arguments to find a PayrollPeriod
     * @example
     * // Get one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodFindFirstArgs} args - Arguments to find a PayrollPeriod
     * @example
     * // Get one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollPeriodFindFirstArgs>(args?: SelectSubset<T, PayrollPeriodFindFirstArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodFindFirstOrThrowArgs} args - Arguments to find a PayrollPeriod
     * @example
     * // Get one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayrollPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollPeriods
     * const payrollPeriods = await prisma.payrollPeriod.findMany()
     * 
     * // Get first 10 PayrollPeriods
     * const payrollPeriods = await prisma.payrollPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollPeriodWithIdOnly = await prisma.payrollPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollPeriodFindManyArgs>(args?: SelectSubset<T, PayrollPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayrollPeriod.
     * @param {PayrollPeriodCreateArgs} args - Arguments to create a PayrollPeriod.
     * @example
     * // Create one PayrollPeriod
     * const PayrollPeriod = await prisma.payrollPeriod.create({
     *   data: {
     *     // ... data to create a PayrollPeriod
     *   }
     * })
     * 
     */
    create<T extends PayrollPeriodCreateArgs>(args: SelectSubset<T, PayrollPeriodCreateArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayrollPeriods.
     * @param {PayrollPeriodCreateManyArgs} args - Arguments to create many PayrollPeriods.
     * @example
     * // Create many PayrollPeriods
     * const payrollPeriod = await prisma.payrollPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollPeriodCreateManyArgs>(args?: SelectSubset<T, PayrollPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayrollPeriods and returns the data saved in the database.
     * @param {PayrollPeriodCreateManyAndReturnArgs} args - Arguments to create many PayrollPeriods.
     * @example
     * // Create many PayrollPeriods
     * const payrollPeriod = await prisma.payrollPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayrollPeriods and only return the `id`
     * const payrollPeriodWithIdOnly = await prisma.payrollPeriod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayrollPeriod.
     * @param {PayrollPeriodDeleteArgs} args - Arguments to delete one PayrollPeriod.
     * @example
     * // Delete one PayrollPeriod
     * const PayrollPeriod = await prisma.payrollPeriod.delete({
     *   where: {
     *     // ... filter to delete one PayrollPeriod
     *   }
     * })
     * 
     */
    delete<T extends PayrollPeriodDeleteArgs>(args: SelectSubset<T, PayrollPeriodDeleteArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayrollPeriod.
     * @param {PayrollPeriodUpdateArgs} args - Arguments to update one PayrollPeriod.
     * @example
     * // Update one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollPeriodUpdateArgs>(args: SelectSubset<T, PayrollPeriodUpdateArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayrollPeriods.
     * @param {PayrollPeriodDeleteManyArgs} args - Arguments to filter PayrollPeriods to delete.
     * @example
     * // Delete a few PayrollPeriods
     * const { count } = await prisma.payrollPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollPeriodDeleteManyArgs>(args?: SelectSubset<T, PayrollPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollPeriods
     * const payrollPeriod = await prisma.payrollPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollPeriodUpdateManyArgs>(args: SelectSubset<T, PayrollPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollPeriods and returns the data updated in the database.
     * @param {PayrollPeriodUpdateManyAndReturnArgs} args - Arguments to update many PayrollPeriods.
     * @example
     * // Update many PayrollPeriods
     * const payrollPeriod = await prisma.payrollPeriod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayrollPeriods and only return the `id`
     * const payrollPeriodWithIdOnly = await prisma.payrollPeriod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollPeriodUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollPeriodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayrollPeriod.
     * @param {PayrollPeriodUpsertArgs} args - Arguments to update or create a PayrollPeriod.
     * @example
     * // Update or create a PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.upsert({
     *   create: {
     *     // ... data to create a PayrollPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollPeriod we want to update
     *   }
     * })
     */
    upsert<T extends PayrollPeriodUpsertArgs>(args: SelectSubset<T, PayrollPeriodUpsertArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayrollPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodCountArgs} args - Arguments to filter PayrollPeriods to count.
     * @example
     * // Count the number of PayrollPeriods
     * const count = await prisma.payrollPeriod.count({
     *   where: {
     *     // ... the filter for the PayrollPeriods we want to count
     *   }
     * })
    **/
    count<T extends PayrollPeriodCountArgs>(
      args?: Subset<T, PayrollPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollPeriodAggregateArgs>(args: Subset<T, PayrollPeriodAggregateArgs>): Prisma.PrismaPromise<GetPayrollPeriodAggregateType<T>>

    /**
     * Group by PayrollPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollPeriodGroupByArgs['orderBy'] }
        : { orderBy?: PayrollPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayrollPeriod model
   */
  readonly fields: PayrollPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    closedBy<T extends PayrollPeriod$closedByArgs<ExtArgs> = {}>(args?: Subset<T, PayrollPeriod$closedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends PayrollPeriod$linesArgs<ExtArgs> = {}>(args?: Subset<T, PayrollPeriod$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayrollPeriod model
   */
  interface PayrollPeriodFieldRefs {
    readonly id: FieldRef<"PayrollPeriod", 'String'>
    readonly month: FieldRef<"PayrollPeriod", 'Int'>
    readonly year: FieldRef<"PayrollPeriod", 'Int'>
    readonly companyId: FieldRef<"PayrollPeriod", 'String'>
    readonly isClosed: FieldRef<"PayrollPeriod", 'Boolean'>
    readonly closedAt: FieldRef<"PayrollPeriod", 'DateTime'>
    readonly closedByUserId: FieldRef<"PayrollPeriod", 'String'>
    readonly deletedAt: FieldRef<"PayrollPeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PayrollPeriod findUnique
   */
  export type PayrollPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriod to fetch.
     */
    where: PayrollPeriodWhereUniqueInput
  }

  /**
   * PayrollPeriod findUniqueOrThrow
   */
  export type PayrollPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriod to fetch.
     */
    where: PayrollPeriodWhereUniqueInput
  }

  /**
   * PayrollPeriod findFirst
   */
  export type PayrollPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriod to fetch.
     */
    where?: PayrollPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollPeriods to fetch.
     */
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollPeriods.
     */
    cursor?: PayrollPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollPeriods.
     */
    distinct?: PayrollPeriodScalarFieldEnum | PayrollPeriodScalarFieldEnum[]
  }

  /**
   * PayrollPeriod findFirstOrThrow
   */
  export type PayrollPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriod to fetch.
     */
    where?: PayrollPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollPeriods to fetch.
     */
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollPeriods.
     */
    cursor?: PayrollPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollPeriods.
     */
    distinct?: PayrollPeriodScalarFieldEnum | PayrollPeriodScalarFieldEnum[]
  }

  /**
   * PayrollPeriod findMany
   */
  export type PayrollPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriods to fetch.
     */
    where?: PayrollPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollPeriods to fetch.
     */
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollPeriods.
     */
    cursor?: PayrollPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollPeriods.
     */
    skip?: number
    distinct?: PayrollPeriodScalarFieldEnum | PayrollPeriodScalarFieldEnum[]
  }

  /**
   * PayrollPeriod create
   */
  export type PayrollPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollPeriod.
     */
    data: XOR<PayrollPeriodCreateInput, PayrollPeriodUncheckedCreateInput>
  }

  /**
   * PayrollPeriod createMany
   */
  export type PayrollPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollPeriods.
     */
    data: PayrollPeriodCreateManyInput | PayrollPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayrollPeriod createManyAndReturn
   */
  export type PayrollPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * The data used to create many PayrollPeriods.
     */
    data: PayrollPeriodCreateManyInput | PayrollPeriodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollPeriod update
   */
  export type PayrollPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollPeriod.
     */
    data: XOR<PayrollPeriodUpdateInput, PayrollPeriodUncheckedUpdateInput>
    /**
     * Choose, which PayrollPeriod to update.
     */
    where: PayrollPeriodWhereUniqueInput
  }

  /**
   * PayrollPeriod updateMany
   */
  export type PayrollPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollPeriods.
     */
    data: XOR<PayrollPeriodUpdateManyMutationInput, PayrollPeriodUncheckedUpdateManyInput>
    /**
     * Filter which PayrollPeriods to update
     */
    where?: PayrollPeriodWhereInput
    /**
     * Limit how many PayrollPeriods to update.
     */
    limit?: number
  }

  /**
   * PayrollPeriod updateManyAndReturn
   */
  export type PayrollPeriodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * The data used to update PayrollPeriods.
     */
    data: XOR<PayrollPeriodUpdateManyMutationInput, PayrollPeriodUncheckedUpdateManyInput>
    /**
     * Filter which PayrollPeriods to update
     */
    where?: PayrollPeriodWhereInput
    /**
     * Limit how many PayrollPeriods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollPeriod upsert
   */
  export type PayrollPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollPeriod to update in case it exists.
     */
    where: PayrollPeriodWhereUniqueInput
    /**
     * In case the PayrollPeriod found by the `where` argument doesn't exist, create a new PayrollPeriod with this data.
     */
    create: XOR<PayrollPeriodCreateInput, PayrollPeriodUncheckedCreateInput>
    /**
     * In case the PayrollPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollPeriodUpdateInput, PayrollPeriodUncheckedUpdateInput>
  }

  /**
   * PayrollPeriod delete
   */
  export type PayrollPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter which PayrollPeriod to delete.
     */
    where: PayrollPeriodWhereUniqueInput
  }

  /**
   * PayrollPeriod deleteMany
   */
  export type PayrollPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollPeriods to delete
     */
    where?: PayrollPeriodWhereInput
    /**
     * Limit how many PayrollPeriods to delete.
     */
    limit?: number
  }

  /**
   * PayrollPeriod.closedBy
   */
  export type PayrollPeriod$closedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PayrollPeriod.lines
   */
  export type PayrollPeriod$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    where?: PayrollLineWhereInput
    orderBy?: PayrollLineOrderByWithRelationInput | PayrollLineOrderByWithRelationInput[]
    cursor?: PayrollLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollLineScalarFieldEnum | PayrollLineScalarFieldEnum[]
  }

  /**
   * PayrollPeriod without action
   */
  export type PayrollPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
  }


  /**
   * Model PayrollLine
   */

  export type AggregatePayrollLine = {
    _count: PayrollLineCountAggregateOutputType | null
    _avg: PayrollLineAvgAggregateOutputType | null
    _sum: PayrollLineSumAggregateOutputType | null
    _min: PayrollLineMinAggregateOutputType | null
    _max: PayrollLineMaxAggregateOutputType | null
  }

  export type PayrollLineAvgAggregateOutputType = {
    workedDays: number | null
    absentDays: number | null
    lateMinutes: number | null
    overtimeHours: number | null
    grossSalary: number | null
    deductions: number | null
    netSalary: number | null
  }

  export type PayrollLineSumAggregateOutputType = {
    workedDays: number | null
    absentDays: number | null
    lateMinutes: number | null
    overtimeHours: number | null
    grossSalary: number | null
    deductions: number | null
    netSalary: number | null
  }

  export type PayrollLineMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    payrollPeriodId: string | null
    employeeId: string | null
    workedDays: number | null
    absentDays: number | null
    lateMinutes: number | null
    overtimeHours: number | null
    grossSalary: number | null
    deductions: number | null
    netSalary: number | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type PayrollLineMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    payrollPeriodId: string | null
    employeeId: string | null
    workedDays: number | null
    absentDays: number | null
    lateMinutes: number | null
    overtimeHours: number | null
    grossSalary: number | null
    deductions: number | null
    netSalary: number | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type PayrollLineCountAggregateOutputType = {
    id: number
    companyId: number
    payrollPeriodId: number
    employeeId: number
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt: number
    createdAt: number
    _all: number
  }


  export type PayrollLineAvgAggregateInputType = {
    workedDays?: true
    absentDays?: true
    lateMinutes?: true
    overtimeHours?: true
    grossSalary?: true
    deductions?: true
    netSalary?: true
  }

  export type PayrollLineSumAggregateInputType = {
    workedDays?: true
    absentDays?: true
    lateMinutes?: true
    overtimeHours?: true
    grossSalary?: true
    deductions?: true
    netSalary?: true
  }

  export type PayrollLineMinAggregateInputType = {
    id?: true
    companyId?: true
    payrollPeriodId?: true
    employeeId?: true
    workedDays?: true
    absentDays?: true
    lateMinutes?: true
    overtimeHours?: true
    grossSalary?: true
    deductions?: true
    netSalary?: true
    deletedAt?: true
    createdAt?: true
  }

  export type PayrollLineMaxAggregateInputType = {
    id?: true
    companyId?: true
    payrollPeriodId?: true
    employeeId?: true
    workedDays?: true
    absentDays?: true
    lateMinutes?: true
    overtimeHours?: true
    grossSalary?: true
    deductions?: true
    netSalary?: true
    deletedAt?: true
    createdAt?: true
  }

  export type PayrollLineCountAggregateInputType = {
    id?: true
    companyId?: true
    payrollPeriodId?: true
    employeeId?: true
    workedDays?: true
    absentDays?: true
    lateMinutes?: true
    overtimeHours?: true
    grossSalary?: true
    deductions?: true
    netSalary?: true
    deletedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PayrollLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollLine to aggregate.
     */
    where?: PayrollLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollLines to fetch.
     */
    orderBy?: PayrollLineOrderByWithRelationInput | PayrollLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollLines
    **/
    _count?: true | PayrollLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollLineMaxAggregateInputType
  }

  export type GetPayrollLineAggregateType<T extends PayrollLineAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollLine[P]>
      : GetScalarType<T[P], AggregatePayrollLine[P]>
  }




  export type PayrollLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollLineWhereInput
    orderBy?: PayrollLineOrderByWithAggregationInput | PayrollLineOrderByWithAggregationInput[]
    by: PayrollLineScalarFieldEnum[] | PayrollLineScalarFieldEnum
    having?: PayrollLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollLineCountAggregateInputType | true
    _avg?: PayrollLineAvgAggregateInputType
    _sum?: PayrollLineSumAggregateInputType
    _min?: PayrollLineMinAggregateInputType
    _max?: PayrollLineMaxAggregateInputType
  }

  export type PayrollLineGroupByOutputType = {
    id: string
    companyId: string
    payrollPeriodId: string
    employeeId: string
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt: Date | null
    createdAt: Date
    _count: PayrollLineCountAggregateOutputType | null
    _avg: PayrollLineAvgAggregateOutputType | null
    _sum: PayrollLineSumAggregateOutputType | null
    _min: PayrollLineMinAggregateOutputType | null
    _max: PayrollLineMaxAggregateOutputType | null
  }

  type GetPayrollLineGroupByPayload<T extends PayrollLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollLineGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollLineGroupByOutputType[P]>
        }
      >
    >


  export type PayrollLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    payrollPeriodId?: boolean
    employeeId?: boolean
    workedDays?: boolean
    absentDays?: boolean
    lateMinutes?: boolean
    overtimeHours?: boolean
    grossSalary?: boolean
    deductions?: boolean
    netSalary?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payrollPeriod?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollLine"]>

  export type PayrollLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    payrollPeriodId?: boolean
    employeeId?: boolean
    workedDays?: boolean
    absentDays?: boolean
    lateMinutes?: boolean
    overtimeHours?: boolean
    grossSalary?: boolean
    deductions?: boolean
    netSalary?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payrollPeriod?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollLine"]>

  export type PayrollLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    payrollPeriodId?: boolean
    employeeId?: boolean
    workedDays?: boolean
    absentDays?: boolean
    lateMinutes?: boolean
    overtimeHours?: boolean
    grossSalary?: boolean
    deductions?: boolean
    netSalary?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payrollPeriod?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollLine"]>

  export type PayrollLineSelectScalar = {
    id?: boolean
    companyId?: boolean
    payrollPeriodId?: boolean
    employeeId?: boolean
    workedDays?: boolean
    absentDays?: boolean
    lateMinutes?: boolean
    overtimeHours?: boolean
    grossSalary?: boolean
    deductions?: boolean
    netSalary?: boolean
    deletedAt?: boolean
    createdAt?: boolean
  }

  export type PayrollLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "payrollPeriodId" | "employeeId" | "workedDays" | "absentDays" | "lateMinutes" | "overtimeHours" | "grossSalary" | "deductions" | "netSalary" | "deletedAt" | "createdAt", ExtArgs["result"]["payrollLine"]>
  export type PayrollLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payrollPeriod?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PayrollLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payrollPeriod?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PayrollLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payrollPeriod?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $PayrollLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayrollLine"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      payrollPeriod: Prisma.$PayrollPeriodPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      payrollPeriodId: string
      employeeId: string
      workedDays: number
      absentDays: number
      lateMinutes: number
      overtimeHours: number
      grossSalary: number
      deductions: number
      netSalary: number
      deletedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["payrollLine"]>
    composites: {}
  }

  type PayrollLineGetPayload<S extends boolean | null | undefined | PayrollLineDefaultArgs> = $Result.GetResult<Prisma.$PayrollLinePayload, S>

  type PayrollLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollLineCountAggregateInputType | true
    }

  export interface PayrollLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollLine'], meta: { name: 'PayrollLine' } }
    /**
     * Find zero or one PayrollLine that matches the filter.
     * @param {PayrollLineFindUniqueArgs} args - Arguments to find a PayrollLine
     * @example
     * // Get one PayrollLine
     * const payrollLine = await prisma.payrollLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollLineFindUniqueArgs>(args: SelectSubset<T, PayrollLineFindUniqueArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayrollLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollLineFindUniqueOrThrowArgs} args - Arguments to find a PayrollLine
     * @example
     * // Get one PayrollLine
     * const payrollLine = await prisma.payrollLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollLineFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineFindFirstArgs} args - Arguments to find a PayrollLine
     * @example
     * // Get one PayrollLine
     * const payrollLine = await prisma.payrollLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollLineFindFirstArgs>(args?: SelectSubset<T, PayrollLineFindFirstArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineFindFirstOrThrowArgs} args - Arguments to find a PayrollLine
     * @example
     * // Get one PayrollLine
     * const payrollLine = await prisma.payrollLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollLineFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayrollLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollLines
     * const payrollLines = await prisma.payrollLine.findMany()
     * 
     * // Get first 10 PayrollLines
     * const payrollLines = await prisma.payrollLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollLineWithIdOnly = await prisma.payrollLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollLineFindManyArgs>(args?: SelectSubset<T, PayrollLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayrollLine.
     * @param {PayrollLineCreateArgs} args - Arguments to create a PayrollLine.
     * @example
     * // Create one PayrollLine
     * const PayrollLine = await prisma.payrollLine.create({
     *   data: {
     *     // ... data to create a PayrollLine
     *   }
     * })
     * 
     */
    create<T extends PayrollLineCreateArgs>(args: SelectSubset<T, PayrollLineCreateArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayrollLines.
     * @param {PayrollLineCreateManyArgs} args - Arguments to create many PayrollLines.
     * @example
     * // Create many PayrollLines
     * const payrollLine = await prisma.payrollLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollLineCreateManyArgs>(args?: SelectSubset<T, PayrollLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayrollLines and returns the data saved in the database.
     * @param {PayrollLineCreateManyAndReturnArgs} args - Arguments to create many PayrollLines.
     * @example
     * // Create many PayrollLines
     * const payrollLine = await prisma.payrollLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayrollLines and only return the `id`
     * const payrollLineWithIdOnly = await prisma.payrollLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollLineCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayrollLine.
     * @param {PayrollLineDeleteArgs} args - Arguments to delete one PayrollLine.
     * @example
     * // Delete one PayrollLine
     * const PayrollLine = await prisma.payrollLine.delete({
     *   where: {
     *     // ... filter to delete one PayrollLine
     *   }
     * })
     * 
     */
    delete<T extends PayrollLineDeleteArgs>(args: SelectSubset<T, PayrollLineDeleteArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayrollLine.
     * @param {PayrollLineUpdateArgs} args - Arguments to update one PayrollLine.
     * @example
     * // Update one PayrollLine
     * const payrollLine = await prisma.payrollLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollLineUpdateArgs>(args: SelectSubset<T, PayrollLineUpdateArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayrollLines.
     * @param {PayrollLineDeleteManyArgs} args - Arguments to filter PayrollLines to delete.
     * @example
     * // Delete a few PayrollLines
     * const { count } = await prisma.payrollLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollLineDeleteManyArgs>(args?: SelectSubset<T, PayrollLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollLines
     * const payrollLine = await prisma.payrollLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollLineUpdateManyArgs>(args: SelectSubset<T, PayrollLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollLines and returns the data updated in the database.
     * @param {PayrollLineUpdateManyAndReturnArgs} args - Arguments to update many PayrollLines.
     * @example
     * // Update many PayrollLines
     * const payrollLine = await prisma.payrollLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayrollLines and only return the `id`
     * const payrollLineWithIdOnly = await prisma.payrollLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollLineUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayrollLine.
     * @param {PayrollLineUpsertArgs} args - Arguments to update or create a PayrollLine.
     * @example
     * // Update or create a PayrollLine
     * const payrollLine = await prisma.payrollLine.upsert({
     *   create: {
     *     // ... data to create a PayrollLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollLine we want to update
     *   }
     * })
     */
    upsert<T extends PayrollLineUpsertArgs>(args: SelectSubset<T, PayrollLineUpsertArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayrollLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineCountArgs} args - Arguments to filter PayrollLines to count.
     * @example
     * // Count the number of PayrollLines
     * const count = await prisma.payrollLine.count({
     *   where: {
     *     // ... the filter for the PayrollLines we want to count
     *   }
     * })
    **/
    count<T extends PayrollLineCountArgs>(
      args?: Subset<T, PayrollLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollLineAggregateArgs>(args: Subset<T, PayrollLineAggregateArgs>): Prisma.PrismaPromise<GetPayrollLineAggregateType<T>>

    /**
     * Group by PayrollLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollLineGroupByArgs['orderBy'] }
        : { orderBy?: PayrollLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayrollLine model
   */
  readonly fields: PayrollLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payrollPeriod<T extends PayrollPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PayrollPeriodDefaultArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayrollLine model
   */
  interface PayrollLineFieldRefs {
    readonly id: FieldRef<"PayrollLine", 'String'>
    readonly companyId: FieldRef<"PayrollLine", 'String'>
    readonly payrollPeriodId: FieldRef<"PayrollLine", 'String'>
    readonly employeeId: FieldRef<"PayrollLine", 'String'>
    readonly workedDays: FieldRef<"PayrollLine", 'Int'>
    readonly absentDays: FieldRef<"PayrollLine", 'Int'>
    readonly lateMinutes: FieldRef<"PayrollLine", 'Int'>
    readonly overtimeHours: FieldRef<"PayrollLine", 'Float'>
    readonly grossSalary: FieldRef<"PayrollLine", 'Float'>
    readonly deductions: FieldRef<"PayrollLine", 'Float'>
    readonly netSalary: FieldRef<"PayrollLine", 'Float'>
    readonly deletedAt: FieldRef<"PayrollLine", 'DateTime'>
    readonly createdAt: FieldRef<"PayrollLine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PayrollLine findUnique
   */
  export type PayrollLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * Filter, which PayrollLine to fetch.
     */
    where: PayrollLineWhereUniqueInput
  }

  /**
   * PayrollLine findUniqueOrThrow
   */
  export type PayrollLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * Filter, which PayrollLine to fetch.
     */
    where: PayrollLineWhereUniqueInput
  }

  /**
   * PayrollLine findFirst
   */
  export type PayrollLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * Filter, which PayrollLine to fetch.
     */
    where?: PayrollLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollLines to fetch.
     */
    orderBy?: PayrollLineOrderByWithRelationInput | PayrollLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollLines.
     */
    cursor?: PayrollLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollLines.
     */
    distinct?: PayrollLineScalarFieldEnum | PayrollLineScalarFieldEnum[]
  }

  /**
   * PayrollLine findFirstOrThrow
   */
  export type PayrollLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * Filter, which PayrollLine to fetch.
     */
    where?: PayrollLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollLines to fetch.
     */
    orderBy?: PayrollLineOrderByWithRelationInput | PayrollLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollLines.
     */
    cursor?: PayrollLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollLines.
     */
    distinct?: PayrollLineScalarFieldEnum | PayrollLineScalarFieldEnum[]
  }

  /**
   * PayrollLine findMany
   */
  export type PayrollLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * Filter, which PayrollLines to fetch.
     */
    where?: PayrollLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollLines to fetch.
     */
    orderBy?: PayrollLineOrderByWithRelationInput | PayrollLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollLines.
     */
    cursor?: PayrollLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollLines.
     */
    skip?: number
    distinct?: PayrollLineScalarFieldEnum | PayrollLineScalarFieldEnum[]
  }

  /**
   * PayrollLine create
   */
  export type PayrollLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollLine.
     */
    data: XOR<PayrollLineCreateInput, PayrollLineUncheckedCreateInput>
  }

  /**
   * PayrollLine createMany
   */
  export type PayrollLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollLines.
     */
    data: PayrollLineCreateManyInput | PayrollLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayrollLine createManyAndReturn
   */
  export type PayrollLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * The data used to create many PayrollLines.
     */
    data: PayrollLineCreateManyInput | PayrollLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollLine update
   */
  export type PayrollLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollLine.
     */
    data: XOR<PayrollLineUpdateInput, PayrollLineUncheckedUpdateInput>
    /**
     * Choose, which PayrollLine to update.
     */
    where: PayrollLineWhereUniqueInput
  }

  /**
   * PayrollLine updateMany
   */
  export type PayrollLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollLines.
     */
    data: XOR<PayrollLineUpdateManyMutationInput, PayrollLineUncheckedUpdateManyInput>
    /**
     * Filter which PayrollLines to update
     */
    where?: PayrollLineWhereInput
    /**
     * Limit how many PayrollLines to update.
     */
    limit?: number
  }

  /**
   * PayrollLine updateManyAndReturn
   */
  export type PayrollLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * The data used to update PayrollLines.
     */
    data: XOR<PayrollLineUpdateManyMutationInput, PayrollLineUncheckedUpdateManyInput>
    /**
     * Filter which PayrollLines to update
     */
    where?: PayrollLineWhereInput
    /**
     * Limit how many PayrollLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollLine upsert
   */
  export type PayrollLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollLine to update in case it exists.
     */
    where: PayrollLineWhereUniqueInput
    /**
     * In case the PayrollLine found by the `where` argument doesn't exist, create a new PayrollLine with this data.
     */
    create: XOR<PayrollLineCreateInput, PayrollLineUncheckedCreateInput>
    /**
     * In case the PayrollLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollLineUpdateInput, PayrollLineUncheckedUpdateInput>
  }

  /**
   * PayrollLine delete
   */
  export type PayrollLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * Filter which PayrollLine to delete.
     */
    where: PayrollLineWhereUniqueInput
  }

  /**
   * PayrollLine deleteMany
   */
  export type PayrollLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollLines to delete
     */
    where?: PayrollLineWhereInput
    /**
     * Limit how many PayrollLines to delete.
     */
    limit?: number
  }

  /**
   * PayrollLine without action
   */
  export type PayrollLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    type: 'type',
    isActive: 'isActive',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    passwordHash: 'passwordHash',
    roles: 'roles',
    isActive: 'isActive',
    companyId: 'companyId',
    personId: 'personId',
    refreshTokenHash: 'refreshTokenHash',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    checkInAt: 'checkInAt',
    checkOutAt: 'checkOutAt',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    daysOfWeek: 'daysOfWeek',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const OvertimeScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    userId: 'userId',
    date: 'date',
    hours: 'hours',
    reason: 'reason',
    status: 'status',
    approvedByUserId: 'approvedByUserId',
    approvedAt: 'approvedAt',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OvertimeScalarFieldEnum = (typeof OvertimeScalarFieldEnum)[keyof typeof OvertimeScalarFieldEnum]


  export const AttendanceSummaryScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    totalHours: 'totalHours',
    overtimeHours: 'overtimeHours',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceSummaryScalarFieldEnum = (typeof AttendanceSummaryScalarFieldEnum)[keyof typeof AttendanceSummaryScalarFieldEnum]


  export const PayrollScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    attendanceSummaryId: 'attendanceSummaryId',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    grossPay: 'grossPay',
    netPay: 'netPay',
    status: 'status',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollScalarFieldEnum = (typeof PayrollScalarFieldEnum)[keyof typeof PayrollScalarFieldEnum]


  export const PayrollExportScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    payrollId: 'payrollId',
    format: 'format',
    path: 'path',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollExportScalarFieldEnum = (typeof PayrollExportScalarFieldEnum)[keyof typeof PayrollExportScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    type: 'type',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    data: 'data',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const PeriodClosureScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    closedAt: 'closedAt'
  };

  export type PeriodClosureScalarFieldEnum = (typeof PeriodClosureScalarFieldEnum)[keyof typeof PeriodClosureScalarFieldEnum]


  export const SchoolClassScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    code: 'code',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolClassScalarFieldEnum = (typeof SchoolClassScalarFieldEnum)[keyof typeof SchoolClassScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    classId: 'classId',
    name: 'name',
    code: 'code',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    classId: 'classId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    personId: 'personId',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const StudentAttendanceScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    studentId: 'studentId',
    date: 'date',
    status: 'status',
    note: 'note',
    recordedByUserId: 'recordedByUserId',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentAttendanceScalarFieldEnum = (typeof StudentAttendanceScalarFieldEnum)[keyof typeof StudentAttendanceScalarFieldEnum]


  export const ConstructionSiteScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    location: 'location',
    latitude: 'latitude',
    longitude: 'longitude',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConstructionSiteScalarFieldEnum = (typeof ConstructionSiteScalarFieldEnum)[keyof typeof ConstructionSiteScalarFieldEnum]


  export const ConstructionTeamScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    siteId: 'siteId',
    name: 'name',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConstructionTeamScalarFieldEnum = (typeof ConstructionTeamScalarFieldEnum)[keyof typeof ConstructionTeamScalarFieldEnum]


  export const ConstructionWorkerScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    teamId: 'teamId',
    name: 'name',
    email: 'email',
    personId: 'personId',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConstructionWorkerScalarFieldEnum = (typeof ConstructionWorkerScalarFieldEnum)[keyof typeof ConstructionWorkerScalarFieldEnum]


  export const SiteAttendanceScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    siteId: 'siteId',
    workerId: 'workerId',
    date: 'date',
    checkInAt: 'checkInAt',
    checkOutAt: 'checkOutAt',
    latitude: 'latitude',
    longitude: 'longitude',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SiteAttendanceScalarFieldEnum = (typeof SiteAttendanceScalarFieldEnum)[keyof typeof SiteAttendanceScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    actionType: 'actionType',
    entityType: 'entityType',
    ip: 'ip',
    userId: 'userId',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    role: 'role',
    userId: 'userId',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const PersonScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PersonScalarFieldEnum = (typeof PersonScalarFieldEnum)[keyof typeof PersonScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    personId: 'personId',
    userId: 'userId',
    scheduleId: 'scheduleId',
    matricule: 'matricule',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const WorkerScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    personId: 'personId',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt'
  };

  export type WorkerScalarFieldEnum = (typeof WorkerScalarFieldEnum)[keyof typeof WorkerScalarFieldEnum]


  export const AttendanceEventScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    type: 'type',
    timestamp: 'timestamp',
    date: 'date',
    personType: 'personType',
    employeeId: 'employeeId',
    studentId: 'studentId',
    workerId: 'workerId',
    deviceId: 'deviceId',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt'
  };

  export type AttendanceEventScalarFieldEnum = (typeof AttendanceEventScalarFieldEnum)[keyof typeof AttendanceEventScalarFieldEnum]


  export const AttendanceDailySummaryScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    date: 'date',
    status: 'status',
    lateMinutes: 'lateMinutes',
    earlyMinutes: 'earlyMinutes',
    workedMinutes: 'workedMinutes',
    employeeId: 'employeeId',
    studentId: 'studentId',
    workerId: 'workerId',
    validatedByUserId: 'validatedByUserId',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt'
  };

  export type AttendanceDailySummaryScalarFieldEnum = (typeof AttendanceDailySummaryScalarFieldEnum)[keyof typeof AttendanceDailySummaryScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    platform: 'platform',
    model: 'model',
    personId: 'personId',
    companyId: 'companyId',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const LeaveTypeScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    code: 'code',
    isPaid: 'isPaid',
    maxDaysYear: 'maxDaysYear',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt'
  };

  export type LeaveTypeScalarFieldEnum = (typeof LeaveTypeScalarFieldEnum)[keyof typeof LeaveTypeScalarFieldEnum]


  export const LeaveBalanceScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    employeeId: 'employeeId',
    leaveTypeId: 'leaveTypeId',
    year: 'year',
    totalDays: 'totalDays',
    usedDays: 'usedDays',
    deletedAt: 'deletedAt'
  };

  export type LeaveBalanceScalarFieldEnum = (typeof LeaveBalanceScalarFieldEnum)[keyof typeof LeaveBalanceScalarFieldEnum]


  export const LeaveRequestScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    employeeId: 'employeeId',
    leaveTypeId: 'leaveTypeId',
    startDate: 'startDate',
    endDate: 'endDate',
    days: 'days',
    status: 'status',
    reason: 'reason',
    requestedAt: 'requestedAt',
    validatedAt: 'validatedAt',
    validatedByUserId: 'validatedByUserId',
    deletedAt: 'deletedAt'
  };

  export type LeaveRequestScalarFieldEnum = (typeof LeaveRequestScalarFieldEnum)[keyof typeof LeaveRequestScalarFieldEnum]


  export const PublicHolidayScalarFieldEnum: {
    id: 'id',
    date: 'date',
    name: 'name',
    country: 'country',
    companyId: 'companyId',
    deletedAt: 'deletedAt'
  };

  export type PublicHolidayScalarFieldEnum = (typeof PublicHolidayScalarFieldEnum)[keyof typeof PublicHolidayScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    employeeId: 'employeeId',
    salaryType: 'salaryType',
    baseSalary: 'baseSalary',
    hourlyRate: 'hourlyRate',
    startDate: 'startDate',
    endDate: 'endDate',
    deletedAt: 'deletedAt'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const PayrollPeriodScalarFieldEnum: {
    id: 'id',
    month: 'month',
    year: 'year',
    companyId: 'companyId',
    isClosed: 'isClosed',
    closedAt: 'closedAt',
    closedByUserId: 'closedByUserId',
    deletedAt: 'deletedAt'
  };

  export type PayrollPeriodScalarFieldEnum = (typeof PayrollPeriodScalarFieldEnum)[keyof typeof PayrollPeriodScalarFieldEnum]


  export const PayrollLineScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    payrollPeriodId: 'payrollPeriodId',
    employeeId: 'employeeId',
    workedDays: 'workedDays',
    absentDays: 'absentDays',
    lateMinutes: 'lateMinutes',
    overtimeHours: 'overtimeHours',
    grossSalary: 'grossSalary',
    deductions: 'deductions',
    netSalary: 'netSalary',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt'
  };

  export type PayrollLineScalarFieldEnum = (typeof PayrollLineScalarFieldEnum)[keyof typeof PayrollLineScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'CompanyType'
   */
  export type EnumCompanyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyType'>
    


  /**
   * Reference to a field of type 'CompanyType[]'
   */
  export type ListEnumCompanyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'OvertimeStatus'
   */
  export type EnumOvertimeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OvertimeStatus'>
    


  /**
   * Reference to a field of type 'OvertimeStatus[]'
   */
  export type ListEnumOvertimeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OvertimeStatus[]'>
    


  /**
   * Reference to a field of type 'PayrollStatus'
   */
  export type EnumPayrollStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollStatus'>
    


  /**
   * Reference to a field of type 'PayrollStatus[]'
   */
  export type ListEnumPayrollStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollStatus[]'>
    


  /**
   * Reference to a field of type 'ExportFormat'
   */
  export type EnumExportFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExportFormat'>
    


  /**
   * Reference to a field of type 'ExportFormat[]'
   */
  export type ListEnumExportFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExportFormat[]'>
    


  /**
   * Reference to a field of type 'ReportType'
   */
  export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType'>
    


  /**
   * Reference to a field of type 'ReportType[]'
   */
  export type ListEnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'StudentAttendanceStatus'
   */
  export type EnumStudentAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentAttendanceStatus'>
    


  /**
   * Reference to a field of type 'StudentAttendanceStatus[]'
   */
  export type ListEnumStudentAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentAttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


  /**
   * Reference to a field of type 'AuditEntity'
   */
  export type EnumAuditEntityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditEntity'>
    


  /**
   * Reference to a field of type 'AuditEntity[]'
   */
  export type ListEnumAuditEntityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditEntity[]'>
    


  /**
   * Reference to a field of type 'AttendanceType'
   */
  export type EnumAttendanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceType'>
    


  /**
   * Reference to a field of type 'AttendanceType[]'
   */
  export type ListEnumAttendanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceType[]'>
    


  /**
   * Reference to a field of type 'PersonType'
   */
  export type EnumPersonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonType'>
    


  /**
   * Reference to a field of type 'PersonType[]'
   */
  export type ListEnumPersonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonType[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'LeaveStatus'
   */
  export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


  /**
   * Reference to a field of type 'LeaveStatus[]'
   */
  export type ListEnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus[]'>
    


  /**
   * Reference to a field of type 'SalaryType'
   */
  export type EnumSalaryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalaryType'>
    


  /**
   * Reference to a field of type 'SalaryType[]'
   */
  export type ListEnumSalaryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalaryType[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    code?: StringFilter<"Company"> | string
    type?: EnumCompanyTypeFilter<"Company"> | $Enums.CompanyType
    isActive?: BoolFilter<"Company"> | boolean
    deletedAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
    persons?: PersonListRelationFilter
    employees?: EmployeeListRelationFilter
    workers?: WorkerListRelationFilter
    attendance?: AttendanceListRelationFilter
    attendanceEvents?: AttendanceEventListRelationFilter
    attendanceDailySummaries?: AttendanceDailySummaryListRelationFilter
    schedules?: ScheduleListRelationFilter
    overtime?: OvertimeListRelationFilter
    attendanceSummaries?: AttendanceSummaryListRelationFilter
    payrolls?: PayrollListRelationFilter
    payrollPeriods?: PayrollPeriodListRelationFilter
    payrollLines?: PayrollLineListRelationFilter
    contracts?: ContractListRelationFilter
    payrollExports?: PayrollExportListRelationFilter
    reports?: ReportListRelationFilter
    schoolClasses?: SchoolClassListRelationFilter
    courses?: CourseListRelationFilter
    students?: StudentListRelationFilter
    studentAttendance?: StudentAttendanceListRelationFilter
    leaveTypes?: LeaveTypeListRelationFilter
    leaveBalances?: LeaveBalanceListRelationFilter
    leaveRequests?: LeaveRequestListRelationFilter
    publicHolidays?: PublicHolidayListRelationFilter
    constructionSites?: ConstructionSiteListRelationFilter
    constructionTeams?: ConstructionTeamListRelationFilter
    constructionWorkers?: ConstructionWorkerListRelationFilter
    siteAttendance?: SiteAttendanceListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    userRoles?: UserRoleListRelationFilter
    devices?: DeviceListRelationFilter
    periodClosures?: PeriodClosureListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    persons?: PersonOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    workers?: WorkerOrderByRelationAggregateInput
    attendance?: AttendanceOrderByRelationAggregateInput
    attendanceEvents?: AttendanceEventOrderByRelationAggregateInput
    attendanceDailySummaries?: AttendanceDailySummaryOrderByRelationAggregateInput
    schedules?: ScheduleOrderByRelationAggregateInput
    overtime?: OvertimeOrderByRelationAggregateInput
    attendanceSummaries?: AttendanceSummaryOrderByRelationAggregateInput
    payrolls?: PayrollOrderByRelationAggregateInput
    payrollPeriods?: PayrollPeriodOrderByRelationAggregateInput
    payrollLines?: PayrollLineOrderByRelationAggregateInput
    contracts?: ContractOrderByRelationAggregateInput
    payrollExports?: PayrollExportOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    schoolClasses?: SchoolClassOrderByRelationAggregateInput
    courses?: CourseOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    studentAttendance?: StudentAttendanceOrderByRelationAggregateInput
    leaveTypes?: LeaveTypeOrderByRelationAggregateInput
    leaveBalances?: LeaveBalanceOrderByRelationAggregateInput
    leaveRequests?: LeaveRequestOrderByRelationAggregateInput
    publicHolidays?: PublicHolidayOrderByRelationAggregateInput
    constructionSites?: ConstructionSiteOrderByRelationAggregateInput
    constructionTeams?: ConstructionTeamOrderByRelationAggregateInput
    constructionWorkers?: ConstructionWorkerOrderByRelationAggregateInput
    siteAttendance?: SiteAttendanceOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    userRoles?: UserRoleOrderByRelationAggregateInput
    devices?: DeviceOrderByRelationAggregateInput
    periodClosures?: PeriodClosureOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    type?: EnumCompanyTypeFilter<"Company"> | $Enums.CompanyType
    isActive?: BoolFilter<"Company"> | boolean
    deletedAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
    persons?: PersonListRelationFilter
    employees?: EmployeeListRelationFilter
    workers?: WorkerListRelationFilter
    attendance?: AttendanceListRelationFilter
    attendanceEvents?: AttendanceEventListRelationFilter
    attendanceDailySummaries?: AttendanceDailySummaryListRelationFilter
    schedules?: ScheduleListRelationFilter
    overtime?: OvertimeListRelationFilter
    attendanceSummaries?: AttendanceSummaryListRelationFilter
    payrolls?: PayrollListRelationFilter
    payrollPeriods?: PayrollPeriodListRelationFilter
    payrollLines?: PayrollLineListRelationFilter
    contracts?: ContractListRelationFilter
    payrollExports?: PayrollExportListRelationFilter
    reports?: ReportListRelationFilter
    schoolClasses?: SchoolClassListRelationFilter
    courses?: CourseListRelationFilter
    students?: StudentListRelationFilter
    studentAttendance?: StudentAttendanceListRelationFilter
    leaveTypes?: LeaveTypeListRelationFilter
    leaveBalances?: LeaveBalanceListRelationFilter
    leaveRequests?: LeaveRequestListRelationFilter
    publicHolidays?: PublicHolidayListRelationFilter
    constructionSites?: ConstructionSiteListRelationFilter
    constructionTeams?: ConstructionTeamListRelationFilter
    constructionWorkers?: ConstructionWorkerListRelationFilter
    siteAttendance?: SiteAttendanceListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    userRoles?: UserRoleListRelationFilter
    devices?: DeviceListRelationFilter
    periodClosures?: PeriodClosureListRelationFilter
  }, "id" | "code">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    code?: StringWithAggregatesFilter<"Company"> | string
    type?: EnumCompanyTypeWithAggregatesFilter<"Company"> | $Enums.CompanyType
    isActive?: BoolWithAggregatesFilter<"Company"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    roles?: EnumRoleNullableListFilter<"User">
    isActive?: BoolFilter<"User"> | boolean
    companyId?: StringFilter<"User"> | string
    personId?: StringNullableFilter<"User"> | string | null
    refreshTokenHash?: StringNullableFilter<"User"> | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    person?: XOR<PersonNullableScalarRelationFilter, PersonWhereInput> | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    userRoles?: UserRoleListRelationFilter
    attendance?: AttendanceListRelationFilter
    overtimeRequests?: OvertimeListRelationFilter
    overtimeApprovals?: OvertimeListRelationFilter
    studentAttendanceRecords?: StudentAttendanceListRelationFilter
    attendanceValidations?: AttendanceDailySummaryListRelationFilter
    leaveValidations?: LeaveRequestListRelationFilter
    payrollPeriodClosures?: PayrollPeriodListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    roles?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    personId?: SortOrderInput | SortOrder
    refreshTokenHash?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    person?: PersonOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    userRoles?: UserRoleOrderByRelationAggregateInput
    attendance?: AttendanceOrderByRelationAggregateInput
    overtimeRequests?: OvertimeOrderByRelationAggregateInput
    overtimeApprovals?: OvertimeOrderByRelationAggregateInput
    studentAttendanceRecords?: StudentAttendanceOrderByRelationAggregateInput
    attendanceValidations?: AttendanceDailySummaryOrderByRelationAggregateInput
    leaveValidations?: LeaveRequestOrderByRelationAggregateInput
    payrollPeriodClosures?: PayrollPeriodOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    personId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    roles?: EnumRoleNullableListFilter<"User">
    isActive?: BoolFilter<"User"> | boolean
    companyId?: StringFilter<"User"> | string
    refreshTokenHash?: StringNullableFilter<"User"> | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    person?: XOR<PersonNullableScalarRelationFilter, PersonWhereInput> | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    userRoles?: UserRoleListRelationFilter
    attendance?: AttendanceListRelationFilter
    overtimeRequests?: OvertimeListRelationFilter
    overtimeApprovals?: OvertimeListRelationFilter
    studentAttendanceRecords?: StudentAttendanceListRelationFilter
    attendanceValidations?: AttendanceDailySummaryListRelationFilter
    leaveValidations?: LeaveRequestListRelationFilter
    payrollPeriodClosures?: PayrollPeriodListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email" | "personId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    roles?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    personId?: SortOrderInput | SortOrder
    refreshTokenHash?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    roles?: EnumRoleNullableListFilter<"User">
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    companyId?: StringWithAggregatesFilter<"User"> | string
    personId?: StringNullableWithAggregatesFilter<"User"> | string | null
    refreshTokenHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    userId?: StringFilter<"Attendance"> | string
    companyId?: StringFilter<"Attendance"> | string
    checkInAt?: DateTimeFilter<"Attendance"> | Date | string
    checkOutAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    userId?: StringFilter<"Attendance"> | string
    companyId?: StringFilter<"Attendance"> | string
    checkInAt?: DateTimeFilter<"Attendance"> | Date | string
    checkOutAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    userId?: StringWithAggregatesFilter<"Attendance"> | string
    companyId?: StringWithAggregatesFilter<"Attendance"> | string
    checkInAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    checkOutAt?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: StringFilter<"Schedule"> | string
    companyId?: StringFilter<"Schedule"> | string
    name?: StringFilter<"Schedule"> | string
    startTime?: StringFilter<"Schedule"> | string
    endTime?: StringFilter<"Schedule"> | string
    daysOfWeek?: StringNullableListFilter<"Schedule">
    deletedAt?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    employees?: EmployeeListRelationFilter
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    daysOfWeek?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    companyId?: StringFilter<"Schedule"> | string
    name?: StringFilter<"Schedule"> | string
    startTime?: StringFilter<"Schedule"> | string
    endTime?: StringFilter<"Schedule"> | string
    daysOfWeek?: StringNullableListFilter<"Schedule">
    deletedAt?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    employees?: EmployeeListRelationFilter
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    daysOfWeek?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Schedule"> | string
    companyId?: StringWithAggregatesFilter<"Schedule"> | string
    name?: StringWithAggregatesFilter<"Schedule"> | string
    startTime?: StringWithAggregatesFilter<"Schedule"> | string
    endTime?: StringWithAggregatesFilter<"Schedule"> | string
    daysOfWeek?: StringNullableListFilter<"Schedule">
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Schedule"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
  }

  export type OvertimeWhereInput = {
    AND?: OvertimeWhereInput | OvertimeWhereInput[]
    OR?: OvertimeWhereInput[]
    NOT?: OvertimeWhereInput | OvertimeWhereInput[]
    id?: StringFilter<"Overtime"> | string
    companyId?: StringFilter<"Overtime"> | string
    userId?: StringFilter<"Overtime"> | string
    date?: DateTimeFilter<"Overtime"> | Date | string
    hours?: FloatFilter<"Overtime"> | number
    reason?: StringNullableFilter<"Overtime"> | string | null
    status?: EnumOvertimeStatusFilter<"Overtime"> | $Enums.OvertimeStatus
    approvedByUserId?: StringNullableFilter<"Overtime"> | string | null
    approvedAt?: DateTimeNullableFilter<"Overtime"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Overtime"> | Date | string | null
    createdAt?: DateTimeFilter<"Overtime"> | Date | string
    updatedAt?: DateTimeFilter<"Overtime"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type OvertimeOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    hours?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedByUserId?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
  }

  export type OvertimeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OvertimeWhereInput | OvertimeWhereInput[]
    OR?: OvertimeWhereInput[]
    NOT?: OvertimeWhereInput | OvertimeWhereInput[]
    companyId?: StringFilter<"Overtime"> | string
    userId?: StringFilter<"Overtime"> | string
    date?: DateTimeFilter<"Overtime"> | Date | string
    hours?: FloatFilter<"Overtime"> | number
    reason?: StringNullableFilter<"Overtime"> | string | null
    status?: EnumOvertimeStatusFilter<"Overtime"> | $Enums.OvertimeStatus
    approvedByUserId?: StringNullableFilter<"Overtime"> | string | null
    approvedAt?: DateTimeNullableFilter<"Overtime"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Overtime"> | Date | string | null
    createdAt?: DateTimeFilter<"Overtime"> | Date | string
    updatedAt?: DateTimeFilter<"Overtime"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type OvertimeOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    hours?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedByUserId?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OvertimeCountOrderByAggregateInput
    _avg?: OvertimeAvgOrderByAggregateInput
    _max?: OvertimeMaxOrderByAggregateInput
    _min?: OvertimeMinOrderByAggregateInput
    _sum?: OvertimeSumOrderByAggregateInput
  }

  export type OvertimeScalarWhereWithAggregatesInput = {
    AND?: OvertimeScalarWhereWithAggregatesInput | OvertimeScalarWhereWithAggregatesInput[]
    OR?: OvertimeScalarWhereWithAggregatesInput[]
    NOT?: OvertimeScalarWhereWithAggregatesInput | OvertimeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Overtime"> | string
    companyId?: StringWithAggregatesFilter<"Overtime"> | string
    userId?: StringWithAggregatesFilter<"Overtime"> | string
    date?: DateTimeWithAggregatesFilter<"Overtime"> | Date | string
    hours?: FloatWithAggregatesFilter<"Overtime"> | number
    reason?: StringNullableWithAggregatesFilter<"Overtime"> | string | null
    status?: EnumOvertimeStatusWithAggregatesFilter<"Overtime"> | $Enums.OvertimeStatus
    approvedByUserId?: StringNullableWithAggregatesFilter<"Overtime"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Overtime"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Overtime"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Overtime"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Overtime"> | Date | string
  }

  export type AttendanceSummaryWhereInput = {
    AND?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    OR?: AttendanceSummaryWhereInput[]
    NOT?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    id?: StringFilter<"AttendanceSummary"> | string
    companyId?: StringFilter<"AttendanceSummary"> | string
    periodStart?: DateTimeFilter<"AttendanceSummary"> | Date | string
    periodEnd?: DateTimeFilter<"AttendanceSummary"> | Date | string
    totalHours?: FloatFilter<"AttendanceSummary"> | number
    overtimeHours?: FloatFilter<"AttendanceSummary"> | number
    deletedAt?: DateTimeNullableFilter<"AttendanceSummary"> | Date | string | null
    createdAt?: DateTimeFilter<"AttendanceSummary"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceSummary"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    payrolls?: PayrollListRelationFilter
  }

  export type AttendanceSummaryOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalHours?: SortOrder
    overtimeHours?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    payrolls?: PayrollOrderByRelationAggregateInput
  }

  export type AttendanceSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    OR?: AttendanceSummaryWhereInput[]
    NOT?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    companyId?: StringFilter<"AttendanceSummary"> | string
    periodStart?: DateTimeFilter<"AttendanceSummary"> | Date | string
    periodEnd?: DateTimeFilter<"AttendanceSummary"> | Date | string
    totalHours?: FloatFilter<"AttendanceSummary"> | number
    overtimeHours?: FloatFilter<"AttendanceSummary"> | number
    deletedAt?: DateTimeNullableFilter<"AttendanceSummary"> | Date | string | null
    createdAt?: DateTimeFilter<"AttendanceSummary"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceSummary"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    payrolls?: PayrollListRelationFilter
  }, "id">

  export type AttendanceSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalHours?: SortOrder
    overtimeHours?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceSummaryCountOrderByAggregateInput
    _avg?: AttendanceSummaryAvgOrderByAggregateInput
    _max?: AttendanceSummaryMaxOrderByAggregateInput
    _min?: AttendanceSummaryMinOrderByAggregateInput
    _sum?: AttendanceSummarySumOrderByAggregateInput
  }

  export type AttendanceSummaryScalarWhereWithAggregatesInput = {
    AND?: AttendanceSummaryScalarWhereWithAggregatesInput | AttendanceSummaryScalarWhereWithAggregatesInput[]
    OR?: AttendanceSummaryScalarWhereWithAggregatesInput[]
    NOT?: AttendanceSummaryScalarWhereWithAggregatesInput | AttendanceSummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceSummary"> | string
    companyId?: StringWithAggregatesFilter<"AttendanceSummary"> | string
    periodStart?: DateTimeWithAggregatesFilter<"AttendanceSummary"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"AttendanceSummary"> | Date | string
    totalHours?: FloatWithAggregatesFilter<"AttendanceSummary"> | number
    overtimeHours?: FloatWithAggregatesFilter<"AttendanceSummary"> | number
    deletedAt?: DateTimeNullableWithAggregatesFilter<"AttendanceSummary"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceSummary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AttendanceSummary"> | Date | string
  }

  export type PayrollWhereInput = {
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    id?: StringFilter<"Payroll"> | string
    companyId?: StringFilter<"Payroll"> | string
    attendanceSummaryId?: StringFilter<"Payroll"> | string
    periodStart?: DateTimeFilter<"Payroll"> | Date | string
    periodEnd?: DateTimeFilter<"Payroll"> | Date | string
    grossPay?: FloatFilter<"Payroll"> | number
    netPay?: FloatFilter<"Payroll"> | number
    status?: EnumPayrollStatusFilter<"Payroll"> | $Enums.PayrollStatus
    deletedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    attendanceSummary?: XOR<AttendanceSummaryScalarRelationFilter, AttendanceSummaryWhereInput>
    exports?: PayrollExportListRelationFilter
  }

  export type PayrollOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    attendanceSummaryId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    grossPay?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    attendanceSummary?: AttendanceSummaryOrderByWithRelationInput
    exports?: PayrollExportOrderByRelationAggregateInput
  }

  export type PayrollWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    companyId?: StringFilter<"Payroll"> | string
    attendanceSummaryId?: StringFilter<"Payroll"> | string
    periodStart?: DateTimeFilter<"Payroll"> | Date | string
    periodEnd?: DateTimeFilter<"Payroll"> | Date | string
    grossPay?: FloatFilter<"Payroll"> | number
    netPay?: FloatFilter<"Payroll"> | number
    status?: EnumPayrollStatusFilter<"Payroll"> | $Enums.PayrollStatus
    deletedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    attendanceSummary?: XOR<AttendanceSummaryScalarRelationFilter, AttendanceSummaryWhereInput>
    exports?: PayrollExportListRelationFilter
  }, "id">

  export type PayrollOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    attendanceSummaryId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    grossPay?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollCountOrderByAggregateInput
    _avg?: PayrollAvgOrderByAggregateInput
    _max?: PayrollMaxOrderByAggregateInput
    _min?: PayrollMinOrderByAggregateInput
    _sum?: PayrollSumOrderByAggregateInput
  }

  export type PayrollScalarWhereWithAggregatesInput = {
    AND?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    OR?: PayrollScalarWhereWithAggregatesInput[]
    NOT?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payroll"> | string
    companyId?: StringWithAggregatesFilter<"Payroll"> | string
    attendanceSummaryId?: StringWithAggregatesFilter<"Payroll"> | string
    periodStart?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    grossPay?: FloatWithAggregatesFilter<"Payroll"> | number
    netPay?: FloatWithAggregatesFilter<"Payroll"> | number
    status?: EnumPayrollStatusWithAggregatesFilter<"Payroll"> | $Enums.PayrollStatus
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Payroll"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
  }

  export type PayrollExportWhereInput = {
    AND?: PayrollExportWhereInput | PayrollExportWhereInput[]
    OR?: PayrollExportWhereInput[]
    NOT?: PayrollExportWhereInput | PayrollExportWhereInput[]
    id?: StringFilter<"PayrollExport"> | string
    companyId?: StringFilter<"PayrollExport"> | string
    payrollId?: StringFilter<"PayrollExport"> | string
    format?: EnumExportFormatFilter<"PayrollExport"> | $Enums.ExportFormat
    path?: StringFilter<"PayrollExport"> | string
    deletedAt?: DateTimeNullableFilter<"PayrollExport"> | Date | string | null
    createdAt?: DateTimeFilter<"PayrollExport"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollExport"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    payroll?: XOR<PayrollScalarRelationFilter, PayrollWhereInput>
  }

  export type PayrollExportOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    payrollId?: SortOrder
    format?: SortOrder
    path?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    payroll?: PayrollOrderByWithRelationInput
  }

  export type PayrollExportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayrollExportWhereInput | PayrollExportWhereInput[]
    OR?: PayrollExportWhereInput[]
    NOT?: PayrollExportWhereInput | PayrollExportWhereInput[]
    companyId?: StringFilter<"PayrollExport"> | string
    payrollId?: StringFilter<"PayrollExport"> | string
    format?: EnumExportFormatFilter<"PayrollExport"> | $Enums.ExportFormat
    path?: StringFilter<"PayrollExport"> | string
    deletedAt?: DateTimeNullableFilter<"PayrollExport"> | Date | string | null
    createdAt?: DateTimeFilter<"PayrollExport"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollExport"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    payroll?: XOR<PayrollScalarRelationFilter, PayrollWhereInput>
  }, "id">

  export type PayrollExportOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    payrollId?: SortOrder
    format?: SortOrder
    path?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollExportCountOrderByAggregateInput
    _max?: PayrollExportMaxOrderByAggregateInput
    _min?: PayrollExportMinOrderByAggregateInput
  }

  export type PayrollExportScalarWhereWithAggregatesInput = {
    AND?: PayrollExportScalarWhereWithAggregatesInput | PayrollExportScalarWhereWithAggregatesInput[]
    OR?: PayrollExportScalarWhereWithAggregatesInput[]
    NOT?: PayrollExportScalarWhereWithAggregatesInput | PayrollExportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PayrollExport"> | string
    companyId?: StringWithAggregatesFilter<"PayrollExport"> | string
    payrollId?: StringWithAggregatesFilter<"PayrollExport"> | string
    format?: EnumExportFormatWithAggregatesFilter<"PayrollExport"> | $Enums.ExportFormat
    path?: StringWithAggregatesFilter<"PayrollExport"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PayrollExport"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PayrollExport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PayrollExport"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    companyId?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    periodStart?: DateTimeFilter<"Report"> | Date | string
    periodEnd?: DateTimeFilter<"Report"> | Date | string
    data?: JsonFilter<"Report">
    deletedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    data?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    companyId?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    periodStart?: DateTimeFilter<"Report"> | Date | string
    periodEnd?: DateTimeFilter<"Report"> | Date | string
    data?: JsonFilter<"Report">
    deletedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    data?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    companyId?: StringWithAggregatesFilter<"Report"> | string
    type?: EnumReportTypeWithAggregatesFilter<"Report"> | $Enums.ReportType
    periodStart?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    data?: JsonWithAggregatesFilter<"Report">
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type PeriodClosureWhereInput = {
    AND?: PeriodClosureWhereInput | PeriodClosureWhereInput[]
    OR?: PeriodClosureWhereInput[]
    NOT?: PeriodClosureWhereInput | PeriodClosureWhereInput[]
    id?: StringFilter<"PeriodClosure"> | string
    companyId?: StringFilter<"PeriodClosure"> | string
    periodStart?: DateTimeFilter<"PeriodClosure"> | Date | string
    periodEnd?: DateTimeFilter<"PeriodClosure"> | Date | string
    closedAt?: DateTimeFilter<"PeriodClosure"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type PeriodClosureOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    closedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type PeriodClosureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PeriodClosureWhereInput | PeriodClosureWhereInput[]
    OR?: PeriodClosureWhereInput[]
    NOT?: PeriodClosureWhereInput | PeriodClosureWhereInput[]
    companyId?: StringFilter<"PeriodClosure"> | string
    periodStart?: DateTimeFilter<"PeriodClosure"> | Date | string
    periodEnd?: DateTimeFilter<"PeriodClosure"> | Date | string
    closedAt?: DateTimeFilter<"PeriodClosure"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id">

  export type PeriodClosureOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    closedAt?: SortOrder
    _count?: PeriodClosureCountOrderByAggregateInput
    _max?: PeriodClosureMaxOrderByAggregateInput
    _min?: PeriodClosureMinOrderByAggregateInput
  }

  export type PeriodClosureScalarWhereWithAggregatesInput = {
    AND?: PeriodClosureScalarWhereWithAggregatesInput | PeriodClosureScalarWhereWithAggregatesInput[]
    OR?: PeriodClosureScalarWhereWithAggregatesInput[]
    NOT?: PeriodClosureScalarWhereWithAggregatesInput | PeriodClosureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PeriodClosure"> | string
    companyId?: StringWithAggregatesFilter<"PeriodClosure"> | string
    periodStart?: DateTimeWithAggregatesFilter<"PeriodClosure"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"PeriodClosure"> | Date | string
    closedAt?: DateTimeWithAggregatesFilter<"PeriodClosure"> | Date | string
  }

  export type SchoolClassWhereInput = {
    AND?: SchoolClassWhereInput | SchoolClassWhereInput[]
    OR?: SchoolClassWhereInput[]
    NOT?: SchoolClassWhereInput | SchoolClassWhereInput[]
    id?: StringFilter<"SchoolClass"> | string
    companyId?: StringFilter<"SchoolClass"> | string
    name?: StringFilter<"SchoolClass"> | string
    code?: StringFilter<"SchoolClass"> | string
    deletedAt?: DateTimeNullableFilter<"SchoolClass"> | Date | string | null
    createdAt?: DateTimeFilter<"SchoolClass"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolClass"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    courses?: CourseListRelationFilter
    students?: StudentListRelationFilter
  }

  export type SchoolClassOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    courses?: CourseOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
  }

  export type SchoolClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_code?: SchoolClassCompanyIdCodeCompoundUniqueInput
    AND?: SchoolClassWhereInput | SchoolClassWhereInput[]
    OR?: SchoolClassWhereInput[]
    NOT?: SchoolClassWhereInput | SchoolClassWhereInput[]
    companyId?: StringFilter<"SchoolClass"> | string
    name?: StringFilter<"SchoolClass"> | string
    code?: StringFilter<"SchoolClass"> | string
    deletedAt?: DateTimeNullableFilter<"SchoolClass"> | Date | string | null
    createdAt?: DateTimeFilter<"SchoolClass"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolClass"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    courses?: CourseListRelationFilter
    students?: StudentListRelationFilter
  }, "id" | "companyId_code">

  export type SchoolClassOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolClassCountOrderByAggregateInput
    _max?: SchoolClassMaxOrderByAggregateInput
    _min?: SchoolClassMinOrderByAggregateInput
  }

  export type SchoolClassScalarWhereWithAggregatesInput = {
    AND?: SchoolClassScalarWhereWithAggregatesInput | SchoolClassScalarWhereWithAggregatesInput[]
    OR?: SchoolClassScalarWhereWithAggregatesInput[]
    NOT?: SchoolClassScalarWhereWithAggregatesInput | SchoolClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolClass"> | string
    companyId?: StringWithAggregatesFilter<"SchoolClass"> | string
    name?: StringWithAggregatesFilter<"SchoolClass"> | string
    code?: StringWithAggregatesFilter<"SchoolClass"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"SchoolClass"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SchoolClass"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolClass"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    companyId?: StringFilter<"Course"> | string
    classId?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    deletedAt?: DateTimeNullableFilter<"Course"> | Date | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    class?: XOR<SchoolClassScalarRelationFilter, SchoolClassWhereInput>
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    class?: SchoolClassOrderByWithRelationInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_code?: CourseCompanyIdCodeCompoundUniqueInput
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    companyId?: StringFilter<"Course"> | string
    classId?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    deletedAt?: DateTimeNullableFilter<"Course"> | Date | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    class?: XOR<SchoolClassScalarRelationFilter, SchoolClassWhereInput>
  }, "id" | "companyId_code">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    companyId?: StringWithAggregatesFilter<"Course"> | string
    classId?: StringWithAggregatesFilter<"Course"> | string
    name?: StringWithAggregatesFilter<"Course"> | string
    code?: StringWithAggregatesFilter<"Course"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Course"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    companyId?: StringFilter<"Student"> | string
    classId?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    email?: StringNullableFilter<"Student"> | string | null
    personId?: StringNullableFilter<"Student"> | string | null
    deletedAt?: DateTimeNullableFilter<"Student"> | Date | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    class?: XOR<SchoolClassScalarRelationFilter, SchoolClassWhereInput>
    person?: XOR<PersonNullableScalarRelationFilter, PersonWhereInput> | null
    attendance?: StudentAttendanceListRelationFilter
    attendanceEvents?: AttendanceEventListRelationFilter
    dailySummaries?: AttendanceDailySummaryListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    classId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    personId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    class?: SchoolClassOrderByWithRelationInput
    person?: PersonOrderByWithRelationInput
    attendance?: StudentAttendanceOrderByRelationAggregateInput
    attendanceEvents?: AttendanceEventOrderByRelationAggregateInput
    dailySummaries?: AttendanceDailySummaryOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    personId?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    companyId?: StringFilter<"Student"> | string
    classId?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    email?: StringNullableFilter<"Student"> | string | null
    deletedAt?: DateTimeNullableFilter<"Student"> | Date | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    class?: XOR<SchoolClassScalarRelationFilter, SchoolClassWhereInput>
    person?: XOR<PersonNullableScalarRelationFilter, PersonWhereInput> | null
    attendance?: StudentAttendanceListRelationFilter
    attendanceEvents?: AttendanceEventListRelationFilter
    dailySummaries?: AttendanceDailySummaryListRelationFilter
  }, "id" | "personId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    classId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    personId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    companyId?: StringWithAggregatesFilter<"Student"> | string
    classId?: StringWithAggregatesFilter<"Student"> | string
    firstName?: StringWithAggregatesFilter<"Student"> | string
    lastName?: StringWithAggregatesFilter<"Student"> | string
    email?: StringNullableWithAggregatesFilter<"Student"> | string | null
    personId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Student"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type StudentAttendanceWhereInput = {
    AND?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    OR?: StudentAttendanceWhereInput[]
    NOT?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    id?: StringFilter<"StudentAttendance"> | string
    companyId?: StringFilter<"StudentAttendance"> | string
    studentId?: StringFilter<"StudentAttendance"> | string
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: EnumStudentAttendanceStatusFilter<"StudentAttendance"> | $Enums.StudentAttendanceStatus
    note?: StringNullableFilter<"StudentAttendance"> | string | null
    recordedByUserId?: StringNullableFilter<"StudentAttendance"> | string | null
    deletedAt?: DateTimeNullableFilter<"StudentAttendance"> | Date | string | null
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    recordedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type StudentAttendanceOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    recordedByUserId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    recordedBy?: UserOrderByWithRelationInput
  }

  export type StudentAttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_date?: StudentAttendanceStudentIdDateCompoundUniqueInput
    AND?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    OR?: StudentAttendanceWhereInput[]
    NOT?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    companyId?: StringFilter<"StudentAttendance"> | string
    studentId?: StringFilter<"StudentAttendance"> | string
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: EnumStudentAttendanceStatusFilter<"StudentAttendance"> | $Enums.StudentAttendanceStatus
    note?: StringNullableFilter<"StudentAttendance"> | string | null
    recordedByUserId?: StringNullableFilter<"StudentAttendance"> | string | null
    deletedAt?: DateTimeNullableFilter<"StudentAttendance"> | Date | string | null
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    recordedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "studentId_date">

  export type StudentAttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    recordedByUserId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentAttendanceCountOrderByAggregateInput
    _max?: StudentAttendanceMaxOrderByAggregateInput
    _min?: StudentAttendanceMinOrderByAggregateInput
  }

  export type StudentAttendanceScalarWhereWithAggregatesInput = {
    AND?: StudentAttendanceScalarWhereWithAggregatesInput | StudentAttendanceScalarWhereWithAggregatesInput[]
    OR?: StudentAttendanceScalarWhereWithAggregatesInput[]
    NOT?: StudentAttendanceScalarWhereWithAggregatesInput | StudentAttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentAttendance"> | string
    companyId?: StringWithAggregatesFilter<"StudentAttendance"> | string
    studentId?: StringWithAggregatesFilter<"StudentAttendance"> | string
    date?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
    status?: EnumStudentAttendanceStatusWithAggregatesFilter<"StudentAttendance"> | $Enums.StudentAttendanceStatus
    note?: StringNullableWithAggregatesFilter<"StudentAttendance"> | string | null
    recordedByUserId?: StringNullableWithAggregatesFilter<"StudentAttendance"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"StudentAttendance"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
  }

  export type ConstructionSiteWhereInput = {
    AND?: ConstructionSiteWhereInput | ConstructionSiteWhereInput[]
    OR?: ConstructionSiteWhereInput[]
    NOT?: ConstructionSiteWhereInput | ConstructionSiteWhereInput[]
    id?: StringFilter<"ConstructionSite"> | string
    companyId?: StringFilter<"ConstructionSite"> | string
    name?: StringFilter<"ConstructionSite"> | string
    location?: StringNullableFilter<"ConstructionSite"> | string | null
    latitude?: FloatNullableFilter<"ConstructionSite"> | number | null
    longitude?: FloatNullableFilter<"ConstructionSite"> | number | null
    deletedAt?: DateTimeNullableFilter<"ConstructionSite"> | Date | string | null
    createdAt?: DateTimeFilter<"ConstructionSite"> | Date | string
    updatedAt?: DateTimeFilter<"ConstructionSite"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    teams?: ConstructionTeamListRelationFilter
    attendance?: SiteAttendanceListRelationFilter
  }

  export type ConstructionSiteOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    teams?: ConstructionTeamOrderByRelationAggregateInput
    attendance?: SiteAttendanceOrderByRelationAggregateInput
  }

  export type ConstructionSiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConstructionSiteWhereInput | ConstructionSiteWhereInput[]
    OR?: ConstructionSiteWhereInput[]
    NOT?: ConstructionSiteWhereInput | ConstructionSiteWhereInput[]
    companyId?: StringFilter<"ConstructionSite"> | string
    name?: StringFilter<"ConstructionSite"> | string
    location?: StringNullableFilter<"ConstructionSite"> | string | null
    latitude?: FloatNullableFilter<"ConstructionSite"> | number | null
    longitude?: FloatNullableFilter<"ConstructionSite"> | number | null
    deletedAt?: DateTimeNullableFilter<"ConstructionSite"> | Date | string | null
    createdAt?: DateTimeFilter<"ConstructionSite"> | Date | string
    updatedAt?: DateTimeFilter<"ConstructionSite"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    teams?: ConstructionTeamListRelationFilter
    attendance?: SiteAttendanceListRelationFilter
  }, "id">

  export type ConstructionSiteOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConstructionSiteCountOrderByAggregateInput
    _avg?: ConstructionSiteAvgOrderByAggregateInput
    _max?: ConstructionSiteMaxOrderByAggregateInput
    _min?: ConstructionSiteMinOrderByAggregateInput
    _sum?: ConstructionSiteSumOrderByAggregateInput
  }

  export type ConstructionSiteScalarWhereWithAggregatesInput = {
    AND?: ConstructionSiteScalarWhereWithAggregatesInput | ConstructionSiteScalarWhereWithAggregatesInput[]
    OR?: ConstructionSiteScalarWhereWithAggregatesInput[]
    NOT?: ConstructionSiteScalarWhereWithAggregatesInput | ConstructionSiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConstructionSite"> | string
    companyId?: StringWithAggregatesFilter<"ConstructionSite"> | string
    name?: StringWithAggregatesFilter<"ConstructionSite"> | string
    location?: StringNullableWithAggregatesFilter<"ConstructionSite"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"ConstructionSite"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"ConstructionSite"> | number | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ConstructionSite"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConstructionSite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConstructionSite"> | Date | string
  }

  export type ConstructionTeamWhereInput = {
    AND?: ConstructionTeamWhereInput | ConstructionTeamWhereInput[]
    OR?: ConstructionTeamWhereInput[]
    NOT?: ConstructionTeamWhereInput | ConstructionTeamWhereInput[]
    id?: StringFilter<"ConstructionTeam"> | string
    companyId?: StringFilter<"ConstructionTeam"> | string
    siteId?: StringFilter<"ConstructionTeam"> | string
    name?: StringFilter<"ConstructionTeam"> | string
    deletedAt?: DateTimeNullableFilter<"ConstructionTeam"> | Date | string | null
    createdAt?: DateTimeFilter<"ConstructionTeam"> | Date | string
    updatedAt?: DateTimeFilter<"ConstructionTeam"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    site?: XOR<ConstructionSiteScalarRelationFilter, ConstructionSiteWhereInput>
    workers?: ConstructionWorkerListRelationFilter
  }

  export type ConstructionTeamOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    site?: ConstructionSiteOrderByWithRelationInput
    workers?: ConstructionWorkerOrderByRelationAggregateInput
  }

  export type ConstructionTeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConstructionTeamWhereInput | ConstructionTeamWhereInput[]
    OR?: ConstructionTeamWhereInput[]
    NOT?: ConstructionTeamWhereInput | ConstructionTeamWhereInput[]
    companyId?: StringFilter<"ConstructionTeam"> | string
    siteId?: StringFilter<"ConstructionTeam"> | string
    name?: StringFilter<"ConstructionTeam"> | string
    deletedAt?: DateTimeNullableFilter<"ConstructionTeam"> | Date | string | null
    createdAt?: DateTimeFilter<"ConstructionTeam"> | Date | string
    updatedAt?: DateTimeFilter<"ConstructionTeam"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    site?: XOR<ConstructionSiteScalarRelationFilter, ConstructionSiteWhereInput>
    workers?: ConstructionWorkerListRelationFilter
  }, "id">

  export type ConstructionTeamOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConstructionTeamCountOrderByAggregateInput
    _max?: ConstructionTeamMaxOrderByAggregateInput
    _min?: ConstructionTeamMinOrderByAggregateInput
  }

  export type ConstructionTeamScalarWhereWithAggregatesInput = {
    AND?: ConstructionTeamScalarWhereWithAggregatesInput | ConstructionTeamScalarWhereWithAggregatesInput[]
    OR?: ConstructionTeamScalarWhereWithAggregatesInput[]
    NOT?: ConstructionTeamScalarWhereWithAggregatesInput | ConstructionTeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConstructionTeam"> | string
    companyId?: StringWithAggregatesFilter<"ConstructionTeam"> | string
    siteId?: StringWithAggregatesFilter<"ConstructionTeam"> | string
    name?: StringWithAggregatesFilter<"ConstructionTeam"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ConstructionTeam"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConstructionTeam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConstructionTeam"> | Date | string
  }

  export type ConstructionWorkerWhereInput = {
    AND?: ConstructionWorkerWhereInput | ConstructionWorkerWhereInput[]
    OR?: ConstructionWorkerWhereInput[]
    NOT?: ConstructionWorkerWhereInput | ConstructionWorkerWhereInput[]
    id?: StringFilter<"ConstructionWorker"> | string
    companyId?: StringFilter<"ConstructionWorker"> | string
    teamId?: StringFilter<"ConstructionWorker"> | string
    name?: StringFilter<"ConstructionWorker"> | string
    email?: StringNullableFilter<"ConstructionWorker"> | string | null
    personId?: StringNullableFilter<"ConstructionWorker"> | string | null
    deletedAt?: DateTimeNullableFilter<"ConstructionWorker"> | Date | string | null
    createdAt?: DateTimeFilter<"ConstructionWorker"> | Date | string
    updatedAt?: DateTimeFilter<"ConstructionWorker"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    team?: XOR<ConstructionTeamScalarRelationFilter, ConstructionTeamWhereInput>
    person?: XOR<PersonNullableScalarRelationFilter, PersonWhereInput> | null
    attendance?: SiteAttendanceListRelationFilter
  }

  export type ConstructionWorkerOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    personId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    team?: ConstructionTeamOrderByWithRelationInput
    person?: PersonOrderByWithRelationInput
    attendance?: SiteAttendanceOrderByRelationAggregateInput
  }

  export type ConstructionWorkerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    personId?: string
    AND?: ConstructionWorkerWhereInput | ConstructionWorkerWhereInput[]
    OR?: ConstructionWorkerWhereInput[]
    NOT?: ConstructionWorkerWhereInput | ConstructionWorkerWhereInput[]
    companyId?: StringFilter<"ConstructionWorker"> | string
    teamId?: StringFilter<"ConstructionWorker"> | string
    name?: StringFilter<"ConstructionWorker"> | string
    email?: StringNullableFilter<"ConstructionWorker"> | string | null
    deletedAt?: DateTimeNullableFilter<"ConstructionWorker"> | Date | string | null
    createdAt?: DateTimeFilter<"ConstructionWorker"> | Date | string
    updatedAt?: DateTimeFilter<"ConstructionWorker"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    team?: XOR<ConstructionTeamScalarRelationFilter, ConstructionTeamWhereInput>
    person?: XOR<PersonNullableScalarRelationFilter, PersonWhereInput> | null
    attendance?: SiteAttendanceListRelationFilter
  }, "id" | "personId">

  export type ConstructionWorkerOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    personId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConstructionWorkerCountOrderByAggregateInput
    _max?: ConstructionWorkerMaxOrderByAggregateInput
    _min?: ConstructionWorkerMinOrderByAggregateInput
  }

  export type ConstructionWorkerScalarWhereWithAggregatesInput = {
    AND?: ConstructionWorkerScalarWhereWithAggregatesInput | ConstructionWorkerScalarWhereWithAggregatesInput[]
    OR?: ConstructionWorkerScalarWhereWithAggregatesInput[]
    NOT?: ConstructionWorkerScalarWhereWithAggregatesInput | ConstructionWorkerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConstructionWorker"> | string
    companyId?: StringWithAggregatesFilter<"ConstructionWorker"> | string
    teamId?: StringWithAggregatesFilter<"ConstructionWorker"> | string
    name?: StringWithAggregatesFilter<"ConstructionWorker"> | string
    email?: StringNullableWithAggregatesFilter<"ConstructionWorker"> | string | null
    personId?: StringNullableWithAggregatesFilter<"ConstructionWorker"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ConstructionWorker"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConstructionWorker"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConstructionWorker"> | Date | string
  }

  export type SiteAttendanceWhereInput = {
    AND?: SiteAttendanceWhereInput | SiteAttendanceWhereInput[]
    OR?: SiteAttendanceWhereInput[]
    NOT?: SiteAttendanceWhereInput | SiteAttendanceWhereInput[]
    id?: StringFilter<"SiteAttendance"> | string
    companyId?: StringFilter<"SiteAttendance"> | string
    siteId?: StringFilter<"SiteAttendance"> | string
    workerId?: StringFilter<"SiteAttendance"> | string
    date?: DateTimeFilter<"SiteAttendance"> | Date | string
    checkInAt?: DateTimeFilter<"SiteAttendance"> | Date | string
    checkOutAt?: DateTimeNullableFilter<"SiteAttendance"> | Date | string | null
    latitude?: FloatNullableFilter<"SiteAttendance"> | number | null
    longitude?: FloatNullableFilter<"SiteAttendance"> | number | null
    deletedAt?: DateTimeNullableFilter<"SiteAttendance"> | Date | string | null
    createdAt?: DateTimeFilter<"SiteAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"SiteAttendance"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    site?: XOR<ConstructionSiteScalarRelationFilter, ConstructionSiteWhereInput>
    worker?: XOR<ConstructionWorkerScalarRelationFilter, ConstructionWorkerWhereInput>
  }

  export type SiteAttendanceOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    siteId?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    site?: ConstructionSiteOrderByWithRelationInput
    worker?: ConstructionWorkerOrderByWithRelationInput
  }

  export type SiteAttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workerId_date?: SiteAttendanceWorkerIdDateCompoundUniqueInput
    AND?: SiteAttendanceWhereInput | SiteAttendanceWhereInput[]
    OR?: SiteAttendanceWhereInput[]
    NOT?: SiteAttendanceWhereInput | SiteAttendanceWhereInput[]
    companyId?: StringFilter<"SiteAttendance"> | string
    siteId?: StringFilter<"SiteAttendance"> | string
    workerId?: StringFilter<"SiteAttendance"> | string
    date?: DateTimeFilter<"SiteAttendance"> | Date | string
    checkInAt?: DateTimeFilter<"SiteAttendance"> | Date | string
    checkOutAt?: DateTimeNullableFilter<"SiteAttendance"> | Date | string | null
    latitude?: FloatNullableFilter<"SiteAttendance"> | number | null
    longitude?: FloatNullableFilter<"SiteAttendance"> | number | null
    deletedAt?: DateTimeNullableFilter<"SiteAttendance"> | Date | string | null
    createdAt?: DateTimeFilter<"SiteAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"SiteAttendance"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    site?: XOR<ConstructionSiteScalarRelationFilter, ConstructionSiteWhereInput>
    worker?: XOR<ConstructionWorkerScalarRelationFilter, ConstructionWorkerWhereInput>
  }, "id" | "workerId_date">

  export type SiteAttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    siteId?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SiteAttendanceCountOrderByAggregateInput
    _avg?: SiteAttendanceAvgOrderByAggregateInput
    _max?: SiteAttendanceMaxOrderByAggregateInput
    _min?: SiteAttendanceMinOrderByAggregateInput
    _sum?: SiteAttendanceSumOrderByAggregateInput
  }

  export type SiteAttendanceScalarWhereWithAggregatesInput = {
    AND?: SiteAttendanceScalarWhereWithAggregatesInput | SiteAttendanceScalarWhereWithAggregatesInput[]
    OR?: SiteAttendanceScalarWhereWithAggregatesInput[]
    NOT?: SiteAttendanceScalarWhereWithAggregatesInput | SiteAttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SiteAttendance"> | string
    companyId?: StringWithAggregatesFilter<"SiteAttendance"> | string
    siteId?: StringWithAggregatesFilter<"SiteAttendance"> | string
    workerId?: StringWithAggregatesFilter<"SiteAttendance"> | string
    date?: DateTimeWithAggregatesFilter<"SiteAttendance"> | Date | string
    checkInAt?: DateTimeWithAggregatesFilter<"SiteAttendance"> | Date | string
    checkOutAt?: DateTimeNullableWithAggregatesFilter<"SiteAttendance"> | Date | string | null
    latitude?: FloatNullableWithAggregatesFilter<"SiteAttendance"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"SiteAttendance"> | number | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"SiteAttendance"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SiteAttendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SiteAttendance"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    companyId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    actionType?: EnumAuditActionNullableFilter<"AuditLog"> | $Enums.AuditAction | null
    entityType?: EnumAuditEntityNullableFilter<"AuditLog"> | $Enums.AuditEntity | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    data?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    companyId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    actionType?: EnumAuditActionNullableFilter<"AuditLog"> | $Enums.AuditAction | null
    entityType?: EnumAuditEntityNullableFilter<"AuditLog"> | $Enums.AuditEntity | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    data?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    companyId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    actionType?: EnumAuditActionNullableWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction | null
    entityType?: EnumAuditEntityNullableWithAggregatesFilter<"AuditLog"> | $Enums.AuditEntity | null
    ip?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    data?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: StringFilter<"UserRole"> | string
    companyId?: StringFilter<"UserRole"> | string
    role?: EnumRoleFilter<"UserRole"> | $Enums.Role
    userId?: StringFilter<"UserRole"> | string
    deletedAt?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_role?: UserRoleUserIdRoleCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    companyId?: StringFilter<"UserRole"> | string
    role?: EnumRoleFilter<"UserRole"> | $Enums.Role
    userId?: StringFilter<"UserRole"> | string
    deletedAt?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "userId_role">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRole"> | string
    companyId?: StringWithAggregatesFilter<"UserRole"> | string
    role?: EnumRoleWithAggregatesFilter<"UserRole"> | $Enums.Role
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"UserRole"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
  }

  export type PersonWhereInput = {
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    id?: StringFilter<"Person"> | string
    firstName?: StringFilter<"Person"> | string
    lastName?: StringFilter<"Person"> | string
    phone?: StringNullableFilter<"Person"> | string | null
    companyId?: StringFilter<"Person"> | string
    createdAt?: DateTimeFilter<"Person"> | Date | string
    updatedAt?: DateTimeFilter<"Person"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Person"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    worker?: XOR<WorkerNullableScalarRelationFilter, WorkerWhereInput> | null
    constructionWorker?: XOR<ConstructionWorkerNullableScalarRelationFilter, ConstructionWorkerWhereInput> | null
    devices?: DeviceListRelationFilter
  }

  export type PersonOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    worker?: WorkerOrderByWithRelationInput
    constructionWorker?: ConstructionWorkerOrderByWithRelationInput
    devices?: DeviceOrderByRelationAggregateInput
  }

  export type PersonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    firstName?: StringFilter<"Person"> | string
    lastName?: StringFilter<"Person"> | string
    phone?: StringNullableFilter<"Person"> | string | null
    companyId?: StringFilter<"Person"> | string
    createdAt?: DateTimeFilter<"Person"> | Date | string
    updatedAt?: DateTimeFilter<"Person"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Person"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    worker?: XOR<WorkerNullableScalarRelationFilter, WorkerWhereInput> | null
    constructionWorker?: XOR<ConstructionWorkerNullableScalarRelationFilter, ConstructionWorkerWhereInput> | null
    devices?: DeviceListRelationFilter
  }, "id">

  export type PersonOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PersonCountOrderByAggregateInput
    _max?: PersonMaxOrderByAggregateInput
    _min?: PersonMinOrderByAggregateInput
  }

  export type PersonScalarWhereWithAggregatesInput = {
    AND?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    OR?: PersonScalarWhereWithAggregatesInput[]
    NOT?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Person"> | string
    firstName?: StringWithAggregatesFilter<"Person"> | string
    lastName?: StringWithAggregatesFilter<"Person"> | string
    phone?: StringNullableWithAggregatesFilter<"Person"> | string | null
    companyId?: StringWithAggregatesFilter<"Person"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Person"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Person"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Person"> | Date | string | null
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    companyId?: StringFilter<"Employee"> | string
    personId?: StringFilter<"Employee"> | string
    userId?: StringNullableFilter<"Employee"> | string | null
    scheduleId?: StringNullableFilter<"Employee"> | string | null
    matricule?: StringNullableFilter<"Employee"> | string | null
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    schedule?: XOR<ScheduleNullableScalarRelationFilter, ScheduleWhereInput> | null
    attendances?: AttendanceEventListRelationFilter
    dailySummaries?: AttendanceDailySummaryListRelationFilter
    payrollLines?: PayrollLineListRelationFilter
    contracts?: ContractListRelationFilter
    leaveBalances?: LeaveBalanceListRelationFilter
    leaveRequests?: LeaveRequestListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    personId?: SortOrder
    userId?: SortOrderInput | SortOrder
    scheduleId?: SortOrderInput | SortOrder
    matricule?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    person?: PersonOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    schedule?: ScheduleOrderByWithRelationInput
    attendances?: AttendanceEventOrderByRelationAggregateInput
    dailySummaries?: AttendanceDailySummaryOrderByRelationAggregateInput
    payrollLines?: PayrollLineOrderByRelationAggregateInput
    contracts?: ContractOrderByRelationAggregateInput
    leaveBalances?: LeaveBalanceOrderByRelationAggregateInput
    leaveRequests?: LeaveRequestOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    personId?: string
    userId?: string
    matricule?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    companyId?: StringFilter<"Employee"> | string
    scheduleId?: StringNullableFilter<"Employee"> | string | null
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    schedule?: XOR<ScheduleNullableScalarRelationFilter, ScheduleWhereInput> | null
    attendances?: AttendanceEventListRelationFilter
    dailySummaries?: AttendanceDailySummaryListRelationFilter
    payrollLines?: PayrollLineListRelationFilter
    contracts?: ContractListRelationFilter
    leaveBalances?: LeaveBalanceListRelationFilter
    leaveRequests?: LeaveRequestListRelationFilter
  }, "id" | "personId" | "userId" | "matricule">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    personId?: SortOrder
    userId?: SortOrderInput | SortOrder
    scheduleId?: SortOrderInput | SortOrder
    matricule?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    companyId?: StringWithAggregatesFilter<"Employee"> | string
    personId?: StringWithAggregatesFilter<"Employee"> | string
    userId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    scheduleId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    matricule?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type WorkerWhereInput = {
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    id?: StringFilter<"Worker"> | string
    companyId?: StringFilter<"Worker"> | string
    personId?: StringFilter<"Worker"> | string
    deletedAt?: DateTimeNullableFilter<"Worker"> | Date | string | null
    createdAt?: DateTimeFilter<"Worker"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    attendances?: AttendanceEventListRelationFilter
    dailySummaries?: AttendanceDailySummaryListRelationFilter
  }

  export type WorkerOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    personId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    person?: PersonOrderByWithRelationInput
    attendances?: AttendanceEventOrderByRelationAggregateInput
    dailySummaries?: AttendanceDailySummaryOrderByRelationAggregateInput
  }

  export type WorkerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    personId?: string
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    companyId?: StringFilter<"Worker"> | string
    deletedAt?: DateTimeNullableFilter<"Worker"> | Date | string | null
    createdAt?: DateTimeFilter<"Worker"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    attendances?: AttendanceEventListRelationFilter
    dailySummaries?: AttendanceDailySummaryListRelationFilter
  }, "id" | "personId">

  export type WorkerOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    personId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WorkerCountOrderByAggregateInput
    _max?: WorkerMaxOrderByAggregateInput
    _min?: WorkerMinOrderByAggregateInput
  }

  export type WorkerScalarWhereWithAggregatesInput = {
    AND?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    OR?: WorkerScalarWhereWithAggregatesInput[]
    NOT?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Worker"> | string
    companyId?: StringWithAggregatesFilter<"Worker"> | string
    personId?: StringWithAggregatesFilter<"Worker"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Worker"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Worker"> | Date | string
  }

  export type AttendanceEventWhereInput = {
    AND?: AttendanceEventWhereInput | AttendanceEventWhereInput[]
    OR?: AttendanceEventWhereInput[]
    NOT?: AttendanceEventWhereInput | AttendanceEventWhereInput[]
    id?: StringFilter<"AttendanceEvent"> | string
    companyId?: StringFilter<"AttendanceEvent"> | string
    type?: EnumAttendanceTypeFilter<"AttendanceEvent"> | $Enums.AttendanceType
    timestamp?: DateTimeFilter<"AttendanceEvent"> | Date | string
    date?: DateTimeFilter<"AttendanceEvent"> | Date | string
    personType?: EnumPersonTypeFilter<"AttendanceEvent"> | $Enums.PersonType
    employeeId?: StringNullableFilter<"AttendanceEvent"> | string | null
    studentId?: StringNullableFilter<"AttendanceEvent"> | string | null
    workerId?: StringNullableFilter<"AttendanceEvent"> | string | null
    deviceId?: StringNullableFilter<"AttendanceEvent"> | string | null
    createdAt?: DateTimeFilter<"AttendanceEvent"> | Date | string
    deletedAt?: DateTimeNullableFilter<"AttendanceEvent"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    worker?: XOR<WorkerNullableScalarRelationFilter, WorkerWhereInput> | null
    device?: XOR<DeviceNullableScalarRelationFilter, DeviceWhereInput> | null
  }

  export type AttendanceEventOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    date?: SortOrder
    personType?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    workerId?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    worker?: WorkerOrderByWithRelationInput
    device?: DeviceOrderByWithRelationInput
  }

  export type AttendanceEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceEventWhereInput | AttendanceEventWhereInput[]
    OR?: AttendanceEventWhereInput[]
    NOT?: AttendanceEventWhereInput | AttendanceEventWhereInput[]
    companyId?: StringFilter<"AttendanceEvent"> | string
    type?: EnumAttendanceTypeFilter<"AttendanceEvent"> | $Enums.AttendanceType
    timestamp?: DateTimeFilter<"AttendanceEvent"> | Date | string
    date?: DateTimeFilter<"AttendanceEvent"> | Date | string
    personType?: EnumPersonTypeFilter<"AttendanceEvent"> | $Enums.PersonType
    employeeId?: StringNullableFilter<"AttendanceEvent"> | string | null
    studentId?: StringNullableFilter<"AttendanceEvent"> | string | null
    workerId?: StringNullableFilter<"AttendanceEvent"> | string | null
    deviceId?: StringNullableFilter<"AttendanceEvent"> | string | null
    createdAt?: DateTimeFilter<"AttendanceEvent"> | Date | string
    deletedAt?: DateTimeNullableFilter<"AttendanceEvent"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    worker?: XOR<WorkerNullableScalarRelationFilter, WorkerWhereInput> | null
    device?: XOR<DeviceNullableScalarRelationFilter, DeviceWhereInput> | null
  }, "id">

  export type AttendanceEventOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    date?: SortOrder
    personType?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    workerId?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AttendanceEventCountOrderByAggregateInput
    _max?: AttendanceEventMaxOrderByAggregateInput
    _min?: AttendanceEventMinOrderByAggregateInput
  }

  export type AttendanceEventScalarWhereWithAggregatesInput = {
    AND?: AttendanceEventScalarWhereWithAggregatesInput | AttendanceEventScalarWhereWithAggregatesInput[]
    OR?: AttendanceEventScalarWhereWithAggregatesInput[]
    NOT?: AttendanceEventScalarWhereWithAggregatesInput | AttendanceEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceEvent"> | string
    companyId?: StringWithAggregatesFilter<"AttendanceEvent"> | string
    type?: EnumAttendanceTypeWithAggregatesFilter<"AttendanceEvent"> | $Enums.AttendanceType
    timestamp?: DateTimeWithAggregatesFilter<"AttendanceEvent"> | Date | string
    date?: DateTimeWithAggregatesFilter<"AttendanceEvent"> | Date | string
    personType?: EnumPersonTypeWithAggregatesFilter<"AttendanceEvent"> | $Enums.PersonType
    employeeId?: StringNullableWithAggregatesFilter<"AttendanceEvent"> | string | null
    studentId?: StringNullableWithAggregatesFilter<"AttendanceEvent"> | string | null
    workerId?: StringNullableWithAggregatesFilter<"AttendanceEvent"> | string | null
    deviceId?: StringNullableWithAggregatesFilter<"AttendanceEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceEvent"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"AttendanceEvent"> | Date | string | null
  }

  export type AttendanceDailySummaryWhereInput = {
    AND?: AttendanceDailySummaryWhereInput | AttendanceDailySummaryWhereInput[]
    OR?: AttendanceDailySummaryWhereInput[]
    NOT?: AttendanceDailySummaryWhereInput | AttendanceDailySummaryWhereInput[]
    id?: StringFilter<"AttendanceDailySummary"> | string
    companyId?: StringFilter<"AttendanceDailySummary"> | string
    date?: DateTimeFilter<"AttendanceDailySummary"> | Date | string
    status?: EnumAttendanceStatusFilter<"AttendanceDailySummary"> | $Enums.AttendanceStatus
    lateMinutes?: IntNullableFilter<"AttendanceDailySummary"> | number | null
    earlyMinutes?: IntNullableFilter<"AttendanceDailySummary"> | number | null
    workedMinutes?: IntNullableFilter<"AttendanceDailySummary"> | number | null
    employeeId?: StringNullableFilter<"AttendanceDailySummary"> | string | null
    studentId?: StringNullableFilter<"AttendanceDailySummary"> | string | null
    workerId?: StringNullableFilter<"AttendanceDailySummary"> | string | null
    validatedByUserId?: StringNullableFilter<"AttendanceDailySummary"> | string | null
    createdAt?: DateTimeFilter<"AttendanceDailySummary"> | Date | string
    deletedAt?: DateTimeNullableFilter<"AttendanceDailySummary"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    worker?: XOR<WorkerNullableScalarRelationFilter, WorkerWhereInput> | null
    validatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AttendanceDailySummaryOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateMinutes?: SortOrderInput | SortOrder
    earlyMinutes?: SortOrderInput | SortOrder
    workedMinutes?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    workerId?: SortOrderInput | SortOrder
    validatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    worker?: WorkerOrderByWithRelationInput
    validatedBy?: UserOrderByWithRelationInput
  }

  export type AttendanceDailySummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_date?: AttendanceDailySummaryEmployeeIdDateCompoundUniqueInput
    studentId_date?: AttendanceDailySummaryStudentIdDateCompoundUniqueInput
    workerId_date?: AttendanceDailySummaryWorkerIdDateCompoundUniqueInput
    AND?: AttendanceDailySummaryWhereInput | AttendanceDailySummaryWhereInput[]
    OR?: AttendanceDailySummaryWhereInput[]
    NOT?: AttendanceDailySummaryWhereInput | AttendanceDailySummaryWhereInput[]
    companyId?: StringFilter<"AttendanceDailySummary"> | string
    date?: DateTimeFilter<"AttendanceDailySummary"> | Date | string
    status?: EnumAttendanceStatusFilter<"AttendanceDailySummary"> | $Enums.AttendanceStatus
    lateMinutes?: IntNullableFilter<"AttendanceDailySummary"> | number | null
    earlyMinutes?: IntNullableFilter<"AttendanceDailySummary"> | number | null
    workedMinutes?: IntNullableFilter<"AttendanceDailySummary"> | number | null
    employeeId?: StringNullableFilter<"AttendanceDailySummary"> | string | null
    studentId?: StringNullableFilter<"AttendanceDailySummary"> | string | null
    workerId?: StringNullableFilter<"AttendanceDailySummary"> | string | null
    validatedByUserId?: StringNullableFilter<"AttendanceDailySummary"> | string | null
    createdAt?: DateTimeFilter<"AttendanceDailySummary"> | Date | string
    deletedAt?: DateTimeNullableFilter<"AttendanceDailySummary"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    worker?: XOR<WorkerNullableScalarRelationFilter, WorkerWhereInput> | null
    validatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "employeeId_date" | "studentId_date" | "workerId_date">

  export type AttendanceDailySummaryOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateMinutes?: SortOrderInput | SortOrder
    earlyMinutes?: SortOrderInput | SortOrder
    workedMinutes?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    workerId?: SortOrderInput | SortOrder
    validatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AttendanceDailySummaryCountOrderByAggregateInput
    _avg?: AttendanceDailySummaryAvgOrderByAggregateInput
    _max?: AttendanceDailySummaryMaxOrderByAggregateInput
    _min?: AttendanceDailySummaryMinOrderByAggregateInput
    _sum?: AttendanceDailySummarySumOrderByAggregateInput
  }

  export type AttendanceDailySummaryScalarWhereWithAggregatesInput = {
    AND?: AttendanceDailySummaryScalarWhereWithAggregatesInput | AttendanceDailySummaryScalarWhereWithAggregatesInput[]
    OR?: AttendanceDailySummaryScalarWhereWithAggregatesInput[]
    NOT?: AttendanceDailySummaryScalarWhereWithAggregatesInput | AttendanceDailySummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceDailySummary"> | string
    companyId?: StringWithAggregatesFilter<"AttendanceDailySummary"> | string
    date?: DateTimeWithAggregatesFilter<"AttendanceDailySummary"> | Date | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"AttendanceDailySummary"> | $Enums.AttendanceStatus
    lateMinutes?: IntNullableWithAggregatesFilter<"AttendanceDailySummary"> | number | null
    earlyMinutes?: IntNullableWithAggregatesFilter<"AttendanceDailySummary"> | number | null
    workedMinutes?: IntNullableWithAggregatesFilter<"AttendanceDailySummary"> | number | null
    employeeId?: StringNullableWithAggregatesFilter<"AttendanceDailySummary"> | string | null
    studentId?: StringNullableWithAggregatesFilter<"AttendanceDailySummary"> | string | null
    workerId?: StringNullableWithAggregatesFilter<"AttendanceDailySummary"> | string | null
    validatedByUserId?: StringNullableWithAggregatesFilter<"AttendanceDailySummary"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceDailySummary"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"AttendanceDailySummary"> | Date | string | null
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: StringFilter<"Device"> | string
    uuid?: StringFilter<"Device"> | string
    platform?: StringFilter<"Device"> | string
    model?: StringFilter<"Device"> | string
    personId?: StringFilter<"Device"> | string
    companyId?: StringFilter<"Device"> | string
    deletedAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    createdAt?: DateTimeFilter<"Device"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    attendanceEvents?: AttendanceEventListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    platform?: SortOrder
    model?: SortOrder
    personId?: SortOrder
    companyId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    person?: PersonOrderByWithRelationInput
    attendanceEvents?: AttendanceEventOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    platform?: StringFilter<"Device"> | string
    model?: StringFilter<"Device"> | string
    personId?: StringFilter<"Device"> | string
    companyId?: StringFilter<"Device"> | string
    deletedAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    createdAt?: DateTimeFilter<"Device"> | Date | string
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
    attendanceEvents?: AttendanceEventListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "uuid">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    platform?: SortOrder
    model?: SortOrder
    personId?: SortOrder
    companyId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Device"> | string
    uuid?: StringWithAggregatesFilter<"Device"> | string
    platform?: StringWithAggregatesFilter<"Device"> | string
    model?: StringWithAggregatesFilter<"Device"> | string
    personId?: StringWithAggregatesFilter<"Device"> | string
    companyId?: StringWithAggregatesFilter<"Device"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Device"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
  }

  export type LeaveTypeWhereInput = {
    AND?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    OR?: LeaveTypeWhereInput[]
    NOT?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    id?: StringFilter<"LeaveType"> | string
    companyId?: StringFilter<"LeaveType"> | string
    name?: StringFilter<"LeaveType"> | string
    code?: StringFilter<"LeaveType"> | string
    isPaid?: BoolFilter<"LeaveType"> | boolean
    maxDaysYear?: IntNullableFilter<"LeaveType"> | number | null
    createdAt?: DateTimeFilter<"LeaveType"> | Date | string
    deletedAt?: DateTimeNullableFilter<"LeaveType"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    balances?: LeaveBalanceListRelationFilter
    requests?: LeaveRequestListRelationFilter
  }

  export type LeaveTypeOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isPaid?: SortOrder
    maxDaysYear?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    balances?: LeaveBalanceOrderByRelationAggregateInput
    requests?: LeaveRequestOrderByRelationAggregateInput
  }

  export type LeaveTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_code?: LeaveTypeCompanyIdCodeCompoundUniqueInput
    AND?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    OR?: LeaveTypeWhereInput[]
    NOT?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    companyId?: StringFilter<"LeaveType"> | string
    name?: StringFilter<"LeaveType"> | string
    code?: StringFilter<"LeaveType"> | string
    isPaid?: BoolFilter<"LeaveType"> | boolean
    maxDaysYear?: IntNullableFilter<"LeaveType"> | number | null
    createdAt?: DateTimeFilter<"LeaveType"> | Date | string
    deletedAt?: DateTimeNullableFilter<"LeaveType"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    balances?: LeaveBalanceListRelationFilter
    requests?: LeaveRequestListRelationFilter
  }, "id" | "companyId_code">

  export type LeaveTypeOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isPaid?: SortOrder
    maxDaysYear?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: LeaveTypeCountOrderByAggregateInput
    _avg?: LeaveTypeAvgOrderByAggregateInput
    _max?: LeaveTypeMaxOrderByAggregateInput
    _min?: LeaveTypeMinOrderByAggregateInput
    _sum?: LeaveTypeSumOrderByAggregateInput
  }

  export type LeaveTypeScalarWhereWithAggregatesInput = {
    AND?: LeaveTypeScalarWhereWithAggregatesInput | LeaveTypeScalarWhereWithAggregatesInput[]
    OR?: LeaveTypeScalarWhereWithAggregatesInput[]
    NOT?: LeaveTypeScalarWhereWithAggregatesInput | LeaveTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveType"> | string
    companyId?: StringWithAggregatesFilter<"LeaveType"> | string
    name?: StringWithAggregatesFilter<"LeaveType"> | string
    code?: StringWithAggregatesFilter<"LeaveType"> | string
    isPaid?: BoolWithAggregatesFilter<"LeaveType"> | boolean
    maxDaysYear?: IntNullableWithAggregatesFilter<"LeaveType"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"LeaveType"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"LeaveType"> | Date | string | null
  }

  export type LeaveBalanceWhereInput = {
    AND?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    OR?: LeaveBalanceWhereInput[]
    NOT?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    id?: StringFilter<"LeaveBalance"> | string
    companyId?: StringFilter<"LeaveBalance"> | string
    employeeId?: StringFilter<"LeaveBalance"> | string
    leaveTypeId?: StringFilter<"LeaveBalance"> | string
    year?: IntFilter<"LeaveBalance"> | number
    totalDays?: IntFilter<"LeaveBalance"> | number
    usedDays?: IntFilter<"LeaveBalance"> | number
    deletedAt?: DateTimeNullableFilter<"LeaveBalance"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    leaveType?: XOR<LeaveTypeScalarRelationFilter, LeaveTypeWhereInput>
  }

  export type LeaveBalanceOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    leaveType?: LeaveTypeOrderByWithRelationInput
  }

  export type LeaveBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_leaveTypeId_year?: LeaveBalanceEmployeeIdLeaveTypeIdYearCompoundUniqueInput
    AND?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    OR?: LeaveBalanceWhereInput[]
    NOT?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    companyId?: StringFilter<"LeaveBalance"> | string
    employeeId?: StringFilter<"LeaveBalance"> | string
    leaveTypeId?: StringFilter<"LeaveBalance"> | string
    year?: IntFilter<"LeaveBalance"> | number
    totalDays?: IntFilter<"LeaveBalance"> | number
    usedDays?: IntFilter<"LeaveBalance"> | number
    deletedAt?: DateTimeNullableFilter<"LeaveBalance"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    leaveType?: XOR<LeaveTypeScalarRelationFilter, LeaveTypeWhereInput>
  }, "id" | "employeeId_leaveTypeId_year">

  export type LeaveBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: LeaveBalanceCountOrderByAggregateInput
    _avg?: LeaveBalanceAvgOrderByAggregateInput
    _max?: LeaveBalanceMaxOrderByAggregateInput
    _min?: LeaveBalanceMinOrderByAggregateInput
    _sum?: LeaveBalanceSumOrderByAggregateInput
  }

  export type LeaveBalanceScalarWhereWithAggregatesInput = {
    AND?: LeaveBalanceScalarWhereWithAggregatesInput | LeaveBalanceScalarWhereWithAggregatesInput[]
    OR?: LeaveBalanceScalarWhereWithAggregatesInput[]
    NOT?: LeaveBalanceScalarWhereWithAggregatesInput | LeaveBalanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveBalance"> | string
    companyId?: StringWithAggregatesFilter<"LeaveBalance"> | string
    employeeId?: StringWithAggregatesFilter<"LeaveBalance"> | string
    leaveTypeId?: StringWithAggregatesFilter<"LeaveBalance"> | string
    year?: IntWithAggregatesFilter<"LeaveBalance"> | number
    totalDays?: IntWithAggregatesFilter<"LeaveBalance"> | number
    usedDays?: IntWithAggregatesFilter<"LeaveBalance"> | number
    deletedAt?: DateTimeNullableWithAggregatesFilter<"LeaveBalance"> | Date | string | null
  }

  export type LeaveRequestWhereInput = {
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    companyId?: StringFilter<"LeaveRequest"> | string
    employeeId?: StringFilter<"LeaveRequest"> | string
    leaveTypeId?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    days?: IntFilter<"LeaveRequest"> | number
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    requestedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    validatedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    validatedByUserId?: StringNullableFilter<"LeaveRequest"> | string | null
    deletedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    leaveType?: XOR<LeaveTypeScalarRelationFilter, LeaveTypeWhereInput>
    validatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LeaveRequestOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedByUserId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    leaveType?: LeaveTypeOrderByWithRelationInput
    validatedBy?: UserOrderByWithRelationInput
  }

  export type LeaveRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    companyId?: StringFilter<"LeaveRequest"> | string
    employeeId?: StringFilter<"LeaveRequest"> | string
    leaveTypeId?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    days?: IntFilter<"LeaveRequest"> | number
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    requestedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    validatedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    validatedByUserId?: StringNullableFilter<"LeaveRequest"> | string | null
    deletedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    leaveType?: XOR<LeaveTypeScalarRelationFilter, LeaveTypeWhereInput>
    validatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LeaveRequestOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    validatedByUserId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: LeaveRequestCountOrderByAggregateInput
    _avg?: LeaveRequestAvgOrderByAggregateInput
    _max?: LeaveRequestMaxOrderByAggregateInput
    _min?: LeaveRequestMinOrderByAggregateInput
    _sum?: LeaveRequestSumOrderByAggregateInput
  }

  export type LeaveRequestScalarWhereWithAggregatesInput = {
    AND?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    OR?: LeaveRequestScalarWhereWithAggregatesInput[]
    NOT?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveRequest"> | string
    companyId?: StringWithAggregatesFilter<"LeaveRequest"> | string
    employeeId?: StringWithAggregatesFilter<"LeaveRequest"> | string
    leaveTypeId?: StringWithAggregatesFilter<"LeaveRequest"> | string
    startDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    days?: IntWithAggregatesFilter<"LeaveRequest"> | number
    status?: EnumLeaveStatusWithAggregatesFilter<"LeaveRequest"> | $Enums.LeaveStatus
    reason?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    validatedAt?: DateTimeNullableWithAggregatesFilter<"LeaveRequest"> | Date | string | null
    validatedByUserId?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"LeaveRequest"> | Date | string | null
  }

  export type PublicHolidayWhereInput = {
    AND?: PublicHolidayWhereInput | PublicHolidayWhereInput[]
    OR?: PublicHolidayWhereInput[]
    NOT?: PublicHolidayWhereInput | PublicHolidayWhereInput[]
    id?: StringFilter<"PublicHoliday"> | string
    date?: DateTimeFilter<"PublicHoliday"> | Date | string
    name?: StringFilter<"PublicHoliday"> | string
    country?: StringFilter<"PublicHoliday"> | string
    companyId?: StringNullableFilter<"PublicHoliday"> | string | null
    deletedAt?: DateTimeNullableFilter<"PublicHoliday"> | Date | string | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }

  export type PublicHolidayOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    country?: SortOrder
    companyId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type PublicHolidayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PublicHolidayWhereInput | PublicHolidayWhereInput[]
    OR?: PublicHolidayWhereInput[]
    NOT?: PublicHolidayWhereInput | PublicHolidayWhereInput[]
    date?: DateTimeFilter<"PublicHoliday"> | Date | string
    name?: StringFilter<"PublicHoliday"> | string
    country?: StringFilter<"PublicHoliday"> | string
    companyId?: StringNullableFilter<"PublicHoliday"> | string | null
    deletedAt?: DateTimeNullableFilter<"PublicHoliday"> | Date | string | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type PublicHolidayOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    country?: SortOrder
    companyId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PublicHolidayCountOrderByAggregateInput
    _max?: PublicHolidayMaxOrderByAggregateInput
    _min?: PublicHolidayMinOrderByAggregateInput
  }

  export type PublicHolidayScalarWhereWithAggregatesInput = {
    AND?: PublicHolidayScalarWhereWithAggregatesInput | PublicHolidayScalarWhereWithAggregatesInput[]
    OR?: PublicHolidayScalarWhereWithAggregatesInput[]
    NOT?: PublicHolidayScalarWhereWithAggregatesInput | PublicHolidayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PublicHoliday"> | string
    date?: DateTimeWithAggregatesFilter<"PublicHoliday"> | Date | string
    name?: StringWithAggregatesFilter<"PublicHoliday"> | string
    country?: StringWithAggregatesFilter<"PublicHoliday"> | string
    companyId?: StringNullableWithAggregatesFilter<"PublicHoliday"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PublicHoliday"> | Date | string | null
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: StringFilter<"Contract"> | string
    companyId?: StringFilter<"Contract"> | string
    employeeId?: StringFilter<"Contract"> | string
    salaryType?: EnumSalaryTypeFilter<"Contract"> | $Enums.SalaryType
    baseSalary?: FloatFilter<"Contract"> | number
    hourlyRate?: FloatNullableFilter<"Contract"> | number | null
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Contract"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    salaryType?: SortOrder
    baseSalary?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    companyId?: StringFilter<"Contract"> | string
    employeeId?: StringFilter<"Contract"> | string
    salaryType?: EnumSalaryTypeFilter<"Contract"> | $Enums.SalaryType
    baseSalary?: FloatFilter<"Contract"> | number
    hourlyRate?: FloatNullableFilter<"Contract"> | number | null
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Contract"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    salaryType?: SortOrder
    baseSalary?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contract"> | string
    companyId?: StringWithAggregatesFilter<"Contract"> | string
    employeeId?: StringWithAggregatesFilter<"Contract"> | string
    salaryType?: EnumSalaryTypeWithAggregatesFilter<"Contract"> | $Enums.SalaryType
    baseSalary?: FloatWithAggregatesFilter<"Contract"> | number
    hourlyRate?: FloatNullableWithAggregatesFilter<"Contract"> | number | null
    startDate?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
  }

  export type PayrollPeriodWhereInput = {
    AND?: PayrollPeriodWhereInput | PayrollPeriodWhereInput[]
    OR?: PayrollPeriodWhereInput[]
    NOT?: PayrollPeriodWhereInput | PayrollPeriodWhereInput[]
    id?: StringFilter<"PayrollPeriod"> | string
    month?: IntFilter<"PayrollPeriod"> | number
    year?: IntFilter<"PayrollPeriod"> | number
    companyId?: StringFilter<"PayrollPeriod"> | string
    isClosed?: BoolFilter<"PayrollPeriod"> | boolean
    closedAt?: DateTimeNullableFilter<"PayrollPeriod"> | Date | string | null
    closedByUserId?: StringNullableFilter<"PayrollPeriod"> | string | null
    deletedAt?: DateTimeNullableFilter<"PayrollPeriod"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    closedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    lines?: PayrollLineListRelationFilter
  }

  export type PayrollPeriodOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    companyId?: SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    closedByUserId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    closedBy?: UserOrderByWithRelationInput
    lines?: PayrollLineOrderByRelationAggregateInput
  }

  export type PayrollPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    month_year_companyId?: PayrollPeriodMonthYearCompanyIdCompoundUniqueInput
    AND?: PayrollPeriodWhereInput | PayrollPeriodWhereInput[]
    OR?: PayrollPeriodWhereInput[]
    NOT?: PayrollPeriodWhereInput | PayrollPeriodWhereInput[]
    month?: IntFilter<"PayrollPeriod"> | number
    year?: IntFilter<"PayrollPeriod"> | number
    companyId?: StringFilter<"PayrollPeriod"> | string
    isClosed?: BoolFilter<"PayrollPeriod"> | boolean
    closedAt?: DateTimeNullableFilter<"PayrollPeriod"> | Date | string | null
    closedByUserId?: StringNullableFilter<"PayrollPeriod"> | string | null
    deletedAt?: DateTimeNullableFilter<"PayrollPeriod"> | Date | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    closedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    lines?: PayrollLineListRelationFilter
  }, "id" | "month_year_companyId">

  export type PayrollPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    companyId?: SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    closedByUserId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PayrollPeriodCountOrderByAggregateInput
    _avg?: PayrollPeriodAvgOrderByAggregateInput
    _max?: PayrollPeriodMaxOrderByAggregateInput
    _min?: PayrollPeriodMinOrderByAggregateInput
    _sum?: PayrollPeriodSumOrderByAggregateInput
  }

  export type PayrollPeriodScalarWhereWithAggregatesInput = {
    AND?: PayrollPeriodScalarWhereWithAggregatesInput | PayrollPeriodScalarWhereWithAggregatesInput[]
    OR?: PayrollPeriodScalarWhereWithAggregatesInput[]
    NOT?: PayrollPeriodScalarWhereWithAggregatesInput | PayrollPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PayrollPeriod"> | string
    month?: IntWithAggregatesFilter<"PayrollPeriod"> | number
    year?: IntWithAggregatesFilter<"PayrollPeriod"> | number
    companyId?: StringWithAggregatesFilter<"PayrollPeriod"> | string
    isClosed?: BoolWithAggregatesFilter<"PayrollPeriod"> | boolean
    closedAt?: DateTimeNullableWithAggregatesFilter<"PayrollPeriod"> | Date | string | null
    closedByUserId?: StringNullableWithAggregatesFilter<"PayrollPeriod"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PayrollPeriod"> | Date | string | null
  }

  export type PayrollLineWhereInput = {
    AND?: PayrollLineWhereInput | PayrollLineWhereInput[]
    OR?: PayrollLineWhereInput[]
    NOT?: PayrollLineWhereInput | PayrollLineWhereInput[]
    id?: StringFilter<"PayrollLine"> | string
    companyId?: StringFilter<"PayrollLine"> | string
    payrollPeriodId?: StringFilter<"PayrollLine"> | string
    employeeId?: StringFilter<"PayrollLine"> | string
    workedDays?: IntFilter<"PayrollLine"> | number
    absentDays?: IntFilter<"PayrollLine"> | number
    lateMinutes?: IntFilter<"PayrollLine"> | number
    overtimeHours?: FloatFilter<"PayrollLine"> | number
    grossSalary?: FloatFilter<"PayrollLine"> | number
    deductions?: FloatFilter<"PayrollLine"> | number
    netSalary?: FloatFilter<"PayrollLine"> | number
    deletedAt?: DateTimeNullableFilter<"PayrollLine"> | Date | string | null
    createdAt?: DateTimeFilter<"PayrollLine"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    payrollPeriod?: XOR<PayrollPeriodScalarRelationFilter, PayrollPeriodWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type PayrollLineOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    payrollPeriodId?: SortOrder
    employeeId?: SortOrder
    workedDays?: SortOrder
    absentDays?: SortOrder
    lateMinutes?: SortOrder
    overtimeHours?: SortOrder
    grossSalary?: SortOrder
    deductions?: SortOrder
    netSalary?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    payrollPeriod?: PayrollPeriodOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
  }

  export type PayrollLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayrollLineWhereInput | PayrollLineWhereInput[]
    OR?: PayrollLineWhereInput[]
    NOT?: PayrollLineWhereInput | PayrollLineWhereInput[]
    companyId?: StringFilter<"PayrollLine"> | string
    payrollPeriodId?: StringFilter<"PayrollLine"> | string
    employeeId?: StringFilter<"PayrollLine"> | string
    workedDays?: IntFilter<"PayrollLine"> | number
    absentDays?: IntFilter<"PayrollLine"> | number
    lateMinutes?: IntFilter<"PayrollLine"> | number
    overtimeHours?: FloatFilter<"PayrollLine"> | number
    grossSalary?: FloatFilter<"PayrollLine"> | number
    deductions?: FloatFilter<"PayrollLine"> | number
    netSalary?: FloatFilter<"PayrollLine"> | number
    deletedAt?: DateTimeNullableFilter<"PayrollLine"> | Date | string | null
    createdAt?: DateTimeFilter<"PayrollLine"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    payrollPeriod?: XOR<PayrollPeriodScalarRelationFilter, PayrollPeriodWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type PayrollLineOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    payrollPeriodId?: SortOrder
    employeeId?: SortOrder
    workedDays?: SortOrder
    absentDays?: SortOrder
    lateMinutes?: SortOrder
    overtimeHours?: SortOrder
    grossSalary?: SortOrder
    deductions?: SortOrder
    netSalary?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PayrollLineCountOrderByAggregateInput
    _avg?: PayrollLineAvgOrderByAggregateInput
    _max?: PayrollLineMaxOrderByAggregateInput
    _min?: PayrollLineMinOrderByAggregateInput
    _sum?: PayrollLineSumOrderByAggregateInput
  }

  export type PayrollLineScalarWhereWithAggregatesInput = {
    AND?: PayrollLineScalarWhereWithAggregatesInput | PayrollLineScalarWhereWithAggregatesInput[]
    OR?: PayrollLineScalarWhereWithAggregatesInput[]
    NOT?: PayrollLineScalarWhereWithAggregatesInput | PayrollLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PayrollLine"> | string
    companyId?: StringWithAggregatesFilter<"PayrollLine"> | string
    payrollPeriodId?: StringWithAggregatesFilter<"PayrollLine"> | string
    employeeId?: StringWithAggregatesFilter<"PayrollLine"> | string
    workedDays?: IntWithAggregatesFilter<"PayrollLine"> | number
    absentDays?: IntWithAggregatesFilter<"PayrollLine"> | number
    lateMinutes?: IntWithAggregatesFilter<"PayrollLine"> | number
    overtimeHours?: FloatWithAggregatesFilter<"PayrollLine"> | number
    grossSalary?: FloatWithAggregatesFilter<"PayrollLine"> | number
    deductions?: FloatWithAggregatesFilter<"PayrollLine"> | number
    netSalary?: FloatWithAggregatesFilter<"PayrollLine"> | number
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PayrollLine"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PayrollLine"> | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    person?: PersonCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    companyId: string
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeUncheckedCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestUncheckedCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodUncheckedCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUncheckedUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUncheckedUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUncheckedUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    companyId: string
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceInput
    company: CompanyCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    userId: string
    companyId: string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceNestedInput
    company?: CompanyUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    userId: string
    companyId: string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    daysOfWeek?: ScheduleCreatedaysOfWeekInput | string[]
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSchedulesInput
    employees?: EmployeeCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    startTime: string
    endTime: string
    daysOfWeek?: ScheduleCreatedaysOfWeekInput | string[]
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduleUpdatedaysOfWeekInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSchedulesNestedInput
    employees?: EmployeeUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduleUpdatedaysOfWeekInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleCreateManyInput = {
    id?: string
    companyId: string
    name: string
    startTime: string
    endTime: string
    daysOfWeek?: ScheduleCreatedaysOfWeekInput | string[]
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduleUpdatedaysOfWeekInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduleUpdatedaysOfWeekInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeCreateInput = {
    id?: string
    date: Date | string
    hours: number
    reason?: string | null
    status?: $Enums.OvertimeStatus
    approvedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutOvertimeInput
    user: UserCreateNestedOneWithoutOvertimeRequestsInput
    approvedBy?: UserCreateNestedOneWithoutOvertimeApprovalsInput
  }

  export type OvertimeUncheckedCreateInput = {
    id?: string
    companyId: string
    userId: string
    date: Date | string
    hours: number
    reason?: string | null
    status?: $Enums.OvertimeStatus
    approvedByUserId?: string | null
    approvedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutOvertimeNestedInput
    user?: UserUpdateOneRequiredWithoutOvertimeRequestsNestedInput
    approvedBy?: UserUpdateOneWithoutOvertimeApprovalsNestedInput
  }

  export type OvertimeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeCreateManyInput = {
    id?: string
    companyId: string
    userId: string
    date: Date | string
    hours: number
    reason?: string | null
    status?: $Enums.OvertimeStatus
    approvedByUserId?: string | null
    approvedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSummaryCreateInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    totalHours: number
    overtimeHours: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutAttendanceSummariesInput
    payrolls?: PayrollCreateNestedManyWithoutAttendanceSummaryInput
  }

  export type AttendanceSummaryUncheckedCreateInput = {
    id?: string
    companyId: string
    periodStart: Date | string
    periodEnd: Date | string
    totalHours: number
    overtimeHours: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAttendanceSummaryInput
  }

  export type AttendanceSummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAttendanceSummariesNestedInput
    payrolls?: PayrollUpdateManyWithoutAttendanceSummaryNestedInput
  }

  export type AttendanceSummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrolls?: PayrollUncheckedUpdateManyWithoutAttendanceSummaryNestedInput
  }

  export type AttendanceSummaryCreateManyInput = {
    id?: string
    companyId: string
    periodStart: Date | string
    periodEnd: Date | string
    totalHours: number
    overtimeHours: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceSummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    grossPay: number
    netPay: number
    status?: $Enums.PayrollStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPayrollsInput
    attendanceSummary: AttendanceSummaryCreateNestedOneWithoutPayrollsInput
    exports?: PayrollExportCreateNestedManyWithoutPayrollInput
  }

  export type PayrollUncheckedCreateInput = {
    id?: string
    companyId: string
    attendanceSummaryId: string
    periodStart: Date | string
    periodEnd: Date | string
    grossPay: number
    netPay: number
    status?: $Enums.PayrollStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exports?: PayrollExportUncheckedCreateNestedManyWithoutPayrollInput
  }

  export type PayrollUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossPay?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPayrollsNestedInput
    attendanceSummary?: AttendanceSummaryUpdateOneRequiredWithoutPayrollsNestedInput
    exports?: PayrollExportUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    attendanceSummaryId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossPay?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exports?: PayrollExportUncheckedUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollCreateManyInput = {
    id?: string
    companyId: string
    attendanceSummaryId: string
    periodStart: Date | string
    periodEnd: Date | string
    grossPay: number
    netPay: number
    status?: $Enums.PayrollStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossPay?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    attendanceSummaryId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossPay?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollExportCreateInput = {
    id?: string
    format: $Enums.ExportFormat
    path: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPayrollExportsInput
    payroll: PayrollCreateNestedOneWithoutExportsInput
  }

  export type PayrollExportUncheckedCreateInput = {
    id?: string
    companyId: string
    payrollId: string
    format: $Enums.ExportFormat
    path: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollExportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    path?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPayrollExportsNestedInput
    payroll?: PayrollUpdateOneRequiredWithoutExportsNestedInput
  }

  export type PayrollExportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    payrollId?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    path?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollExportCreateManyInput = {
    id?: string
    companyId: string
    payrollId: string
    format: $Enums.ExportFormat
    path: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollExportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    path?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollExportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    payrollId?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    path?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    type: $Enums.ReportType
    periodStart: Date | string
    periodEnd: Date | string
    data: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    companyId: string
    type: $Enums.ReportType
    periodStart: Date | string
    periodEnd: Date | string
    data: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    companyId: string
    type: $Enums.ReportType
    periodStart: Date | string
    periodEnd: Date | string
    data: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodClosureCreateInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    closedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPeriodClosuresInput
  }

  export type PeriodClosureUncheckedCreateInput = {
    id?: string
    companyId: string
    periodStart: Date | string
    periodEnd: Date | string
    closedAt?: Date | string
  }

  export type PeriodClosureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPeriodClosuresNestedInput
  }

  export type PeriodClosureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodClosureCreateManyInput = {
    id?: string
    companyId: string
    periodStart: Date | string
    periodEnd: Date | string
    closedAt?: Date | string
  }

  export type PeriodClosureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodClosureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolClassCreateInput = {
    id?: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSchoolClassesInput
    courses?: CourseCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
  }

  export type SchoolClassUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
  }

  export type SchoolClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSchoolClassesNestedInput
    courses?: CourseUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
  }

  export type SchoolClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SchoolClassCreateManyInput = {
    id?: string
    companyId: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCoursesInput
    class: SchoolClassCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    companyId: string
    classId: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCoursesNestedInput
    class?: SchoolClassUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateManyInput = {
    id?: string
    companyId: string
    classId: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStudentsInput
    class: SchoolClassCreateNestedOneWithoutStudentsInput
    person?: PersonCreateNestedOneWithoutStudentInput
    attendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutStudentInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    companyId: string
    classId: string
    firstName: string
    lastName: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutStudentInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStudentsNestedInput
    class?: SchoolClassUpdateOneRequiredWithoutStudentsNestedInput
    person?: PersonUpdateOneWithoutStudentNestedInput
    attendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutStudentNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutStudentNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    companyId: string
    classId: string
    firstName: string
    lastName: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.StudentAttendanceStatus
    note?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStudentAttendanceInput
    student: StudentCreateNestedOneWithoutAttendanceInput
    recordedBy?: UserCreateNestedOneWithoutStudentAttendanceRecordsInput
  }

  export type StudentAttendanceUncheckedCreateInput = {
    id?: string
    companyId: string
    studentId: string
    date: Date | string
    status: $Enums.StudentAttendanceStatus
    note?: string | null
    recordedByUserId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentAttendanceStatusFieldUpdateOperationsInput | $Enums.StudentAttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStudentAttendanceNestedInput
    student?: StudentUpdateOneRequiredWithoutAttendanceNestedInput
    recordedBy?: UserUpdateOneWithoutStudentAttendanceRecordsNestedInput
  }

  export type StudentAttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentAttendanceStatusFieldUpdateOperationsInput | $Enums.StudentAttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceCreateManyInput = {
    id?: string
    companyId: string
    studentId: string
    date: Date | string
    status: $Enums.StudentAttendanceStatus
    note?: string | null
    recordedByUserId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentAttendanceStatusFieldUpdateOperationsInput | $Enums.StudentAttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentAttendanceStatusFieldUpdateOperationsInput | $Enums.StudentAttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConstructionSiteCreateInput = {
    id?: string
    name: string
    location?: string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutConstructionSitesInput
    teams?: ConstructionTeamCreateNestedManyWithoutSiteInput
    attendance?: SiteAttendanceCreateNestedManyWithoutSiteInput
  }

  export type ConstructionSiteUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    location?: string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: ConstructionTeamUncheckedCreateNestedManyWithoutSiteInput
    attendance?: SiteAttendanceUncheckedCreateNestedManyWithoutSiteInput
  }

  export type ConstructionSiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutConstructionSitesNestedInput
    teams?: ConstructionTeamUpdateManyWithoutSiteNestedInput
    attendance?: SiteAttendanceUpdateManyWithoutSiteNestedInput
  }

  export type ConstructionSiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: ConstructionTeamUncheckedUpdateManyWithoutSiteNestedInput
    attendance?: SiteAttendanceUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type ConstructionSiteCreateManyInput = {
    id?: string
    companyId: string
    name: string
    location?: string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConstructionSiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConstructionSiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConstructionTeamCreateInput = {
    id?: string
    name: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutConstructionTeamsInput
    site: ConstructionSiteCreateNestedOneWithoutTeamsInput
    workers?: ConstructionWorkerCreateNestedManyWithoutTeamInput
  }

  export type ConstructionTeamUncheckedCreateInput = {
    id?: string
    companyId: string
    siteId: string
    name: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workers?: ConstructionWorkerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type ConstructionTeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutConstructionTeamsNestedInput
    site?: ConstructionSiteUpdateOneRequiredWithoutTeamsNestedInput
    workers?: ConstructionWorkerUpdateManyWithoutTeamNestedInput
  }

  export type ConstructionTeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workers?: ConstructionWorkerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ConstructionTeamCreateManyInput = {
    id?: string
    companyId: string
    siteId: string
    name: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConstructionTeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConstructionTeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConstructionWorkerCreateInput = {
    id?: string
    name: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutConstructionWorkersInput
    team: ConstructionTeamCreateNestedOneWithoutWorkersInput
    person?: PersonCreateNestedOneWithoutConstructionWorkerInput
    attendance?: SiteAttendanceCreateNestedManyWithoutWorkerInput
  }

  export type ConstructionWorkerUncheckedCreateInput = {
    id?: string
    companyId: string
    teamId: string
    name: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: SiteAttendanceUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type ConstructionWorkerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutConstructionWorkersNestedInput
    team?: ConstructionTeamUpdateOneRequiredWithoutWorkersNestedInput
    person?: PersonUpdateOneWithoutConstructionWorkerNestedInput
    attendance?: SiteAttendanceUpdateManyWithoutWorkerNestedInput
  }

  export type ConstructionWorkerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: SiteAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type ConstructionWorkerCreateManyInput = {
    id?: string
    companyId: string
    teamId: string
    name: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConstructionWorkerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConstructionWorkerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteAttendanceCreateInput = {
    id?: string
    date: Date | string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSiteAttendanceInput
    site: ConstructionSiteCreateNestedOneWithoutAttendanceInput
    worker: ConstructionWorkerCreateNestedOneWithoutAttendanceInput
  }

  export type SiteAttendanceUncheckedCreateInput = {
    id?: string
    companyId: string
    siteId: string
    workerId: string
    date: Date | string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteAttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSiteAttendanceNestedInput
    site?: ConstructionSiteUpdateOneRequiredWithoutAttendanceNestedInput
    worker?: ConstructionWorkerUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type SiteAttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteAttendanceCreateManyInput = {
    id?: string
    companyId: string
    siteId: string
    workerId: string
    date: Date | string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteAttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteAttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    actionType?: $Enums.AuditAction | null
    entityType?: $Enums.AuditEntity | null
    ip?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAuditLogsInput
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    companyId: string
    action: string
    entity: string
    entityId: string
    actionType?: $Enums.AuditAction | null
    entityType?: $Enums.AuditEntity | null
    ip?: string | null
    userId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: NullableEnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction | null
    entityType?: NullableEnumAuditEntityFieldUpdateOperationsInput | $Enums.AuditEntity | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAuditLogsNestedInput
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: NullableEnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction | null
    entityType?: NullableEnumAuditEntityFieldUpdateOperationsInput | $Enums.AuditEntity | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    companyId: string
    action: string
    entity: string
    entityId: string
    actionType?: $Enums.AuditAction | null
    entityType?: $Enums.AuditEntity | null
    ip?: string | null
    userId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: NullableEnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction | null
    entityType?: NullableEnumAuditEntityFieldUpdateOperationsInput | $Enums.AuditEntity | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: NullableEnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction | null
    entityType?: NullableEnumAuditEntityFieldUpdateOperationsInput | $Enums.AuditEntity | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    id?: string
    role: $Enums.Role
    deletedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
    company: CompanyCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    companyId: string
    role: $Enums.Role
    userId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    company?: CompanyUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyInput = {
    id?: string
    companyId: string
    role: $Enums.Role
    userId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonCreateInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPersonsInput
    user?: UserCreateNestedOneWithoutPersonInput
    employee?: EmployeeCreateNestedOneWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    worker?: WorkerCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerCreateNestedOneWithoutPersonInput
    devices?: DeviceCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserUncheckedCreateNestedOneWithoutPersonInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    worker?: WorkerUncheckedCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerUncheckedCreateNestedOneWithoutPersonInput
    devices?: DeviceUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPersonsNestedInput
    user?: UserUpdateOneWithoutPersonNestedInput
    employee?: EmployeeUpdateOneWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    worker?: WorkerUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUpdateOneWithoutPersonNestedInput
    devices?: DeviceUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateOneWithoutPersonNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUncheckedUpdateOneWithoutPersonNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeCreateInput = {
    id?: string
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutEmployeesInput
    person: PersonCreateNestedOneWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    schedule?: ScheduleCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineCreateNestedManyWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    companyId: string
    personId: string
    userId?: string | null
    scheduleId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
    person?: PersonUpdateOneRequiredWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    schedule?: ScheduleUpdateOneWithoutEmployeesNestedInput
    attendances?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    companyId: string
    personId: string
    userId?: string | null
    scheduleId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerCreateInput = {
    id?: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutWorkersInput
    person: PersonCreateNestedOneWithoutWorkerInput
    attendances?: AttendanceEventCreateNestedManyWithoutWorkerInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUncheckedCreateInput = {
    id?: string
    companyId: string
    personId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutWorkerInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutWorkersNestedInput
    person?: PersonUpdateOneRequiredWithoutWorkerNestedInput
    attendances?: AttendanceEventUpdateManyWithoutWorkerNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutWorkerNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerCreateManyInput = {
    id?: string
    companyId: string
    personId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WorkerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventCreateInput = {
    id?: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    createdAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutAttendanceEventsInput
    employee?: EmployeeCreateNestedOneWithoutAttendancesInput
    student?: StudentCreateNestedOneWithoutAttendanceEventsInput
    worker?: WorkerCreateNestedOneWithoutAttendancesInput
    device?: DeviceCreateNestedOneWithoutAttendanceEventsInput
  }

  export type AttendanceEventUncheckedCreateInput = {
    id?: string
    companyId: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    employeeId?: string | null
    studentId?: string | null
    workerId?: string | null
    deviceId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutAttendanceEventsNestedInput
    employee?: EmployeeUpdateOneWithoutAttendancesNestedInput
    student?: StudentUpdateOneWithoutAttendanceEventsNestedInput
    worker?: WorkerUpdateOneWithoutAttendancesNestedInput
    device?: DeviceUpdateOneWithoutAttendanceEventsNestedInput
  }

  export type AttendanceEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceEventCreateManyInput = {
    id?: string
    companyId: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    employeeId?: string | null
    studentId?: string | null
    workerId?: string | null
    deviceId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDailySummaryCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutAttendanceDailySummariesInput
    employee?: EmployeeCreateNestedOneWithoutDailySummariesInput
    student?: StudentCreateNestedOneWithoutDailySummariesInput
    worker?: WorkerCreateNestedOneWithoutDailySummariesInput
    validatedBy?: UserCreateNestedOneWithoutAttendanceValidationsInput
  }

  export type AttendanceDailySummaryUncheckedCreateInput = {
    id?: string
    companyId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    employeeId?: string | null
    studentId?: string | null
    workerId?: string | null
    validatedByUserId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceDailySummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutAttendanceDailySummariesNestedInput
    employee?: EmployeeUpdateOneWithoutDailySummariesNestedInput
    student?: StudentUpdateOneWithoutDailySummariesNestedInput
    worker?: WorkerUpdateOneWithoutDailySummariesNestedInput
    validatedBy?: UserUpdateOneWithoutAttendanceValidationsNestedInput
  }

  export type AttendanceDailySummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDailySummaryCreateManyInput = {
    id?: string
    companyId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    employeeId?: string | null
    studentId?: string | null
    workerId?: string | null
    validatedByUserId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceDailySummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDailySummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeviceCreateInput = {
    id?: string
    uuid: string
    platform: string
    model: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    person: PersonCreateNestedOneWithoutDevicesInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutDeviceInput
    company: CompanyCreateNestedOneWithoutDevicesInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: string
    uuid: string
    platform: string
    model: string
    personId: string
    companyId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutDevicesNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutDeviceNestedInput
    company?: CompanyUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceCreateManyInput = {
    id?: string
    uuid: string
    platform: string
    model: string
    personId: string
    companyId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveTypeCreateInput = {
    id?: string
    name: string
    code: string
    isPaid: boolean
    maxDaysYear?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutLeaveTypesInput
    balances?: LeaveBalanceCreateNestedManyWithoutLeaveTypeInput
    requests?: LeaveRequestCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    code: string
    isPaid: boolean
    maxDaysYear?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    balances?: LeaveBalanceUncheckedCreateNestedManyWithoutLeaveTypeInput
    requests?: LeaveRequestUncheckedCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    maxDaysYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutLeaveTypesNestedInput
    balances?: LeaveBalanceUpdateManyWithoutLeaveTypeNestedInput
    requests?: LeaveRequestUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    maxDaysYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balances?: LeaveBalanceUncheckedUpdateManyWithoutLeaveTypeNestedInput
    requests?: LeaveRequestUncheckedUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeCreateManyInput = {
    id?: string
    companyId: string
    name: string
    code: string
    isPaid: boolean
    maxDaysYear?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LeaveTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    maxDaysYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    maxDaysYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveBalanceCreateInput = {
    id?: string
    year: number
    totalDays: number
    usedDays?: number
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutLeaveBalancesInput
    employee: EmployeeCreateNestedOneWithoutLeaveBalancesInput
    leaveType: LeaveTypeCreateNestedOneWithoutBalancesInput
  }

  export type LeaveBalanceUncheckedCreateInput = {
    id?: string
    companyId: string
    employeeId: string
    leaveTypeId: string
    year: number
    totalDays: number
    usedDays?: number
    deletedAt?: Date | string | null
  }

  export type LeaveBalanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutLeaveBalancesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLeaveBalancesNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type LeaveBalanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveBalanceCreateManyInput = {
    id?: string
    companyId: string
    employeeId: string
    leaveTypeId: string
    year: number
    totalDays: number
    usedDays?: number
    deletedAt?: Date | string | null
  }

  export type LeaveBalanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveBalanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutLeaveRequestsInput
    employee: EmployeeCreateNestedOneWithoutLeaveRequestsInput
    leaveType: LeaveTypeCreateNestedOneWithoutRequestsInput
    validatedBy?: UserCreateNestedOneWithoutLeaveValidationsInput
  }

  export type LeaveRequestUncheckedCreateInput = {
    id?: string
    companyId: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    validatedByUserId?: string | null
    deletedAt?: Date | string | null
  }

  export type LeaveRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutLeaveRequestsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLeaveRequestsNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutRequestsNestedInput
    validatedBy?: UserUpdateOneWithoutLeaveValidationsNestedInput
  }

  export type LeaveRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestCreateManyInput = {
    id?: string
    companyId: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    validatedByUserId?: string | null
    deletedAt?: Date | string | null
  }

  export type LeaveRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PublicHolidayCreateInput = {
    id?: string
    date: Date | string
    name: string
    country: string
    deletedAt?: Date | string | null
    company?: CompanyCreateNestedOneWithoutPublicHolidaysInput
  }

  export type PublicHolidayUncheckedCreateInput = {
    id?: string
    date: Date | string
    name: string
    country: string
    companyId?: string | null
    deletedAt?: Date | string | null
  }

  export type PublicHolidayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneWithoutPublicHolidaysNestedInput
  }

  export type PublicHolidayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PublicHolidayCreateManyInput = {
    id?: string
    date: Date | string
    name: string
    country: string
    companyId?: string | null
    deletedAt?: Date | string | null
  }

  export type PublicHolidayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PublicHolidayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractCreateInput = {
    id?: string
    salaryType: $Enums.SalaryType
    baseSalary: number
    hourlyRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutContractsInput
    employee: EmployeeCreateNestedOneWithoutContractsInput
  }

  export type ContractUncheckedCreateInput = {
    id?: string
    companyId: string
    employeeId: string
    salaryType: $Enums.SalaryType
    baseSalary: number
    hourlyRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    salaryType?: EnumSalaryTypeFieldUpdateOperationsInput | $Enums.SalaryType
    baseSalary?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutContractsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutContractsNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    salaryType?: EnumSalaryTypeFieldUpdateOperationsInput | $Enums.SalaryType
    baseSalary?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractCreateManyInput = {
    id?: string
    companyId: string
    employeeId: string
    salaryType: $Enums.SalaryType
    baseSalary: number
    hourlyRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    salaryType?: EnumSalaryTypeFieldUpdateOperationsInput | $Enums.SalaryType
    baseSalary?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    salaryType?: EnumSalaryTypeFieldUpdateOperationsInput | $Enums.SalaryType
    baseSalary?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollPeriodCreateInput = {
    id?: string
    month: number
    year: number
    isClosed?: boolean
    closedAt?: Date | string | null
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPayrollPeriodsInput
    closedBy?: UserCreateNestedOneWithoutPayrollPeriodClosuresInput
    lines?: PayrollLineCreateNestedManyWithoutPayrollPeriodInput
  }

  export type PayrollPeriodUncheckedCreateInput = {
    id?: string
    month: number
    year: number
    companyId: string
    isClosed?: boolean
    closedAt?: Date | string | null
    closedByUserId?: string | null
    deletedAt?: Date | string | null
    lines?: PayrollLineUncheckedCreateNestedManyWithoutPayrollPeriodInput
  }

  export type PayrollPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPayrollPeriodsNestedInput
    closedBy?: UserUpdateOneWithoutPayrollPeriodClosuresNestedInput
    lines?: PayrollLineUpdateManyWithoutPayrollPeriodNestedInput
  }

  export type PayrollPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: PayrollLineUncheckedUpdateManyWithoutPayrollPeriodNestedInput
  }

  export type PayrollPeriodCreateManyInput = {
    id?: string
    month: number
    year: number
    companyId: string
    isClosed?: boolean
    closedAt?: Date | string | null
    closedByUserId?: string | null
    deletedAt?: Date | string | null
  }

  export type PayrollPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollLineCreateInput = {
    id?: string
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutPayrollLinesInput
    payrollPeriod: PayrollPeriodCreateNestedOneWithoutLinesInput
    employee: EmployeeCreateNestedOneWithoutPayrollLinesInput
  }

  export type PayrollLineUncheckedCreateInput = {
    id?: string
    companyId: string
    payrollPeriodId: string
    employeeId: string
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PayrollLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateMinutes?: IntFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPayrollLinesNestedInput
    payrollPeriod?: PayrollPeriodUpdateOneRequiredWithoutLinesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutPayrollLinesNestedInput
  }

  export type PayrollLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    payrollPeriodId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateMinutes?: IntFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollLineCreateManyInput = {
    id?: string
    companyId: string
    payrollPeriodId: string
    employeeId: string
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PayrollLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateMinutes?: IntFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    payrollPeriodId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateMinutes?: IntFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumCompanyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyType | EnumCompanyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyTypeFilter<$PrismaModel> | $Enums.CompanyType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PersonListRelationFilter = {
    every?: PersonWhereInput
    some?: PersonWhereInput
    none?: PersonWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type WorkerListRelationFilter = {
    every?: WorkerWhereInput
    some?: WorkerWhereInput
    none?: WorkerWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type AttendanceEventListRelationFilter = {
    every?: AttendanceEventWhereInput
    some?: AttendanceEventWhereInput
    none?: AttendanceEventWhereInput
  }

  export type AttendanceDailySummaryListRelationFilter = {
    every?: AttendanceDailySummaryWhereInput
    some?: AttendanceDailySummaryWhereInput
    none?: AttendanceDailySummaryWhereInput
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type OvertimeListRelationFilter = {
    every?: OvertimeWhereInput
    some?: OvertimeWhereInput
    none?: OvertimeWhereInput
  }

  export type AttendanceSummaryListRelationFilter = {
    every?: AttendanceSummaryWhereInput
    some?: AttendanceSummaryWhereInput
    none?: AttendanceSummaryWhereInput
  }

  export type PayrollListRelationFilter = {
    every?: PayrollWhereInput
    some?: PayrollWhereInput
    none?: PayrollWhereInput
  }

  export type PayrollPeriodListRelationFilter = {
    every?: PayrollPeriodWhereInput
    some?: PayrollPeriodWhereInput
    none?: PayrollPeriodWhereInput
  }

  export type PayrollLineListRelationFilter = {
    every?: PayrollLineWhereInput
    some?: PayrollLineWhereInput
    none?: PayrollLineWhereInput
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type PayrollExportListRelationFilter = {
    every?: PayrollExportWhereInput
    some?: PayrollExportWhereInput
    none?: PayrollExportWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type SchoolClassListRelationFilter = {
    every?: SchoolClassWhereInput
    some?: SchoolClassWhereInput
    none?: SchoolClassWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type StudentAttendanceListRelationFilter = {
    every?: StudentAttendanceWhereInput
    some?: StudentAttendanceWhereInput
    none?: StudentAttendanceWhereInput
  }

  export type LeaveTypeListRelationFilter = {
    every?: LeaveTypeWhereInput
    some?: LeaveTypeWhereInput
    none?: LeaveTypeWhereInput
  }

  export type LeaveBalanceListRelationFilter = {
    every?: LeaveBalanceWhereInput
    some?: LeaveBalanceWhereInput
    none?: LeaveBalanceWhereInput
  }

  export type LeaveRequestListRelationFilter = {
    every?: LeaveRequestWhereInput
    some?: LeaveRequestWhereInput
    none?: LeaveRequestWhereInput
  }

  export type PublicHolidayListRelationFilter = {
    every?: PublicHolidayWhereInput
    some?: PublicHolidayWhereInput
    none?: PublicHolidayWhereInput
  }

  export type ConstructionSiteListRelationFilter = {
    every?: ConstructionSiteWhereInput
    some?: ConstructionSiteWhereInput
    none?: ConstructionSiteWhereInput
  }

  export type ConstructionTeamListRelationFilter = {
    every?: ConstructionTeamWhereInput
    some?: ConstructionTeamWhereInput
    none?: ConstructionTeamWhereInput
  }

  export type ConstructionWorkerListRelationFilter = {
    every?: ConstructionWorkerWhereInput
    some?: ConstructionWorkerWhereInput
    none?: ConstructionWorkerWhereInput
  }

  export type SiteAttendanceListRelationFilter = {
    every?: SiteAttendanceWhereInput
    some?: SiteAttendanceWhereInput
    none?: SiteAttendanceWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type DeviceListRelationFilter = {
    every?: DeviceWhereInput
    some?: DeviceWhereInput
    none?: DeviceWhereInput
  }

  export type PeriodClosureListRelationFilter = {
    every?: PeriodClosureWhereInput
    some?: PeriodClosureWhereInput
    none?: PeriodClosureWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceDailySummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OvertimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceSummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollPeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollExportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PublicHolidayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConstructionSiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConstructionTeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConstructionWorkerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PeriodClosureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumCompanyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyType | EnumCompanyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyTypeWithAggregatesFilter<$PrismaModel> | $Enums.CompanyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyTypeFilter<$PrismaModel>
    _max?: NestedEnumCompanyTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    has?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type PersonNullableScalarRelationFilter = {
    is?: PersonWhereInput | null
    isNot?: PersonWhereInput | null
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    roles?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    personId?: SortOrder
    refreshTokenHash?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    personId?: SortOrder
    refreshTokenHash?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    personId?: SortOrder
    refreshTokenHash?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    daysOfWeek?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumOvertimeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OvertimeStatus | EnumOvertimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOvertimeStatusFilter<$PrismaModel> | $Enums.OvertimeStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type OvertimeCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    hours?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedByUserId?: SortOrder
    approvedAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OvertimeAvgOrderByAggregateInput = {
    hours?: SortOrder
  }

  export type OvertimeMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    hours?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedByUserId?: SortOrder
    approvedAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OvertimeMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    hours?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedByUserId?: SortOrder
    approvedAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OvertimeSumOrderByAggregateInput = {
    hours?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumOvertimeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OvertimeStatus | EnumOvertimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOvertimeStatusWithAggregatesFilter<$PrismaModel> | $Enums.OvertimeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOvertimeStatusFilter<$PrismaModel>
    _max?: NestedEnumOvertimeStatusFilter<$PrismaModel>
  }

  export type AttendanceSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalHours?: SortOrder
    overtimeHours?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceSummaryAvgOrderByAggregateInput = {
    totalHours?: SortOrder
    overtimeHours?: SortOrder
  }

  export type AttendanceSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalHours?: SortOrder
    overtimeHours?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalHours?: SortOrder
    overtimeHours?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceSummarySumOrderByAggregateInput = {
    totalHours?: SortOrder
    overtimeHours?: SortOrder
  }

  export type EnumPayrollStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollStatus | EnumPayrollStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayrollStatusFilter<$PrismaModel> | $Enums.PayrollStatus
  }

  export type AttendanceSummaryScalarRelationFilter = {
    is?: AttendanceSummaryWhereInput
    isNot?: AttendanceSummaryWhereInput
  }

  export type PayrollCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    attendanceSummaryId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    grossPay?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollAvgOrderByAggregateInput = {
    grossPay?: SortOrder
    netPay?: SortOrder
  }

  export type PayrollMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    attendanceSummaryId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    grossPay?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    attendanceSummaryId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    grossPay?: SortOrder
    netPay?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollSumOrderByAggregateInput = {
    grossPay?: SortOrder
    netPay?: SortOrder
  }

  export type EnumPayrollStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollStatus | EnumPayrollStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayrollStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayrollStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayrollStatusFilter<$PrismaModel>
    _max?: NestedEnumPayrollStatusFilter<$PrismaModel>
  }

  export type EnumExportFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ExportFormat | EnumExportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumExportFormatFilter<$PrismaModel> | $Enums.ExportFormat
  }

  export type PayrollScalarRelationFilter = {
    is?: PayrollWhereInput
    isNot?: PayrollWhereInput
  }

  export type PayrollExportCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    payrollId?: SortOrder
    format?: SortOrder
    path?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollExportMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    payrollId?: SortOrder
    format?: SortOrder
    path?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollExportMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    payrollId?: SortOrder
    format?: SortOrder
    path?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumExportFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExportFormat | EnumExportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumExportFormatWithAggregatesFilter<$PrismaModel> | $Enums.ExportFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExportFormatFilter<$PrismaModel>
    _max?: NestedEnumExportFormatFilter<$PrismaModel>
  }

  export type EnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    data?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PeriodClosureCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    closedAt?: SortOrder
  }

  export type PeriodClosureMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    closedAt?: SortOrder
  }

  export type PeriodClosureMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    closedAt?: SortOrder
  }

  export type SchoolClassCompanyIdCodeCompoundUniqueInput = {
    companyId: string
    code: string
  }

  export type SchoolClassCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolClassMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolClassMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolClassScalarRelationFilter = {
    is?: SchoolClassWhereInput
    isNot?: SchoolClassWhereInput
  }

  export type CourseCompanyIdCodeCompoundUniqueInput = {
    companyId: string
    code: string
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    classId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    personId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    classId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    personId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    classId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    personId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStudentAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentAttendanceStatus | EnumStudentAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentAttendanceStatus[] | ListEnumStudentAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentAttendanceStatus[] | ListEnumStudentAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentAttendanceStatusFilter<$PrismaModel> | $Enums.StudentAttendanceStatus
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type StudentAttendanceStudentIdDateCompoundUniqueInput = {
    studentId: string
    date: Date | string
  }

  export type StudentAttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    note?: SortOrder
    recordedByUserId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    note?: SortOrder
    recordedByUserId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    note?: SortOrder
    recordedByUserId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStudentAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentAttendanceStatus | EnumStudentAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentAttendanceStatus[] | ListEnumStudentAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentAttendanceStatus[] | ListEnumStudentAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentAttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentAttendanceStatusFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ConstructionSiteCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConstructionSiteAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type ConstructionSiteMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConstructionSiteMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    location?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConstructionSiteSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ConstructionSiteScalarRelationFilter = {
    is?: ConstructionSiteWhereInput
    isNot?: ConstructionSiteWhereInput
  }

  export type ConstructionTeamCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConstructionTeamMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConstructionTeamMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    siteId?: SortOrder
    name?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConstructionTeamScalarRelationFilter = {
    is?: ConstructionTeamWhereInput
    isNot?: ConstructionTeamWhereInput
  }

  export type ConstructionWorkerCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    personId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConstructionWorkerMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    personId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConstructionWorkerMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    personId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConstructionWorkerScalarRelationFilter = {
    is?: ConstructionWorkerWhereInput
    isNot?: ConstructionWorkerWhereInput
  }

  export type SiteAttendanceWorkerIdDateCompoundUniqueInput = {
    workerId: string
    date: Date | string
  }

  export type SiteAttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    siteId?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteAttendanceAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type SiteAttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    siteId?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteAttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    siteId?: SortOrder
    workerId?: SortOrder
    date?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteAttendanceSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumAuditActionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel> | null
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAuditActionNullableFilter<$PrismaModel> | $Enums.AuditAction | null
  }

  export type EnumAuditEntityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntity | EnumAuditEntityFieldRefInput<$PrismaModel> | null
    in?: $Enums.AuditEntity[] | ListEnumAuditEntityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AuditEntity[] | ListEnumAuditEntityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAuditEntityNullableFilter<$PrismaModel> | $Enums.AuditEntity | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrder
    entityType?: SortOrder
    ip?: SortOrder
    userId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrder
    entityType?: SortOrder
    ip?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    actionType?: SortOrder
    entityType?: SortOrder
    ip?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditActionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel> | null
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAuditActionNullableWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAuditActionNullableFilter<$PrismaModel>
    _max?: NestedEnumAuditActionNullableFilter<$PrismaModel>
  }

  export type EnumAuditEntityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntity | EnumAuditEntityFieldRefInput<$PrismaModel> | null
    in?: $Enums.AuditEntity[] | ListEnumAuditEntityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AuditEntity[] | ListEnumAuditEntityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAuditEntityNullableWithAggregatesFilter<$PrismaModel> | $Enums.AuditEntity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAuditEntityNullableFilter<$PrismaModel>
    _max?: NestedEnumAuditEntityNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type UserRoleUserIdRoleCompoundUniqueInput = {
    userId: string
    role: $Enums.Role
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type WorkerNullableScalarRelationFilter = {
    is?: WorkerWhereInput | null
    isNot?: WorkerWhereInput | null
  }

  export type ConstructionWorkerNullableScalarRelationFilter = {
    is?: ConstructionWorkerWhereInput | null
    isNot?: ConstructionWorkerWhereInput | null
  }

  export type PersonCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PersonMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PersonMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PersonScalarRelationFilter = {
    is?: PersonWhereInput
    isNot?: PersonWhereInput
  }

  export type ScheduleNullableScalarRelationFilter = {
    is?: ScheduleWhereInput | null
    isNot?: ScheduleWhereInput | null
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    personId?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    matricule?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    personId?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    matricule?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    personId?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    matricule?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkerCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    personId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkerMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    personId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkerMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    personId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAttendanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceType | EnumAttendanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceTypeFilter<$PrismaModel> | $Enums.AttendanceType
  }

  export type EnumPersonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonTypeFilter<$PrismaModel> | $Enums.PersonType
  }

  export type DeviceNullableScalarRelationFilter = {
    is?: DeviceWhereInput | null
    isNot?: DeviceWhereInput | null
  }

  export type AttendanceEventCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    date?: SortOrder
    personType?: SortOrder
    employeeId?: SortOrder
    studentId?: SortOrder
    workerId?: SortOrder
    deviceId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AttendanceEventMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    date?: SortOrder
    personType?: SortOrder
    employeeId?: SortOrder
    studentId?: SortOrder
    workerId?: SortOrder
    deviceId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AttendanceEventMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    date?: SortOrder
    personType?: SortOrder
    employeeId?: SortOrder
    studentId?: SortOrder
    workerId?: SortOrder
    deviceId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumAttendanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceType | EnumAttendanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceTypeFilter<$PrismaModel>
    _max?: NestedEnumAttendanceTypeFilter<$PrismaModel>
  }

  export type EnumPersonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonTypeWithAggregatesFilter<$PrismaModel> | $Enums.PersonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonTypeFilter<$PrismaModel>
    _max?: NestedEnumPersonTypeFilter<$PrismaModel>
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AttendanceDailySummaryEmployeeIdDateCompoundUniqueInput = {
    employeeId: string
    date: Date | string
  }

  export type AttendanceDailySummaryStudentIdDateCompoundUniqueInput = {
    studentId: string
    date: Date | string
  }

  export type AttendanceDailySummaryWorkerIdDateCompoundUniqueInput = {
    workerId: string
    date: Date | string
  }

  export type AttendanceDailySummaryCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateMinutes?: SortOrder
    earlyMinutes?: SortOrder
    workedMinutes?: SortOrder
    employeeId?: SortOrder
    studentId?: SortOrder
    workerId?: SortOrder
    validatedByUserId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AttendanceDailySummaryAvgOrderByAggregateInput = {
    lateMinutes?: SortOrder
    earlyMinutes?: SortOrder
    workedMinutes?: SortOrder
  }

  export type AttendanceDailySummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateMinutes?: SortOrder
    earlyMinutes?: SortOrder
    workedMinutes?: SortOrder
    employeeId?: SortOrder
    studentId?: SortOrder
    workerId?: SortOrder
    validatedByUserId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AttendanceDailySummaryMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateMinutes?: SortOrder
    earlyMinutes?: SortOrder
    workedMinutes?: SortOrder
    employeeId?: SortOrder
    studentId?: SortOrder
    workerId?: SortOrder
    validatedByUserId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AttendanceDailySummarySumOrderByAggregateInput = {
    lateMinutes?: SortOrder
    earlyMinutes?: SortOrder
    workedMinutes?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    platform?: SortOrder
    model?: SortOrder
    personId?: SortOrder
    companyId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    platform?: SortOrder
    model?: SortOrder
    personId?: SortOrder
    companyId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    platform?: SortOrder
    model?: SortOrder
    personId?: SortOrder
    companyId?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LeaveTypeCompanyIdCodeCompoundUniqueInput = {
    companyId: string
    code: string
  }

  export type LeaveTypeCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isPaid?: SortOrder
    maxDaysYear?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaveTypeAvgOrderByAggregateInput = {
    maxDaysYear?: SortOrder
  }

  export type LeaveTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isPaid?: SortOrder
    maxDaysYear?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaveTypeMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isPaid?: SortOrder
    maxDaysYear?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaveTypeSumOrderByAggregateInput = {
    maxDaysYear?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type LeaveTypeScalarRelationFilter = {
    is?: LeaveTypeWhereInput
    isNot?: LeaveTypeWhereInput
  }

  export type LeaveBalanceEmployeeIdLeaveTypeIdYearCompoundUniqueInput = {
    employeeId: string
    leaveTypeId: string
    year: number
  }

  export type LeaveBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaveBalanceAvgOrderByAggregateInput = {
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
  }

  export type LeaveBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaveBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaveBalanceSumOrderByAggregateInput = {
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type LeaveRequestCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    requestedAt?: SortOrder
    validatedAt?: SortOrder
    validatedByUserId?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaveRequestAvgOrderByAggregateInput = {
    days?: SortOrder
  }

  export type LeaveRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    requestedAt?: SortOrder
    validatedAt?: SortOrder
    validatedByUserId?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaveRequestMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    days?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    requestedAt?: SortOrder
    validatedAt?: SortOrder
    validatedByUserId?: SortOrder
    deletedAt?: SortOrder
  }

  export type LeaveRequestSumOrderByAggregateInput = {
    days?: SortOrder
  }

  export type EnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type PublicHolidayCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    country?: SortOrder
    companyId?: SortOrder
    deletedAt?: SortOrder
  }

  export type PublicHolidayMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    country?: SortOrder
    companyId?: SortOrder
    deletedAt?: SortOrder
  }

  export type PublicHolidayMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    name?: SortOrder
    country?: SortOrder
    companyId?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumSalaryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryType | EnumSalaryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryType[] | ListEnumSalaryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryType[] | ListEnumSalaryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryTypeFilter<$PrismaModel> | $Enums.SalaryType
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    salaryType?: SortOrder
    baseSalary?: SortOrder
    hourlyRate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    baseSalary?: SortOrder
    hourlyRate?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    salaryType?: SortOrder
    baseSalary?: SortOrder
    hourlyRate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    employeeId?: SortOrder
    salaryType?: SortOrder
    baseSalary?: SortOrder
    hourlyRate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    baseSalary?: SortOrder
    hourlyRate?: SortOrder
  }

  export type EnumSalaryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryType | EnumSalaryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryType[] | ListEnumSalaryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryType[] | ListEnumSalaryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryTypeWithAggregatesFilter<$PrismaModel> | $Enums.SalaryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalaryTypeFilter<$PrismaModel>
    _max?: NestedEnumSalaryTypeFilter<$PrismaModel>
  }

  export type PayrollPeriodMonthYearCompanyIdCompoundUniqueInput = {
    month: number
    year: number
    companyId: string
  }

  export type PayrollPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    companyId?: SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrder
    closedByUserId?: SortOrder
    deletedAt?: SortOrder
  }

  export type PayrollPeriodAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
  }

  export type PayrollPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    companyId?: SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrder
    closedByUserId?: SortOrder
    deletedAt?: SortOrder
  }

  export type PayrollPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    companyId?: SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrder
    closedByUserId?: SortOrder
    deletedAt?: SortOrder
  }

  export type PayrollPeriodSumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
  }

  export type PayrollPeriodScalarRelationFilter = {
    is?: PayrollPeriodWhereInput
    isNot?: PayrollPeriodWhereInput
  }

  export type PayrollLineCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    payrollPeriodId?: SortOrder
    employeeId?: SortOrder
    workedDays?: SortOrder
    absentDays?: SortOrder
    lateMinutes?: SortOrder
    overtimeHours?: SortOrder
    grossSalary?: SortOrder
    deductions?: SortOrder
    netSalary?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PayrollLineAvgOrderByAggregateInput = {
    workedDays?: SortOrder
    absentDays?: SortOrder
    lateMinutes?: SortOrder
    overtimeHours?: SortOrder
    grossSalary?: SortOrder
    deductions?: SortOrder
    netSalary?: SortOrder
  }

  export type PayrollLineMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    payrollPeriodId?: SortOrder
    employeeId?: SortOrder
    workedDays?: SortOrder
    absentDays?: SortOrder
    lateMinutes?: SortOrder
    overtimeHours?: SortOrder
    grossSalary?: SortOrder
    deductions?: SortOrder
    netSalary?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PayrollLineMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    payrollPeriodId?: SortOrder
    employeeId?: SortOrder
    workedDays?: SortOrder
    absentDays?: SortOrder
    lateMinutes?: SortOrder
    overtimeHours?: SortOrder
    grossSalary?: SortOrder
    deductions?: SortOrder
    netSalary?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PayrollLineSumOrderByAggregateInput = {
    workedDays?: SortOrder
    absentDays?: SortOrder
    lateMinutes?: SortOrder
    overtimeHours?: SortOrder
    grossSalary?: SortOrder
    deductions?: SortOrder
    netSalary?: SortOrder
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PersonCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PersonCreateWithoutCompanyInput, PersonUncheckedCreateWithoutCompanyInput> | PersonCreateWithoutCompanyInput[] | PersonUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutCompanyInput | PersonCreateOrConnectWithoutCompanyInput[]
    createMany?: PersonCreateManyCompanyInputEnvelope
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutCompanyInput = {
    create?: XOR<EmployeeCreateWithoutCompanyInput, EmployeeUncheckedCreateWithoutCompanyInput> | EmployeeCreateWithoutCompanyInput[] | EmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutCompanyInput | EmployeeCreateOrConnectWithoutCompanyInput[]
    createMany?: EmployeeCreateManyCompanyInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type WorkerCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WorkerCreateWithoutCompanyInput, WorkerUncheckedCreateWithoutCompanyInput> | WorkerCreateWithoutCompanyInput[] | WorkerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCompanyInput | WorkerCreateOrConnectWithoutCompanyInput[]
    createMany?: WorkerCreateManyCompanyInputEnvelope
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AttendanceCreateWithoutCompanyInput, AttendanceUncheckedCreateWithoutCompanyInput> | AttendanceCreateWithoutCompanyInput[] | AttendanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutCompanyInput | AttendanceCreateOrConnectWithoutCompanyInput[]
    createMany?: AttendanceCreateManyCompanyInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AttendanceEventCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AttendanceEventCreateWithoutCompanyInput, AttendanceEventUncheckedCreateWithoutCompanyInput> | AttendanceEventCreateWithoutCompanyInput[] | AttendanceEventUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutCompanyInput | AttendanceEventCreateOrConnectWithoutCompanyInput[]
    createMany?: AttendanceEventCreateManyCompanyInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type AttendanceDailySummaryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutCompanyInput, AttendanceDailySummaryUncheckedCreateWithoutCompanyInput> | AttendanceDailySummaryCreateWithoutCompanyInput[] | AttendanceDailySummaryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutCompanyInput | AttendanceDailySummaryCreateOrConnectWithoutCompanyInput[]
    createMany?: AttendanceDailySummaryCreateManyCompanyInputEnvelope
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ScheduleCreateWithoutCompanyInput, ScheduleUncheckedCreateWithoutCompanyInput> | ScheduleCreateWithoutCompanyInput[] | ScheduleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutCompanyInput | ScheduleCreateOrConnectWithoutCompanyInput[]
    createMany?: ScheduleCreateManyCompanyInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type OvertimeCreateNestedManyWithoutCompanyInput = {
    create?: XOR<OvertimeCreateWithoutCompanyInput, OvertimeUncheckedCreateWithoutCompanyInput> | OvertimeCreateWithoutCompanyInput[] | OvertimeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutCompanyInput | OvertimeCreateOrConnectWithoutCompanyInput[]
    createMany?: OvertimeCreateManyCompanyInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type AttendanceSummaryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AttendanceSummaryCreateWithoutCompanyInput, AttendanceSummaryUncheckedCreateWithoutCompanyInput> | AttendanceSummaryCreateWithoutCompanyInput[] | AttendanceSummaryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutCompanyInput | AttendanceSummaryCreateOrConnectWithoutCompanyInput[]
    createMany?: AttendanceSummaryCreateManyCompanyInputEnvelope
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
  }

  export type PayrollCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PayrollCreateWithoutCompanyInput, PayrollUncheckedCreateWithoutCompanyInput> | PayrollCreateWithoutCompanyInput[] | PayrollUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutCompanyInput | PayrollCreateOrConnectWithoutCompanyInput[]
    createMany?: PayrollCreateManyCompanyInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type PayrollPeriodCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PayrollPeriodCreateWithoutCompanyInput, PayrollPeriodUncheckedCreateWithoutCompanyInput> | PayrollPeriodCreateWithoutCompanyInput[] | PayrollPeriodUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutCompanyInput | PayrollPeriodCreateOrConnectWithoutCompanyInput[]
    createMany?: PayrollPeriodCreateManyCompanyInputEnvelope
    connect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
  }

  export type PayrollLineCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PayrollLineCreateWithoutCompanyInput, PayrollLineUncheckedCreateWithoutCompanyInput> | PayrollLineCreateWithoutCompanyInput[] | PayrollLineUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutCompanyInput | PayrollLineCreateOrConnectWithoutCompanyInput[]
    createMany?: PayrollLineCreateManyCompanyInputEnvelope
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
  }

  export type ContractCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContractCreateWithoutCompanyInput, ContractUncheckedCreateWithoutCompanyInput> | ContractCreateWithoutCompanyInput[] | ContractUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutCompanyInput | ContractCreateOrConnectWithoutCompanyInput[]
    createMany?: ContractCreateManyCompanyInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type PayrollExportCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PayrollExportCreateWithoutCompanyInput, PayrollExportUncheckedCreateWithoutCompanyInput> | PayrollExportCreateWithoutCompanyInput[] | PayrollExportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollExportCreateOrConnectWithoutCompanyInput | PayrollExportCreateOrConnectWithoutCompanyInput[]
    createMany?: PayrollExportCreateManyCompanyInputEnvelope
    connect?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput> | ReportCreateWithoutCompanyInput[] | ReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCompanyInput | ReportCreateOrConnectWithoutCompanyInput[]
    createMany?: ReportCreateManyCompanyInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type SchoolClassCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SchoolClassCreateWithoutCompanyInput, SchoolClassUncheckedCreateWithoutCompanyInput> | SchoolClassCreateWithoutCompanyInput[] | SchoolClassUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SchoolClassCreateOrConnectWithoutCompanyInput | SchoolClassCreateOrConnectWithoutCompanyInput[]
    createMany?: SchoolClassCreateManyCompanyInputEnvelope
    connect?: SchoolClassWhereUniqueInput | SchoolClassWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CourseCreateWithoutCompanyInput, CourseUncheckedCreateWithoutCompanyInput> | CourseCreateWithoutCompanyInput[] | CourseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCompanyInput | CourseCreateOrConnectWithoutCompanyInput[]
    createMany?: CourseCreateManyCompanyInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<StudentCreateWithoutCompanyInput, StudentUncheckedCreateWithoutCompanyInput> | StudentCreateWithoutCompanyInput[] | StudentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCompanyInput | StudentCreateOrConnectWithoutCompanyInput[]
    createMany?: StudentCreateManyCompanyInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentAttendanceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<StudentAttendanceCreateWithoutCompanyInput, StudentAttendanceUncheckedCreateWithoutCompanyInput> | StudentAttendanceCreateWithoutCompanyInput[] | StudentAttendanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutCompanyInput | StudentAttendanceCreateOrConnectWithoutCompanyInput[]
    createMany?: StudentAttendanceCreateManyCompanyInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type LeaveTypeCreateNestedManyWithoutCompanyInput = {
    create?: XOR<LeaveTypeCreateWithoutCompanyInput, LeaveTypeUncheckedCreateWithoutCompanyInput> | LeaveTypeCreateWithoutCompanyInput[] | LeaveTypeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutCompanyInput | LeaveTypeCreateOrConnectWithoutCompanyInput[]
    createMany?: LeaveTypeCreateManyCompanyInputEnvelope
    connect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
  }

  export type LeaveBalanceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<LeaveBalanceCreateWithoutCompanyInput, LeaveBalanceUncheckedCreateWithoutCompanyInput> | LeaveBalanceCreateWithoutCompanyInput[] | LeaveBalanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutCompanyInput | LeaveBalanceCreateOrConnectWithoutCompanyInput[]
    createMany?: LeaveBalanceCreateManyCompanyInputEnvelope
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutCompanyInput = {
    create?: XOR<LeaveRequestCreateWithoutCompanyInput, LeaveRequestUncheckedCreateWithoutCompanyInput> | LeaveRequestCreateWithoutCompanyInput[] | LeaveRequestUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutCompanyInput | LeaveRequestCreateOrConnectWithoutCompanyInput[]
    createMany?: LeaveRequestCreateManyCompanyInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type PublicHolidayCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PublicHolidayCreateWithoutCompanyInput, PublicHolidayUncheckedCreateWithoutCompanyInput> | PublicHolidayCreateWithoutCompanyInput[] | PublicHolidayUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PublicHolidayCreateOrConnectWithoutCompanyInput | PublicHolidayCreateOrConnectWithoutCompanyInput[]
    createMany?: PublicHolidayCreateManyCompanyInputEnvelope
    connect?: PublicHolidayWhereUniqueInput | PublicHolidayWhereUniqueInput[]
  }

  export type ConstructionSiteCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ConstructionSiteCreateWithoutCompanyInput, ConstructionSiteUncheckedCreateWithoutCompanyInput> | ConstructionSiteCreateWithoutCompanyInput[] | ConstructionSiteUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ConstructionSiteCreateOrConnectWithoutCompanyInput | ConstructionSiteCreateOrConnectWithoutCompanyInput[]
    createMany?: ConstructionSiteCreateManyCompanyInputEnvelope
    connect?: ConstructionSiteWhereUniqueInput | ConstructionSiteWhereUniqueInput[]
  }

  export type ConstructionTeamCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ConstructionTeamCreateWithoutCompanyInput, ConstructionTeamUncheckedCreateWithoutCompanyInput> | ConstructionTeamCreateWithoutCompanyInput[] | ConstructionTeamUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ConstructionTeamCreateOrConnectWithoutCompanyInput | ConstructionTeamCreateOrConnectWithoutCompanyInput[]
    createMany?: ConstructionTeamCreateManyCompanyInputEnvelope
    connect?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
  }

  export type ConstructionWorkerCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ConstructionWorkerCreateWithoutCompanyInput, ConstructionWorkerUncheckedCreateWithoutCompanyInput> | ConstructionWorkerCreateWithoutCompanyInput[] | ConstructionWorkerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutCompanyInput | ConstructionWorkerCreateOrConnectWithoutCompanyInput[]
    createMany?: ConstructionWorkerCreateManyCompanyInputEnvelope
    connect?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
  }

  export type SiteAttendanceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SiteAttendanceCreateWithoutCompanyInput, SiteAttendanceUncheckedCreateWithoutCompanyInput> | SiteAttendanceCreateWithoutCompanyInput[] | SiteAttendanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SiteAttendanceCreateOrConnectWithoutCompanyInput | SiteAttendanceCreateOrConnectWithoutCompanyInput[]
    createMany?: SiteAttendanceCreateManyCompanyInputEnvelope
    connect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserRoleCreateWithoutCompanyInput, UserRoleUncheckedCreateWithoutCompanyInput> | UserRoleCreateWithoutCompanyInput[] | UserRoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutCompanyInput | UserRoleCreateOrConnectWithoutCompanyInput[]
    createMany?: UserRoleCreateManyCompanyInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type DeviceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DeviceCreateWithoutCompanyInput, DeviceUncheckedCreateWithoutCompanyInput> | DeviceCreateWithoutCompanyInput[] | DeviceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutCompanyInput | DeviceCreateOrConnectWithoutCompanyInput[]
    createMany?: DeviceCreateManyCompanyInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type PeriodClosureCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PeriodClosureCreateWithoutCompanyInput, PeriodClosureUncheckedCreateWithoutCompanyInput> | PeriodClosureCreateWithoutCompanyInput[] | PeriodClosureUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PeriodClosureCreateOrConnectWithoutCompanyInput | PeriodClosureCreateOrConnectWithoutCompanyInput[]
    createMany?: PeriodClosureCreateManyCompanyInputEnvelope
    connect?: PeriodClosureWhereUniqueInput | PeriodClosureWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PersonUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PersonCreateWithoutCompanyInput, PersonUncheckedCreateWithoutCompanyInput> | PersonCreateWithoutCompanyInput[] | PersonUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutCompanyInput | PersonCreateOrConnectWithoutCompanyInput[]
    createMany?: PersonCreateManyCompanyInputEnvelope
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<EmployeeCreateWithoutCompanyInput, EmployeeUncheckedCreateWithoutCompanyInput> | EmployeeCreateWithoutCompanyInput[] | EmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutCompanyInput | EmployeeCreateOrConnectWithoutCompanyInput[]
    createMany?: EmployeeCreateManyCompanyInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type WorkerUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WorkerCreateWithoutCompanyInput, WorkerUncheckedCreateWithoutCompanyInput> | WorkerCreateWithoutCompanyInput[] | WorkerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCompanyInput | WorkerCreateOrConnectWithoutCompanyInput[]
    createMany?: WorkerCreateManyCompanyInputEnvelope
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AttendanceCreateWithoutCompanyInput, AttendanceUncheckedCreateWithoutCompanyInput> | AttendanceCreateWithoutCompanyInput[] | AttendanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutCompanyInput | AttendanceCreateOrConnectWithoutCompanyInput[]
    createMany?: AttendanceCreateManyCompanyInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AttendanceEventCreateWithoutCompanyInput, AttendanceEventUncheckedCreateWithoutCompanyInput> | AttendanceEventCreateWithoutCompanyInput[] | AttendanceEventUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutCompanyInput | AttendanceEventCreateOrConnectWithoutCompanyInput[]
    createMany?: AttendanceEventCreateManyCompanyInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutCompanyInput, AttendanceDailySummaryUncheckedCreateWithoutCompanyInput> | AttendanceDailySummaryCreateWithoutCompanyInput[] | AttendanceDailySummaryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutCompanyInput | AttendanceDailySummaryCreateOrConnectWithoutCompanyInput[]
    createMany?: AttendanceDailySummaryCreateManyCompanyInputEnvelope
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ScheduleCreateWithoutCompanyInput, ScheduleUncheckedCreateWithoutCompanyInput> | ScheduleCreateWithoutCompanyInput[] | ScheduleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutCompanyInput | ScheduleCreateOrConnectWithoutCompanyInput[]
    createMany?: ScheduleCreateManyCompanyInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type OvertimeUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<OvertimeCreateWithoutCompanyInput, OvertimeUncheckedCreateWithoutCompanyInput> | OvertimeCreateWithoutCompanyInput[] | OvertimeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutCompanyInput | OvertimeCreateOrConnectWithoutCompanyInput[]
    createMany?: OvertimeCreateManyCompanyInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AttendanceSummaryCreateWithoutCompanyInput, AttendanceSummaryUncheckedCreateWithoutCompanyInput> | AttendanceSummaryCreateWithoutCompanyInput[] | AttendanceSummaryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutCompanyInput | AttendanceSummaryCreateOrConnectWithoutCompanyInput[]
    createMany?: AttendanceSummaryCreateManyCompanyInputEnvelope
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
  }

  export type PayrollUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PayrollCreateWithoutCompanyInput, PayrollUncheckedCreateWithoutCompanyInput> | PayrollCreateWithoutCompanyInput[] | PayrollUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutCompanyInput | PayrollCreateOrConnectWithoutCompanyInput[]
    createMany?: PayrollCreateManyCompanyInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PayrollPeriodCreateWithoutCompanyInput, PayrollPeriodUncheckedCreateWithoutCompanyInput> | PayrollPeriodCreateWithoutCompanyInput[] | PayrollPeriodUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutCompanyInput | PayrollPeriodCreateOrConnectWithoutCompanyInput[]
    createMany?: PayrollPeriodCreateManyCompanyInputEnvelope
    connect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
  }

  export type PayrollLineUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PayrollLineCreateWithoutCompanyInput, PayrollLineUncheckedCreateWithoutCompanyInput> | PayrollLineCreateWithoutCompanyInput[] | PayrollLineUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutCompanyInput | PayrollLineCreateOrConnectWithoutCompanyInput[]
    createMany?: PayrollLineCreateManyCompanyInputEnvelope
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContractCreateWithoutCompanyInput, ContractUncheckedCreateWithoutCompanyInput> | ContractCreateWithoutCompanyInput[] | ContractUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutCompanyInput | ContractCreateOrConnectWithoutCompanyInput[]
    createMany?: ContractCreateManyCompanyInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type PayrollExportUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PayrollExportCreateWithoutCompanyInput, PayrollExportUncheckedCreateWithoutCompanyInput> | PayrollExportCreateWithoutCompanyInput[] | PayrollExportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollExportCreateOrConnectWithoutCompanyInput | PayrollExportCreateOrConnectWithoutCompanyInput[]
    createMany?: PayrollExportCreateManyCompanyInputEnvelope
    connect?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput> | ReportCreateWithoutCompanyInput[] | ReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCompanyInput | ReportCreateOrConnectWithoutCompanyInput[]
    createMany?: ReportCreateManyCompanyInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type SchoolClassUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SchoolClassCreateWithoutCompanyInput, SchoolClassUncheckedCreateWithoutCompanyInput> | SchoolClassCreateWithoutCompanyInput[] | SchoolClassUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SchoolClassCreateOrConnectWithoutCompanyInput | SchoolClassCreateOrConnectWithoutCompanyInput[]
    createMany?: SchoolClassCreateManyCompanyInputEnvelope
    connect?: SchoolClassWhereUniqueInput | SchoolClassWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CourseCreateWithoutCompanyInput, CourseUncheckedCreateWithoutCompanyInput> | CourseCreateWithoutCompanyInput[] | CourseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCompanyInput | CourseCreateOrConnectWithoutCompanyInput[]
    createMany?: CourseCreateManyCompanyInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<StudentCreateWithoutCompanyInput, StudentUncheckedCreateWithoutCompanyInput> | StudentCreateWithoutCompanyInput[] | StudentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCompanyInput | StudentCreateOrConnectWithoutCompanyInput[]
    createMany?: StudentCreateManyCompanyInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<StudentAttendanceCreateWithoutCompanyInput, StudentAttendanceUncheckedCreateWithoutCompanyInput> | StudentAttendanceCreateWithoutCompanyInput[] | StudentAttendanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutCompanyInput | StudentAttendanceCreateOrConnectWithoutCompanyInput[]
    createMany?: StudentAttendanceCreateManyCompanyInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<LeaveTypeCreateWithoutCompanyInput, LeaveTypeUncheckedCreateWithoutCompanyInput> | LeaveTypeCreateWithoutCompanyInput[] | LeaveTypeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutCompanyInput | LeaveTypeCreateOrConnectWithoutCompanyInput[]
    createMany?: LeaveTypeCreateManyCompanyInputEnvelope
    connect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
  }

  export type LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<LeaveBalanceCreateWithoutCompanyInput, LeaveBalanceUncheckedCreateWithoutCompanyInput> | LeaveBalanceCreateWithoutCompanyInput[] | LeaveBalanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutCompanyInput | LeaveBalanceCreateOrConnectWithoutCompanyInput[]
    createMany?: LeaveBalanceCreateManyCompanyInputEnvelope
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<LeaveRequestCreateWithoutCompanyInput, LeaveRequestUncheckedCreateWithoutCompanyInput> | LeaveRequestCreateWithoutCompanyInput[] | LeaveRequestUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutCompanyInput | LeaveRequestCreateOrConnectWithoutCompanyInput[]
    createMany?: LeaveRequestCreateManyCompanyInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PublicHolidayCreateWithoutCompanyInput, PublicHolidayUncheckedCreateWithoutCompanyInput> | PublicHolidayCreateWithoutCompanyInput[] | PublicHolidayUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PublicHolidayCreateOrConnectWithoutCompanyInput | PublicHolidayCreateOrConnectWithoutCompanyInput[]
    createMany?: PublicHolidayCreateManyCompanyInputEnvelope
    connect?: PublicHolidayWhereUniqueInput | PublicHolidayWhereUniqueInput[]
  }

  export type ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ConstructionSiteCreateWithoutCompanyInput, ConstructionSiteUncheckedCreateWithoutCompanyInput> | ConstructionSiteCreateWithoutCompanyInput[] | ConstructionSiteUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ConstructionSiteCreateOrConnectWithoutCompanyInput | ConstructionSiteCreateOrConnectWithoutCompanyInput[]
    createMany?: ConstructionSiteCreateManyCompanyInputEnvelope
    connect?: ConstructionSiteWhereUniqueInput | ConstructionSiteWhereUniqueInput[]
  }

  export type ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ConstructionTeamCreateWithoutCompanyInput, ConstructionTeamUncheckedCreateWithoutCompanyInput> | ConstructionTeamCreateWithoutCompanyInput[] | ConstructionTeamUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ConstructionTeamCreateOrConnectWithoutCompanyInput | ConstructionTeamCreateOrConnectWithoutCompanyInput[]
    createMany?: ConstructionTeamCreateManyCompanyInputEnvelope
    connect?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
  }

  export type ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ConstructionWorkerCreateWithoutCompanyInput, ConstructionWorkerUncheckedCreateWithoutCompanyInput> | ConstructionWorkerCreateWithoutCompanyInput[] | ConstructionWorkerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutCompanyInput | ConstructionWorkerCreateOrConnectWithoutCompanyInput[]
    createMany?: ConstructionWorkerCreateManyCompanyInputEnvelope
    connect?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
  }

  export type SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SiteAttendanceCreateWithoutCompanyInput, SiteAttendanceUncheckedCreateWithoutCompanyInput> | SiteAttendanceCreateWithoutCompanyInput[] | SiteAttendanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SiteAttendanceCreateOrConnectWithoutCompanyInput | SiteAttendanceCreateOrConnectWithoutCompanyInput[]
    createMany?: SiteAttendanceCreateManyCompanyInputEnvelope
    connect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserRoleCreateWithoutCompanyInput, UserRoleUncheckedCreateWithoutCompanyInput> | UserRoleCreateWithoutCompanyInput[] | UserRoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutCompanyInput | UserRoleCreateOrConnectWithoutCompanyInput[]
    createMany?: UserRoleCreateManyCompanyInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type DeviceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DeviceCreateWithoutCompanyInput, DeviceUncheckedCreateWithoutCompanyInput> | DeviceCreateWithoutCompanyInput[] | DeviceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutCompanyInput | DeviceCreateOrConnectWithoutCompanyInput[]
    createMany?: DeviceCreateManyCompanyInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PeriodClosureCreateWithoutCompanyInput, PeriodClosureUncheckedCreateWithoutCompanyInput> | PeriodClosureCreateWithoutCompanyInput[] | PeriodClosureUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PeriodClosureCreateOrConnectWithoutCompanyInput | PeriodClosureCreateOrConnectWithoutCompanyInput[]
    createMany?: PeriodClosureCreateManyCompanyInputEnvelope
    connect?: PeriodClosureWhereUniqueInput | PeriodClosureWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumCompanyTypeFieldUpdateOperationsInput = {
    set?: $Enums.CompanyType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PersonUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PersonCreateWithoutCompanyInput, PersonUncheckedCreateWithoutCompanyInput> | PersonCreateWithoutCompanyInput[] | PersonUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutCompanyInput | PersonCreateOrConnectWithoutCompanyInput[]
    upsert?: PersonUpsertWithWhereUniqueWithoutCompanyInput | PersonUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PersonCreateManyCompanyInputEnvelope
    set?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    disconnect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    delete?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    update?: PersonUpdateWithWhereUniqueWithoutCompanyInput | PersonUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PersonUpdateManyWithWhereWithoutCompanyInput | PersonUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PersonScalarWhereInput | PersonScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<EmployeeCreateWithoutCompanyInput, EmployeeUncheckedCreateWithoutCompanyInput> | EmployeeCreateWithoutCompanyInput[] | EmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutCompanyInput | EmployeeCreateOrConnectWithoutCompanyInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutCompanyInput | EmployeeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: EmployeeCreateManyCompanyInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutCompanyInput | EmployeeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutCompanyInput | EmployeeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type WorkerUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WorkerCreateWithoutCompanyInput, WorkerUncheckedCreateWithoutCompanyInput> | WorkerCreateWithoutCompanyInput[] | WorkerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCompanyInput | WorkerCreateOrConnectWithoutCompanyInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutCompanyInput | WorkerUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WorkerCreateManyCompanyInputEnvelope
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutCompanyInput | WorkerUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutCompanyInput | WorkerUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AttendanceCreateWithoutCompanyInput, AttendanceUncheckedCreateWithoutCompanyInput> | AttendanceCreateWithoutCompanyInput[] | AttendanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutCompanyInput | AttendanceCreateOrConnectWithoutCompanyInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutCompanyInput | AttendanceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AttendanceCreateManyCompanyInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutCompanyInput | AttendanceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutCompanyInput | AttendanceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AttendanceEventUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutCompanyInput, AttendanceEventUncheckedCreateWithoutCompanyInput> | AttendanceEventCreateWithoutCompanyInput[] | AttendanceEventUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutCompanyInput | AttendanceEventCreateOrConnectWithoutCompanyInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutCompanyInput | AttendanceEventUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AttendanceEventCreateManyCompanyInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutCompanyInput | AttendanceEventUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutCompanyInput | AttendanceEventUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutCompanyInput, AttendanceDailySummaryUncheckedCreateWithoutCompanyInput> | AttendanceDailySummaryCreateWithoutCompanyInput[] | AttendanceDailySummaryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutCompanyInput | AttendanceDailySummaryCreateOrConnectWithoutCompanyInput[]
    upsert?: AttendanceDailySummaryUpsertWithWhereUniqueWithoutCompanyInput | AttendanceDailySummaryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AttendanceDailySummaryCreateManyCompanyInputEnvelope
    set?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    disconnect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    delete?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    update?: AttendanceDailySummaryUpdateWithWhereUniqueWithoutCompanyInput | AttendanceDailySummaryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AttendanceDailySummaryUpdateManyWithWhereWithoutCompanyInput | AttendanceDailySummaryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AttendanceDailySummaryScalarWhereInput | AttendanceDailySummaryScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ScheduleCreateWithoutCompanyInput, ScheduleUncheckedCreateWithoutCompanyInput> | ScheduleCreateWithoutCompanyInput[] | ScheduleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutCompanyInput | ScheduleCreateOrConnectWithoutCompanyInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutCompanyInput | ScheduleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ScheduleCreateManyCompanyInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutCompanyInput | ScheduleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutCompanyInput | ScheduleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type OvertimeUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<OvertimeCreateWithoutCompanyInput, OvertimeUncheckedCreateWithoutCompanyInput> | OvertimeCreateWithoutCompanyInput[] | OvertimeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutCompanyInput | OvertimeCreateOrConnectWithoutCompanyInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutCompanyInput | OvertimeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: OvertimeCreateManyCompanyInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutCompanyInput | OvertimeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutCompanyInput | OvertimeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type AttendanceSummaryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutCompanyInput, AttendanceSummaryUncheckedCreateWithoutCompanyInput> | AttendanceSummaryCreateWithoutCompanyInput[] | AttendanceSummaryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutCompanyInput | AttendanceSummaryCreateOrConnectWithoutCompanyInput[]
    upsert?: AttendanceSummaryUpsertWithWhereUniqueWithoutCompanyInput | AttendanceSummaryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AttendanceSummaryCreateManyCompanyInputEnvelope
    set?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    disconnect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    delete?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    update?: AttendanceSummaryUpdateWithWhereUniqueWithoutCompanyInput | AttendanceSummaryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AttendanceSummaryUpdateManyWithWhereWithoutCompanyInput | AttendanceSummaryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
  }

  export type PayrollUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PayrollCreateWithoutCompanyInput, PayrollUncheckedCreateWithoutCompanyInput> | PayrollCreateWithoutCompanyInput[] | PayrollUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutCompanyInput | PayrollCreateOrConnectWithoutCompanyInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutCompanyInput | PayrollUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PayrollCreateManyCompanyInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutCompanyInput | PayrollUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutCompanyInput | PayrollUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type PayrollPeriodUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PayrollPeriodCreateWithoutCompanyInput, PayrollPeriodUncheckedCreateWithoutCompanyInput> | PayrollPeriodCreateWithoutCompanyInput[] | PayrollPeriodUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutCompanyInput | PayrollPeriodCreateOrConnectWithoutCompanyInput[]
    upsert?: PayrollPeriodUpsertWithWhereUniqueWithoutCompanyInput | PayrollPeriodUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PayrollPeriodCreateManyCompanyInputEnvelope
    set?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    disconnect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    delete?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    connect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    update?: PayrollPeriodUpdateWithWhereUniqueWithoutCompanyInput | PayrollPeriodUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PayrollPeriodUpdateManyWithWhereWithoutCompanyInput | PayrollPeriodUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PayrollPeriodScalarWhereInput | PayrollPeriodScalarWhereInput[]
  }

  export type PayrollLineUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PayrollLineCreateWithoutCompanyInput, PayrollLineUncheckedCreateWithoutCompanyInput> | PayrollLineCreateWithoutCompanyInput[] | PayrollLineUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutCompanyInput | PayrollLineCreateOrConnectWithoutCompanyInput[]
    upsert?: PayrollLineUpsertWithWhereUniqueWithoutCompanyInput | PayrollLineUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PayrollLineCreateManyCompanyInputEnvelope
    set?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    disconnect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    delete?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    update?: PayrollLineUpdateWithWhereUniqueWithoutCompanyInput | PayrollLineUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PayrollLineUpdateManyWithWhereWithoutCompanyInput | PayrollLineUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
  }

  export type ContractUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContractCreateWithoutCompanyInput, ContractUncheckedCreateWithoutCompanyInput> | ContractCreateWithoutCompanyInput[] | ContractUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutCompanyInput | ContractCreateOrConnectWithoutCompanyInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutCompanyInput | ContractUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContractCreateManyCompanyInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutCompanyInput | ContractUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutCompanyInput | ContractUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type PayrollExportUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PayrollExportCreateWithoutCompanyInput, PayrollExportUncheckedCreateWithoutCompanyInput> | PayrollExportCreateWithoutCompanyInput[] | PayrollExportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollExportCreateOrConnectWithoutCompanyInput | PayrollExportCreateOrConnectWithoutCompanyInput[]
    upsert?: PayrollExportUpsertWithWhereUniqueWithoutCompanyInput | PayrollExportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PayrollExportCreateManyCompanyInputEnvelope
    set?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    disconnect?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    delete?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    connect?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    update?: PayrollExportUpdateWithWhereUniqueWithoutCompanyInput | PayrollExportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PayrollExportUpdateManyWithWhereWithoutCompanyInput | PayrollExportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PayrollExportScalarWhereInput | PayrollExportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput> | ReportCreateWithoutCompanyInput[] | ReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCompanyInput | ReportCreateOrConnectWithoutCompanyInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCompanyInput | ReportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ReportCreateManyCompanyInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCompanyInput | ReportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCompanyInput | ReportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type SchoolClassUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SchoolClassCreateWithoutCompanyInput, SchoolClassUncheckedCreateWithoutCompanyInput> | SchoolClassCreateWithoutCompanyInput[] | SchoolClassUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SchoolClassCreateOrConnectWithoutCompanyInput | SchoolClassCreateOrConnectWithoutCompanyInput[]
    upsert?: SchoolClassUpsertWithWhereUniqueWithoutCompanyInput | SchoolClassUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SchoolClassCreateManyCompanyInputEnvelope
    set?: SchoolClassWhereUniqueInput | SchoolClassWhereUniqueInput[]
    disconnect?: SchoolClassWhereUniqueInput | SchoolClassWhereUniqueInput[]
    delete?: SchoolClassWhereUniqueInput | SchoolClassWhereUniqueInput[]
    connect?: SchoolClassWhereUniqueInput | SchoolClassWhereUniqueInput[]
    update?: SchoolClassUpdateWithWhereUniqueWithoutCompanyInput | SchoolClassUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SchoolClassUpdateManyWithWhereWithoutCompanyInput | SchoolClassUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SchoolClassScalarWhereInput | SchoolClassScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CourseCreateWithoutCompanyInput, CourseUncheckedCreateWithoutCompanyInput> | CourseCreateWithoutCompanyInput[] | CourseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCompanyInput | CourseCreateOrConnectWithoutCompanyInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCompanyInput | CourseUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CourseCreateManyCompanyInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCompanyInput | CourseUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCompanyInput | CourseUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<StudentCreateWithoutCompanyInput, StudentUncheckedCreateWithoutCompanyInput> | StudentCreateWithoutCompanyInput[] | StudentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCompanyInput | StudentCreateOrConnectWithoutCompanyInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutCompanyInput | StudentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: StudentCreateManyCompanyInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutCompanyInput | StudentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutCompanyInput | StudentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentAttendanceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutCompanyInput, StudentAttendanceUncheckedCreateWithoutCompanyInput> | StudentAttendanceCreateWithoutCompanyInput[] | StudentAttendanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutCompanyInput | StudentAttendanceCreateOrConnectWithoutCompanyInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutCompanyInput | StudentAttendanceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: StudentAttendanceCreateManyCompanyInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutCompanyInput | StudentAttendanceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutCompanyInput | StudentAttendanceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type LeaveTypeUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<LeaveTypeCreateWithoutCompanyInput, LeaveTypeUncheckedCreateWithoutCompanyInput> | LeaveTypeCreateWithoutCompanyInput[] | LeaveTypeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutCompanyInput | LeaveTypeCreateOrConnectWithoutCompanyInput[]
    upsert?: LeaveTypeUpsertWithWhereUniqueWithoutCompanyInput | LeaveTypeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: LeaveTypeCreateManyCompanyInputEnvelope
    set?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    disconnect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    delete?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    connect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    update?: LeaveTypeUpdateWithWhereUniqueWithoutCompanyInput | LeaveTypeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: LeaveTypeUpdateManyWithWhereWithoutCompanyInput | LeaveTypeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: LeaveTypeScalarWhereInput | LeaveTypeScalarWhereInput[]
  }

  export type LeaveBalanceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutCompanyInput, LeaveBalanceUncheckedCreateWithoutCompanyInput> | LeaveBalanceCreateWithoutCompanyInput[] | LeaveBalanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutCompanyInput | LeaveBalanceCreateOrConnectWithoutCompanyInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutCompanyInput | LeaveBalanceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: LeaveBalanceCreateManyCompanyInputEnvelope
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutCompanyInput | LeaveBalanceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutCompanyInput | LeaveBalanceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutCompanyInput, LeaveRequestUncheckedCreateWithoutCompanyInput> | LeaveRequestCreateWithoutCompanyInput[] | LeaveRequestUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutCompanyInput | LeaveRequestCreateOrConnectWithoutCompanyInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutCompanyInput | LeaveRequestUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: LeaveRequestCreateManyCompanyInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutCompanyInput | LeaveRequestUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutCompanyInput | LeaveRequestUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type PublicHolidayUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PublicHolidayCreateWithoutCompanyInput, PublicHolidayUncheckedCreateWithoutCompanyInput> | PublicHolidayCreateWithoutCompanyInput[] | PublicHolidayUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PublicHolidayCreateOrConnectWithoutCompanyInput | PublicHolidayCreateOrConnectWithoutCompanyInput[]
    upsert?: PublicHolidayUpsertWithWhereUniqueWithoutCompanyInput | PublicHolidayUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PublicHolidayCreateManyCompanyInputEnvelope
    set?: PublicHolidayWhereUniqueInput | PublicHolidayWhereUniqueInput[]
    disconnect?: PublicHolidayWhereUniqueInput | PublicHolidayWhereUniqueInput[]
    delete?: PublicHolidayWhereUniqueInput | PublicHolidayWhereUniqueInput[]
    connect?: PublicHolidayWhereUniqueInput | PublicHolidayWhereUniqueInput[]
    update?: PublicHolidayUpdateWithWhereUniqueWithoutCompanyInput | PublicHolidayUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PublicHolidayUpdateManyWithWhereWithoutCompanyInput | PublicHolidayUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PublicHolidayScalarWhereInput | PublicHolidayScalarWhereInput[]
  }

  export type ConstructionSiteUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ConstructionSiteCreateWithoutCompanyInput, ConstructionSiteUncheckedCreateWithoutCompanyInput> | ConstructionSiteCreateWithoutCompanyInput[] | ConstructionSiteUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ConstructionSiteCreateOrConnectWithoutCompanyInput | ConstructionSiteCreateOrConnectWithoutCompanyInput[]
    upsert?: ConstructionSiteUpsertWithWhereUniqueWithoutCompanyInput | ConstructionSiteUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ConstructionSiteCreateManyCompanyInputEnvelope
    set?: ConstructionSiteWhereUniqueInput | ConstructionSiteWhereUniqueInput[]
    disconnect?: ConstructionSiteWhereUniqueInput | ConstructionSiteWhereUniqueInput[]
    delete?: ConstructionSiteWhereUniqueInput | ConstructionSiteWhereUniqueInput[]
    connect?: ConstructionSiteWhereUniqueInput | ConstructionSiteWhereUniqueInput[]
    update?: ConstructionSiteUpdateWithWhereUniqueWithoutCompanyInput | ConstructionSiteUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ConstructionSiteUpdateManyWithWhereWithoutCompanyInput | ConstructionSiteUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ConstructionSiteScalarWhereInput | ConstructionSiteScalarWhereInput[]
  }

  export type ConstructionTeamUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ConstructionTeamCreateWithoutCompanyInput, ConstructionTeamUncheckedCreateWithoutCompanyInput> | ConstructionTeamCreateWithoutCompanyInput[] | ConstructionTeamUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ConstructionTeamCreateOrConnectWithoutCompanyInput | ConstructionTeamCreateOrConnectWithoutCompanyInput[]
    upsert?: ConstructionTeamUpsertWithWhereUniqueWithoutCompanyInput | ConstructionTeamUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ConstructionTeamCreateManyCompanyInputEnvelope
    set?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    disconnect?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    delete?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    connect?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    update?: ConstructionTeamUpdateWithWhereUniqueWithoutCompanyInput | ConstructionTeamUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ConstructionTeamUpdateManyWithWhereWithoutCompanyInput | ConstructionTeamUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ConstructionTeamScalarWhereInput | ConstructionTeamScalarWhereInput[]
  }

  export type ConstructionWorkerUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ConstructionWorkerCreateWithoutCompanyInput, ConstructionWorkerUncheckedCreateWithoutCompanyInput> | ConstructionWorkerCreateWithoutCompanyInput[] | ConstructionWorkerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutCompanyInput | ConstructionWorkerCreateOrConnectWithoutCompanyInput[]
    upsert?: ConstructionWorkerUpsertWithWhereUniqueWithoutCompanyInput | ConstructionWorkerUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ConstructionWorkerCreateManyCompanyInputEnvelope
    set?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    disconnect?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    delete?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    connect?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    update?: ConstructionWorkerUpdateWithWhereUniqueWithoutCompanyInput | ConstructionWorkerUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ConstructionWorkerUpdateManyWithWhereWithoutCompanyInput | ConstructionWorkerUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ConstructionWorkerScalarWhereInput | ConstructionWorkerScalarWhereInput[]
  }

  export type SiteAttendanceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SiteAttendanceCreateWithoutCompanyInput, SiteAttendanceUncheckedCreateWithoutCompanyInput> | SiteAttendanceCreateWithoutCompanyInput[] | SiteAttendanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SiteAttendanceCreateOrConnectWithoutCompanyInput | SiteAttendanceCreateOrConnectWithoutCompanyInput[]
    upsert?: SiteAttendanceUpsertWithWhereUniqueWithoutCompanyInput | SiteAttendanceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SiteAttendanceCreateManyCompanyInputEnvelope
    set?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    disconnect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    delete?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    connect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    update?: SiteAttendanceUpdateWithWhereUniqueWithoutCompanyInput | SiteAttendanceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SiteAttendanceUpdateManyWithWhereWithoutCompanyInput | SiteAttendanceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SiteAttendanceScalarWhereInput | SiteAttendanceScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserRoleCreateWithoutCompanyInput, UserRoleUncheckedCreateWithoutCompanyInput> | UserRoleCreateWithoutCompanyInput[] | UserRoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutCompanyInput | UserRoleCreateOrConnectWithoutCompanyInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutCompanyInput | UserRoleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserRoleCreateManyCompanyInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutCompanyInput | UserRoleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutCompanyInput | UserRoleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type DeviceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DeviceCreateWithoutCompanyInput, DeviceUncheckedCreateWithoutCompanyInput> | DeviceCreateWithoutCompanyInput[] | DeviceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutCompanyInput | DeviceCreateOrConnectWithoutCompanyInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutCompanyInput | DeviceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DeviceCreateManyCompanyInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutCompanyInput | DeviceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutCompanyInput | DeviceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type PeriodClosureUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PeriodClosureCreateWithoutCompanyInput, PeriodClosureUncheckedCreateWithoutCompanyInput> | PeriodClosureCreateWithoutCompanyInput[] | PeriodClosureUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PeriodClosureCreateOrConnectWithoutCompanyInput | PeriodClosureCreateOrConnectWithoutCompanyInput[]
    upsert?: PeriodClosureUpsertWithWhereUniqueWithoutCompanyInput | PeriodClosureUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PeriodClosureCreateManyCompanyInputEnvelope
    set?: PeriodClosureWhereUniqueInput | PeriodClosureWhereUniqueInput[]
    disconnect?: PeriodClosureWhereUniqueInput | PeriodClosureWhereUniqueInput[]
    delete?: PeriodClosureWhereUniqueInput | PeriodClosureWhereUniqueInput[]
    connect?: PeriodClosureWhereUniqueInput | PeriodClosureWhereUniqueInput[]
    update?: PeriodClosureUpdateWithWhereUniqueWithoutCompanyInput | PeriodClosureUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PeriodClosureUpdateManyWithWhereWithoutCompanyInput | PeriodClosureUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PeriodClosureScalarWhereInput | PeriodClosureScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PersonUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PersonCreateWithoutCompanyInput, PersonUncheckedCreateWithoutCompanyInput> | PersonCreateWithoutCompanyInput[] | PersonUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutCompanyInput | PersonCreateOrConnectWithoutCompanyInput[]
    upsert?: PersonUpsertWithWhereUniqueWithoutCompanyInput | PersonUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PersonCreateManyCompanyInputEnvelope
    set?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    disconnect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    delete?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    update?: PersonUpdateWithWhereUniqueWithoutCompanyInput | PersonUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PersonUpdateManyWithWhereWithoutCompanyInput | PersonUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PersonScalarWhereInput | PersonScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<EmployeeCreateWithoutCompanyInput, EmployeeUncheckedCreateWithoutCompanyInput> | EmployeeCreateWithoutCompanyInput[] | EmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutCompanyInput | EmployeeCreateOrConnectWithoutCompanyInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutCompanyInput | EmployeeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: EmployeeCreateManyCompanyInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutCompanyInput | EmployeeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutCompanyInput | EmployeeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type WorkerUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WorkerCreateWithoutCompanyInput, WorkerUncheckedCreateWithoutCompanyInput> | WorkerCreateWithoutCompanyInput[] | WorkerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutCompanyInput | WorkerCreateOrConnectWithoutCompanyInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutCompanyInput | WorkerUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WorkerCreateManyCompanyInputEnvelope
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutCompanyInput | WorkerUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutCompanyInput | WorkerUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AttendanceCreateWithoutCompanyInput, AttendanceUncheckedCreateWithoutCompanyInput> | AttendanceCreateWithoutCompanyInput[] | AttendanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutCompanyInput | AttendanceCreateOrConnectWithoutCompanyInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutCompanyInput | AttendanceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AttendanceCreateManyCompanyInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutCompanyInput | AttendanceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutCompanyInput | AttendanceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutCompanyInput, AttendanceEventUncheckedCreateWithoutCompanyInput> | AttendanceEventCreateWithoutCompanyInput[] | AttendanceEventUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutCompanyInput | AttendanceEventCreateOrConnectWithoutCompanyInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutCompanyInput | AttendanceEventUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AttendanceEventCreateManyCompanyInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutCompanyInput | AttendanceEventUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutCompanyInput | AttendanceEventUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutCompanyInput, AttendanceDailySummaryUncheckedCreateWithoutCompanyInput> | AttendanceDailySummaryCreateWithoutCompanyInput[] | AttendanceDailySummaryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutCompanyInput | AttendanceDailySummaryCreateOrConnectWithoutCompanyInput[]
    upsert?: AttendanceDailySummaryUpsertWithWhereUniqueWithoutCompanyInput | AttendanceDailySummaryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AttendanceDailySummaryCreateManyCompanyInputEnvelope
    set?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    disconnect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    delete?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    update?: AttendanceDailySummaryUpdateWithWhereUniqueWithoutCompanyInput | AttendanceDailySummaryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AttendanceDailySummaryUpdateManyWithWhereWithoutCompanyInput | AttendanceDailySummaryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AttendanceDailySummaryScalarWhereInput | AttendanceDailySummaryScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ScheduleCreateWithoutCompanyInput, ScheduleUncheckedCreateWithoutCompanyInput> | ScheduleCreateWithoutCompanyInput[] | ScheduleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutCompanyInput | ScheduleCreateOrConnectWithoutCompanyInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutCompanyInput | ScheduleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ScheduleCreateManyCompanyInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutCompanyInput | ScheduleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutCompanyInput | ScheduleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type OvertimeUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<OvertimeCreateWithoutCompanyInput, OvertimeUncheckedCreateWithoutCompanyInput> | OvertimeCreateWithoutCompanyInput[] | OvertimeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutCompanyInput | OvertimeCreateOrConnectWithoutCompanyInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutCompanyInput | OvertimeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: OvertimeCreateManyCompanyInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutCompanyInput | OvertimeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutCompanyInput | OvertimeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutCompanyInput, AttendanceSummaryUncheckedCreateWithoutCompanyInput> | AttendanceSummaryCreateWithoutCompanyInput[] | AttendanceSummaryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutCompanyInput | AttendanceSummaryCreateOrConnectWithoutCompanyInput[]
    upsert?: AttendanceSummaryUpsertWithWhereUniqueWithoutCompanyInput | AttendanceSummaryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AttendanceSummaryCreateManyCompanyInputEnvelope
    set?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    disconnect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    delete?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    update?: AttendanceSummaryUpdateWithWhereUniqueWithoutCompanyInput | AttendanceSummaryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AttendanceSummaryUpdateManyWithWhereWithoutCompanyInput | AttendanceSummaryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
  }

  export type PayrollUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PayrollCreateWithoutCompanyInput, PayrollUncheckedCreateWithoutCompanyInput> | PayrollCreateWithoutCompanyInput[] | PayrollUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutCompanyInput | PayrollCreateOrConnectWithoutCompanyInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutCompanyInput | PayrollUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PayrollCreateManyCompanyInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutCompanyInput | PayrollUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutCompanyInput | PayrollUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PayrollPeriodCreateWithoutCompanyInput, PayrollPeriodUncheckedCreateWithoutCompanyInput> | PayrollPeriodCreateWithoutCompanyInput[] | PayrollPeriodUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutCompanyInput | PayrollPeriodCreateOrConnectWithoutCompanyInput[]
    upsert?: PayrollPeriodUpsertWithWhereUniqueWithoutCompanyInput | PayrollPeriodUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PayrollPeriodCreateManyCompanyInputEnvelope
    set?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    disconnect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    delete?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    connect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    update?: PayrollPeriodUpdateWithWhereUniqueWithoutCompanyInput | PayrollPeriodUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PayrollPeriodUpdateManyWithWhereWithoutCompanyInput | PayrollPeriodUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PayrollPeriodScalarWhereInput | PayrollPeriodScalarWhereInput[]
  }

  export type PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PayrollLineCreateWithoutCompanyInput, PayrollLineUncheckedCreateWithoutCompanyInput> | PayrollLineCreateWithoutCompanyInput[] | PayrollLineUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutCompanyInput | PayrollLineCreateOrConnectWithoutCompanyInput[]
    upsert?: PayrollLineUpsertWithWhereUniqueWithoutCompanyInput | PayrollLineUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PayrollLineCreateManyCompanyInputEnvelope
    set?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    disconnect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    delete?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    update?: PayrollLineUpdateWithWhereUniqueWithoutCompanyInput | PayrollLineUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PayrollLineUpdateManyWithWhereWithoutCompanyInput | PayrollLineUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContractCreateWithoutCompanyInput, ContractUncheckedCreateWithoutCompanyInput> | ContractCreateWithoutCompanyInput[] | ContractUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutCompanyInput | ContractCreateOrConnectWithoutCompanyInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutCompanyInput | ContractUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContractCreateManyCompanyInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutCompanyInput | ContractUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutCompanyInput | ContractUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PayrollExportCreateWithoutCompanyInput, PayrollExportUncheckedCreateWithoutCompanyInput> | PayrollExportCreateWithoutCompanyInput[] | PayrollExportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PayrollExportCreateOrConnectWithoutCompanyInput | PayrollExportCreateOrConnectWithoutCompanyInput[]
    upsert?: PayrollExportUpsertWithWhereUniqueWithoutCompanyInput | PayrollExportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PayrollExportCreateManyCompanyInputEnvelope
    set?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    disconnect?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    delete?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    connect?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    update?: PayrollExportUpdateWithWhereUniqueWithoutCompanyInput | PayrollExportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PayrollExportUpdateManyWithWhereWithoutCompanyInput | PayrollExportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PayrollExportScalarWhereInput | PayrollExportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput> | ReportCreateWithoutCompanyInput[] | ReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCompanyInput | ReportCreateOrConnectWithoutCompanyInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCompanyInput | ReportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ReportCreateManyCompanyInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCompanyInput | ReportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCompanyInput | ReportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SchoolClassCreateWithoutCompanyInput, SchoolClassUncheckedCreateWithoutCompanyInput> | SchoolClassCreateWithoutCompanyInput[] | SchoolClassUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SchoolClassCreateOrConnectWithoutCompanyInput | SchoolClassCreateOrConnectWithoutCompanyInput[]
    upsert?: SchoolClassUpsertWithWhereUniqueWithoutCompanyInput | SchoolClassUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SchoolClassCreateManyCompanyInputEnvelope
    set?: SchoolClassWhereUniqueInput | SchoolClassWhereUniqueInput[]
    disconnect?: SchoolClassWhereUniqueInput | SchoolClassWhereUniqueInput[]
    delete?: SchoolClassWhereUniqueInput | SchoolClassWhereUniqueInput[]
    connect?: SchoolClassWhereUniqueInput | SchoolClassWhereUniqueInput[]
    update?: SchoolClassUpdateWithWhereUniqueWithoutCompanyInput | SchoolClassUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SchoolClassUpdateManyWithWhereWithoutCompanyInput | SchoolClassUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SchoolClassScalarWhereInput | SchoolClassScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CourseCreateWithoutCompanyInput, CourseUncheckedCreateWithoutCompanyInput> | CourseCreateWithoutCompanyInput[] | CourseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCompanyInput | CourseCreateOrConnectWithoutCompanyInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCompanyInput | CourseUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CourseCreateManyCompanyInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCompanyInput | CourseUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCompanyInput | CourseUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<StudentCreateWithoutCompanyInput, StudentUncheckedCreateWithoutCompanyInput> | StudentCreateWithoutCompanyInput[] | StudentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCompanyInput | StudentCreateOrConnectWithoutCompanyInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutCompanyInput | StudentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: StudentCreateManyCompanyInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutCompanyInput | StudentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutCompanyInput | StudentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutCompanyInput, StudentAttendanceUncheckedCreateWithoutCompanyInput> | StudentAttendanceCreateWithoutCompanyInput[] | StudentAttendanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutCompanyInput | StudentAttendanceCreateOrConnectWithoutCompanyInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutCompanyInput | StudentAttendanceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: StudentAttendanceCreateManyCompanyInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutCompanyInput | StudentAttendanceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutCompanyInput | StudentAttendanceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<LeaveTypeCreateWithoutCompanyInput, LeaveTypeUncheckedCreateWithoutCompanyInput> | LeaveTypeCreateWithoutCompanyInput[] | LeaveTypeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutCompanyInput | LeaveTypeCreateOrConnectWithoutCompanyInput[]
    upsert?: LeaveTypeUpsertWithWhereUniqueWithoutCompanyInput | LeaveTypeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: LeaveTypeCreateManyCompanyInputEnvelope
    set?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    disconnect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    delete?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    connect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    update?: LeaveTypeUpdateWithWhereUniqueWithoutCompanyInput | LeaveTypeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: LeaveTypeUpdateManyWithWhereWithoutCompanyInput | LeaveTypeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: LeaveTypeScalarWhereInput | LeaveTypeScalarWhereInput[]
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutCompanyInput, LeaveBalanceUncheckedCreateWithoutCompanyInput> | LeaveBalanceCreateWithoutCompanyInput[] | LeaveBalanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutCompanyInput | LeaveBalanceCreateOrConnectWithoutCompanyInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutCompanyInput | LeaveBalanceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: LeaveBalanceCreateManyCompanyInputEnvelope
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutCompanyInput | LeaveBalanceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutCompanyInput | LeaveBalanceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutCompanyInput, LeaveRequestUncheckedCreateWithoutCompanyInput> | LeaveRequestCreateWithoutCompanyInput[] | LeaveRequestUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutCompanyInput | LeaveRequestCreateOrConnectWithoutCompanyInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutCompanyInput | LeaveRequestUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: LeaveRequestCreateManyCompanyInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutCompanyInput | LeaveRequestUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutCompanyInput | LeaveRequestUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PublicHolidayCreateWithoutCompanyInput, PublicHolidayUncheckedCreateWithoutCompanyInput> | PublicHolidayCreateWithoutCompanyInput[] | PublicHolidayUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PublicHolidayCreateOrConnectWithoutCompanyInput | PublicHolidayCreateOrConnectWithoutCompanyInput[]
    upsert?: PublicHolidayUpsertWithWhereUniqueWithoutCompanyInput | PublicHolidayUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PublicHolidayCreateManyCompanyInputEnvelope
    set?: PublicHolidayWhereUniqueInput | PublicHolidayWhereUniqueInput[]
    disconnect?: PublicHolidayWhereUniqueInput | PublicHolidayWhereUniqueInput[]
    delete?: PublicHolidayWhereUniqueInput | PublicHolidayWhereUniqueInput[]
    connect?: PublicHolidayWhereUniqueInput | PublicHolidayWhereUniqueInput[]
    update?: PublicHolidayUpdateWithWhereUniqueWithoutCompanyInput | PublicHolidayUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PublicHolidayUpdateManyWithWhereWithoutCompanyInput | PublicHolidayUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PublicHolidayScalarWhereInput | PublicHolidayScalarWhereInput[]
  }

  export type ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ConstructionSiteCreateWithoutCompanyInput, ConstructionSiteUncheckedCreateWithoutCompanyInput> | ConstructionSiteCreateWithoutCompanyInput[] | ConstructionSiteUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ConstructionSiteCreateOrConnectWithoutCompanyInput | ConstructionSiteCreateOrConnectWithoutCompanyInput[]
    upsert?: ConstructionSiteUpsertWithWhereUniqueWithoutCompanyInput | ConstructionSiteUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ConstructionSiteCreateManyCompanyInputEnvelope
    set?: ConstructionSiteWhereUniqueInput | ConstructionSiteWhereUniqueInput[]
    disconnect?: ConstructionSiteWhereUniqueInput | ConstructionSiteWhereUniqueInput[]
    delete?: ConstructionSiteWhereUniqueInput | ConstructionSiteWhereUniqueInput[]
    connect?: ConstructionSiteWhereUniqueInput | ConstructionSiteWhereUniqueInput[]
    update?: ConstructionSiteUpdateWithWhereUniqueWithoutCompanyInput | ConstructionSiteUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ConstructionSiteUpdateManyWithWhereWithoutCompanyInput | ConstructionSiteUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ConstructionSiteScalarWhereInput | ConstructionSiteScalarWhereInput[]
  }

  export type ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ConstructionTeamCreateWithoutCompanyInput, ConstructionTeamUncheckedCreateWithoutCompanyInput> | ConstructionTeamCreateWithoutCompanyInput[] | ConstructionTeamUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ConstructionTeamCreateOrConnectWithoutCompanyInput | ConstructionTeamCreateOrConnectWithoutCompanyInput[]
    upsert?: ConstructionTeamUpsertWithWhereUniqueWithoutCompanyInput | ConstructionTeamUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ConstructionTeamCreateManyCompanyInputEnvelope
    set?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    disconnect?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    delete?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    connect?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    update?: ConstructionTeamUpdateWithWhereUniqueWithoutCompanyInput | ConstructionTeamUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ConstructionTeamUpdateManyWithWhereWithoutCompanyInput | ConstructionTeamUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ConstructionTeamScalarWhereInput | ConstructionTeamScalarWhereInput[]
  }

  export type ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ConstructionWorkerCreateWithoutCompanyInput, ConstructionWorkerUncheckedCreateWithoutCompanyInput> | ConstructionWorkerCreateWithoutCompanyInput[] | ConstructionWorkerUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutCompanyInput | ConstructionWorkerCreateOrConnectWithoutCompanyInput[]
    upsert?: ConstructionWorkerUpsertWithWhereUniqueWithoutCompanyInput | ConstructionWorkerUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ConstructionWorkerCreateManyCompanyInputEnvelope
    set?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    disconnect?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    delete?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    connect?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    update?: ConstructionWorkerUpdateWithWhereUniqueWithoutCompanyInput | ConstructionWorkerUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ConstructionWorkerUpdateManyWithWhereWithoutCompanyInput | ConstructionWorkerUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ConstructionWorkerScalarWhereInput | ConstructionWorkerScalarWhereInput[]
  }

  export type SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SiteAttendanceCreateWithoutCompanyInput, SiteAttendanceUncheckedCreateWithoutCompanyInput> | SiteAttendanceCreateWithoutCompanyInput[] | SiteAttendanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SiteAttendanceCreateOrConnectWithoutCompanyInput | SiteAttendanceCreateOrConnectWithoutCompanyInput[]
    upsert?: SiteAttendanceUpsertWithWhereUniqueWithoutCompanyInput | SiteAttendanceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SiteAttendanceCreateManyCompanyInputEnvelope
    set?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    disconnect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    delete?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    connect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    update?: SiteAttendanceUpdateWithWhereUniqueWithoutCompanyInput | SiteAttendanceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SiteAttendanceUpdateManyWithWhereWithoutCompanyInput | SiteAttendanceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SiteAttendanceScalarWhereInput | SiteAttendanceScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput> | AuditLogCreateWithoutCompanyInput[] | AuditLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutCompanyInput | AuditLogCreateOrConnectWithoutCompanyInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutCompanyInput | AuditLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AuditLogCreateManyCompanyInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutCompanyInput | AuditLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutCompanyInput | AuditLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserRoleCreateWithoutCompanyInput, UserRoleUncheckedCreateWithoutCompanyInput> | UserRoleCreateWithoutCompanyInput[] | UserRoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutCompanyInput | UserRoleCreateOrConnectWithoutCompanyInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutCompanyInput | UserRoleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserRoleCreateManyCompanyInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutCompanyInput | UserRoleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutCompanyInput | UserRoleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type DeviceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DeviceCreateWithoutCompanyInput, DeviceUncheckedCreateWithoutCompanyInput> | DeviceCreateWithoutCompanyInput[] | DeviceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutCompanyInput | DeviceCreateOrConnectWithoutCompanyInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutCompanyInput | DeviceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DeviceCreateManyCompanyInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutCompanyInput | DeviceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutCompanyInput | DeviceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PeriodClosureCreateWithoutCompanyInput, PeriodClosureUncheckedCreateWithoutCompanyInput> | PeriodClosureCreateWithoutCompanyInput[] | PeriodClosureUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PeriodClosureCreateOrConnectWithoutCompanyInput | PeriodClosureCreateOrConnectWithoutCompanyInput[]
    upsert?: PeriodClosureUpsertWithWhereUniqueWithoutCompanyInput | PeriodClosureUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PeriodClosureCreateManyCompanyInputEnvelope
    set?: PeriodClosureWhereUniqueInput | PeriodClosureWhereUniqueInput[]
    disconnect?: PeriodClosureWhereUniqueInput | PeriodClosureWhereUniqueInput[]
    delete?: PeriodClosureWhereUniqueInput | PeriodClosureWhereUniqueInput[]
    connect?: PeriodClosureWhereUniqueInput | PeriodClosureWhereUniqueInput[]
    update?: PeriodClosureUpdateWithWhereUniqueWithoutCompanyInput | PeriodClosureUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PeriodClosureUpdateManyWithWhereWithoutCompanyInput | PeriodClosureUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PeriodClosureScalarWhereInput | PeriodClosureScalarWhereInput[]
  }

  export type UserCreaterolesInput = {
    set: $Enums.Role[]
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonCreateWithoutUserInput, PersonUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonCreateOrConnectWithoutUserInput
    connect?: PersonWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type OvertimeCreateNestedManyWithoutUserInput = {
    create?: XOR<OvertimeCreateWithoutUserInput, OvertimeUncheckedCreateWithoutUserInput> | OvertimeCreateWithoutUserInput[] | OvertimeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutUserInput | OvertimeCreateOrConnectWithoutUserInput[]
    createMany?: OvertimeCreateManyUserInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type OvertimeCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<OvertimeCreateWithoutApprovedByInput, OvertimeUncheckedCreateWithoutApprovedByInput> | OvertimeCreateWithoutApprovedByInput[] | OvertimeUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutApprovedByInput | OvertimeCreateOrConnectWithoutApprovedByInput[]
    createMany?: OvertimeCreateManyApprovedByInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type StudentAttendanceCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<StudentAttendanceCreateWithoutRecordedByInput, StudentAttendanceUncheckedCreateWithoutRecordedByInput> | StudentAttendanceCreateWithoutRecordedByInput[] | StudentAttendanceUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutRecordedByInput | StudentAttendanceCreateOrConnectWithoutRecordedByInput[]
    createMany?: StudentAttendanceCreateManyRecordedByInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type AttendanceDailySummaryCreateNestedManyWithoutValidatedByInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutValidatedByInput, AttendanceDailySummaryUncheckedCreateWithoutValidatedByInput> | AttendanceDailySummaryCreateWithoutValidatedByInput[] | AttendanceDailySummaryUncheckedCreateWithoutValidatedByInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutValidatedByInput | AttendanceDailySummaryCreateOrConnectWithoutValidatedByInput[]
    createMany?: AttendanceDailySummaryCreateManyValidatedByInputEnvelope
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutValidatedByInput = {
    create?: XOR<LeaveRequestCreateWithoutValidatedByInput, LeaveRequestUncheckedCreateWithoutValidatedByInput> | LeaveRequestCreateWithoutValidatedByInput[] | LeaveRequestUncheckedCreateWithoutValidatedByInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutValidatedByInput | LeaveRequestCreateOrConnectWithoutValidatedByInput[]
    createMany?: LeaveRequestCreateManyValidatedByInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type PayrollPeriodCreateNestedManyWithoutClosedByInput = {
    create?: XOR<PayrollPeriodCreateWithoutClosedByInput, PayrollPeriodUncheckedCreateWithoutClosedByInput> | PayrollPeriodCreateWithoutClosedByInput[] | PayrollPeriodUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutClosedByInput | PayrollPeriodCreateOrConnectWithoutClosedByInput[]
    createMany?: PayrollPeriodCreateManyClosedByInputEnvelope
    connect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type OvertimeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OvertimeCreateWithoutUserInput, OvertimeUncheckedCreateWithoutUserInput> | OvertimeCreateWithoutUserInput[] | OvertimeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutUserInput | OvertimeCreateOrConnectWithoutUserInput[]
    createMany?: OvertimeCreateManyUserInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type OvertimeUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<OvertimeCreateWithoutApprovedByInput, OvertimeUncheckedCreateWithoutApprovedByInput> | OvertimeCreateWithoutApprovedByInput[] | OvertimeUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutApprovedByInput | OvertimeCreateOrConnectWithoutApprovedByInput[]
    createMany?: OvertimeCreateManyApprovedByInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<StudentAttendanceCreateWithoutRecordedByInput, StudentAttendanceUncheckedCreateWithoutRecordedByInput> | StudentAttendanceCreateWithoutRecordedByInput[] | StudentAttendanceUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutRecordedByInput | StudentAttendanceCreateOrConnectWithoutRecordedByInput[]
    createMany?: StudentAttendanceCreateManyRecordedByInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type AttendanceDailySummaryUncheckedCreateNestedManyWithoutValidatedByInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutValidatedByInput, AttendanceDailySummaryUncheckedCreateWithoutValidatedByInput> | AttendanceDailySummaryCreateWithoutValidatedByInput[] | AttendanceDailySummaryUncheckedCreateWithoutValidatedByInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutValidatedByInput | AttendanceDailySummaryCreateOrConnectWithoutValidatedByInput[]
    createMany?: AttendanceDailySummaryCreateManyValidatedByInputEnvelope
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutValidatedByInput = {
    create?: XOR<LeaveRequestCreateWithoutValidatedByInput, LeaveRequestUncheckedCreateWithoutValidatedByInput> | LeaveRequestCreateWithoutValidatedByInput[] | LeaveRequestUncheckedCreateWithoutValidatedByInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutValidatedByInput | LeaveRequestCreateOrConnectWithoutValidatedByInput[]
    createMany?: LeaveRequestCreateManyValidatedByInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type PayrollPeriodUncheckedCreateNestedManyWithoutClosedByInput = {
    create?: XOR<PayrollPeriodCreateWithoutClosedByInput, PayrollPeriodUncheckedCreateWithoutClosedByInput> | PayrollPeriodCreateWithoutClosedByInput[] | PayrollPeriodUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutClosedByInput | PayrollPeriodCreateOrConnectWithoutClosedByInput[]
    createMany?: PayrollPeriodCreateManyClosedByInputEnvelope
    connect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdaterolesInput = {
    set?: $Enums.Role[]
    push?: $Enums.Role | $Enums.Role[]
  }

  export type CompanyUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type PersonUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonCreateWithoutUserInput, PersonUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonCreateOrConnectWithoutUserInput
    upsert?: PersonUpsertWithoutUserInput
    disconnect?: PersonWhereInput | boolean
    delete?: PersonWhereInput | boolean
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutUserInput, PersonUpdateWithoutUserInput>, PersonUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type OvertimeUpdateManyWithoutUserNestedInput = {
    create?: XOR<OvertimeCreateWithoutUserInput, OvertimeUncheckedCreateWithoutUserInput> | OvertimeCreateWithoutUserInput[] | OvertimeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutUserInput | OvertimeCreateOrConnectWithoutUserInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutUserInput | OvertimeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OvertimeCreateManyUserInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutUserInput | OvertimeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutUserInput | OvertimeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type OvertimeUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<OvertimeCreateWithoutApprovedByInput, OvertimeUncheckedCreateWithoutApprovedByInput> | OvertimeCreateWithoutApprovedByInput[] | OvertimeUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutApprovedByInput | OvertimeCreateOrConnectWithoutApprovedByInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutApprovedByInput | OvertimeUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: OvertimeCreateManyApprovedByInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutApprovedByInput | OvertimeUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutApprovedByInput | OvertimeUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type StudentAttendanceUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutRecordedByInput, StudentAttendanceUncheckedCreateWithoutRecordedByInput> | StudentAttendanceCreateWithoutRecordedByInput[] | StudentAttendanceUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutRecordedByInput | StudentAttendanceCreateOrConnectWithoutRecordedByInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutRecordedByInput | StudentAttendanceUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: StudentAttendanceCreateManyRecordedByInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutRecordedByInput | StudentAttendanceUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutRecordedByInput | StudentAttendanceUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type AttendanceDailySummaryUpdateManyWithoutValidatedByNestedInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutValidatedByInput, AttendanceDailySummaryUncheckedCreateWithoutValidatedByInput> | AttendanceDailySummaryCreateWithoutValidatedByInput[] | AttendanceDailySummaryUncheckedCreateWithoutValidatedByInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutValidatedByInput | AttendanceDailySummaryCreateOrConnectWithoutValidatedByInput[]
    upsert?: AttendanceDailySummaryUpsertWithWhereUniqueWithoutValidatedByInput | AttendanceDailySummaryUpsertWithWhereUniqueWithoutValidatedByInput[]
    createMany?: AttendanceDailySummaryCreateManyValidatedByInputEnvelope
    set?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    disconnect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    delete?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    update?: AttendanceDailySummaryUpdateWithWhereUniqueWithoutValidatedByInput | AttendanceDailySummaryUpdateWithWhereUniqueWithoutValidatedByInput[]
    updateMany?: AttendanceDailySummaryUpdateManyWithWhereWithoutValidatedByInput | AttendanceDailySummaryUpdateManyWithWhereWithoutValidatedByInput[]
    deleteMany?: AttendanceDailySummaryScalarWhereInput | AttendanceDailySummaryScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutValidatedByNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutValidatedByInput, LeaveRequestUncheckedCreateWithoutValidatedByInput> | LeaveRequestCreateWithoutValidatedByInput[] | LeaveRequestUncheckedCreateWithoutValidatedByInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutValidatedByInput | LeaveRequestCreateOrConnectWithoutValidatedByInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutValidatedByInput | LeaveRequestUpsertWithWhereUniqueWithoutValidatedByInput[]
    createMany?: LeaveRequestCreateManyValidatedByInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutValidatedByInput | LeaveRequestUpdateWithWhereUniqueWithoutValidatedByInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutValidatedByInput | LeaveRequestUpdateManyWithWhereWithoutValidatedByInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type PayrollPeriodUpdateManyWithoutClosedByNestedInput = {
    create?: XOR<PayrollPeriodCreateWithoutClosedByInput, PayrollPeriodUncheckedCreateWithoutClosedByInput> | PayrollPeriodCreateWithoutClosedByInput[] | PayrollPeriodUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutClosedByInput | PayrollPeriodCreateOrConnectWithoutClosedByInput[]
    upsert?: PayrollPeriodUpsertWithWhereUniqueWithoutClosedByInput | PayrollPeriodUpsertWithWhereUniqueWithoutClosedByInput[]
    createMany?: PayrollPeriodCreateManyClosedByInputEnvelope
    set?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    disconnect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    delete?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    connect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    update?: PayrollPeriodUpdateWithWhereUniqueWithoutClosedByInput | PayrollPeriodUpdateWithWhereUniqueWithoutClosedByInput[]
    updateMany?: PayrollPeriodUpdateManyWithWhereWithoutClosedByInput | PayrollPeriodUpdateManyWithWhereWithoutClosedByInput[]
    deleteMany?: PayrollPeriodScalarWhereInput | PayrollPeriodScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type OvertimeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OvertimeCreateWithoutUserInput, OvertimeUncheckedCreateWithoutUserInput> | OvertimeCreateWithoutUserInput[] | OvertimeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutUserInput | OvertimeCreateOrConnectWithoutUserInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutUserInput | OvertimeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OvertimeCreateManyUserInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutUserInput | OvertimeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutUserInput | OvertimeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type OvertimeUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<OvertimeCreateWithoutApprovedByInput, OvertimeUncheckedCreateWithoutApprovedByInput> | OvertimeCreateWithoutApprovedByInput[] | OvertimeUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutApprovedByInput | OvertimeCreateOrConnectWithoutApprovedByInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutApprovedByInput | OvertimeUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: OvertimeCreateManyApprovedByInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutApprovedByInput | OvertimeUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutApprovedByInput | OvertimeUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutRecordedByInput, StudentAttendanceUncheckedCreateWithoutRecordedByInput> | StudentAttendanceCreateWithoutRecordedByInput[] | StudentAttendanceUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutRecordedByInput | StudentAttendanceCreateOrConnectWithoutRecordedByInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutRecordedByInput | StudentAttendanceUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: StudentAttendanceCreateManyRecordedByInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutRecordedByInput | StudentAttendanceUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutRecordedByInput | StudentAttendanceUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByNestedInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutValidatedByInput, AttendanceDailySummaryUncheckedCreateWithoutValidatedByInput> | AttendanceDailySummaryCreateWithoutValidatedByInput[] | AttendanceDailySummaryUncheckedCreateWithoutValidatedByInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutValidatedByInput | AttendanceDailySummaryCreateOrConnectWithoutValidatedByInput[]
    upsert?: AttendanceDailySummaryUpsertWithWhereUniqueWithoutValidatedByInput | AttendanceDailySummaryUpsertWithWhereUniqueWithoutValidatedByInput[]
    createMany?: AttendanceDailySummaryCreateManyValidatedByInputEnvelope
    set?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    disconnect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    delete?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    update?: AttendanceDailySummaryUpdateWithWhereUniqueWithoutValidatedByInput | AttendanceDailySummaryUpdateWithWhereUniqueWithoutValidatedByInput[]
    updateMany?: AttendanceDailySummaryUpdateManyWithWhereWithoutValidatedByInput | AttendanceDailySummaryUpdateManyWithWhereWithoutValidatedByInput[]
    deleteMany?: AttendanceDailySummaryScalarWhereInput | AttendanceDailySummaryScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutValidatedByNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutValidatedByInput, LeaveRequestUncheckedCreateWithoutValidatedByInput> | LeaveRequestCreateWithoutValidatedByInput[] | LeaveRequestUncheckedCreateWithoutValidatedByInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutValidatedByInput | LeaveRequestCreateOrConnectWithoutValidatedByInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutValidatedByInput | LeaveRequestUpsertWithWhereUniqueWithoutValidatedByInput[]
    createMany?: LeaveRequestCreateManyValidatedByInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutValidatedByInput | LeaveRequestUpdateWithWhereUniqueWithoutValidatedByInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutValidatedByInput | LeaveRequestUpdateManyWithWhereWithoutValidatedByInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type PayrollPeriodUncheckedUpdateManyWithoutClosedByNestedInput = {
    create?: XOR<PayrollPeriodCreateWithoutClosedByInput, PayrollPeriodUncheckedCreateWithoutClosedByInput> | PayrollPeriodCreateWithoutClosedByInput[] | PayrollPeriodUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutClosedByInput | PayrollPeriodCreateOrConnectWithoutClosedByInput[]
    upsert?: PayrollPeriodUpsertWithWhereUniqueWithoutClosedByInput | PayrollPeriodUpsertWithWhereUniqueWithoutClosedByInput[]
    createMany?: PayrollPeriodCreateManyClosedByInputEnvelope
    set?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    disconnect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    delete?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    connect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    update?: PayrollPeriodUpdateWithWhereUniqueWithoutClosedByInput | PayrollPeriodUpdateWithWhereUniqueWithoutClosedByInput[]
    updateMany?: PayrollPeriodUpdateManyWithWhereWithoutClosedByInput | PayrollPeriodUpdateManyWithWhereWithoutClosedByInput[]
    deleteMany?: PayrollPeriodScalarWhereInput | PayrollPeriodScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<CompanyCreateWithoutAttendanceInput, CompanyUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAttendanceInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceInput
    upsert?: UserUpsertWithoutAttendanceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceInput, UserUpdateWithoutAttendanceInput>, UserUncheckedUpdateWithoutAttendanceInput>
  }

  export type CompanyUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<CompanyCreateWithoutAttendanceInput, CompanyUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAttendanceInput
    upsert?: CompanyUpsertWithoutAttendanceInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAttendanceInput, CompanyUpdateWithoutAttendanceInput>, CompanyUncheckedUpdateWithoutAttendanceInput>
  }

  export type ScheduleCreatedaysOfWeekInput = {
    set: string[]
  }

  export type CompanyCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<CompanyCreateWithoutSchedulesInput, CompanyUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSchedulesInput
    connect?: CompanyWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutScheduleInput = {
    create?: XOR<EmployeeCreateWithoutScheduleInput, EmployeeUncheckedCreateWithoutScheduleInput> | EmployeeCreateWithoutScheduleInput[] | EmployeeUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutScheduleInput | EmployeeCreateOrConnectWithoutScheduleInput[]
    createMany?: EmployeeCreateManyScheduleInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<EmployeeCreateWithoutScheduleInput, EmployeeUncheckedCreateWithoutScheduleInput> | EmployeeCreateWithoutScheduleInput[] | EmployeeUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutScheduleInput | EmployeeCreateOrConnectWithoutScheduleInput[]
    createMany?: EmployeeCreateManyScheduleInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ScheduleUpdatedaysOfWeekInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CompanyUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<CompanyCreateWithoutSchedulesInput, CompanyUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSchedulesInput
    upsert?: CompanyUpsertWithoutSchedulesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSchedulesInput, CompanyUpdateWithoutSchedulesInput>, CompanyUncheckedUpdateWithoutSchedulesInput>
  }

  export type EmployeeUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<EmployeeCreateWithoutScheduleInput, EmployeeUncheckedCreateWithoutScheduleInput> | EmployeeCreateWithoutScheduleInput[] | EmployeeUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutScheduleInput | EmployeeCreateOrConnectWithoutScheduleInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutScheduleInput | EmployeeUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: EmployeeCreateManyScheduleInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutScheduleInput | EmployeeUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutScheduleInput | EmployeeUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<EmployeeCreateWithoutScheduleInput, EmployeeUncheckedCreateWithoutScheduleInput> | EmployeeCreateWithoutScheduleInput[] | EmployeeUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutScheduleInput | EmployeeCreateOrConnectWithoutScheduleInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutScheduleInput | EmployeeUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: EmployeeCreateManyScheduleInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutScheduleInput | EmployeeUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutScheduleInput | EmployeeUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutOvertimeInput = {
    create?: XOR<CompanyCreateWithoutOvertimeInput, CompanyUncheckedCreateWithoutOvertimeInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutOvertimeInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOvertimeRequestsInput = {
    create?: XOR<UserCreateWithoutOvertimeRequestsInput, UserUncheckedCreateWithoutOvertimeRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOvertimeRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOvertimeApprovalsInput = {
    create?: XOR<UserCreateWithoutOvertimeApprovalsInput, UserUncheckedCreateWithoutOvertimeApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOvertimeApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumOvertimeStatusFieldUpdateOperationsInput = {
    set?: $Enums.OvertimeStatus
  }

  export type CompanyUpdateOneRequiredWithoutOvertimeNestedInput = {
    create?: XOR<CompanyCreateWithoutOvertimeInput, CompanyUncheckedCreateWithoutOvertimeInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutOvertimeInput
    upsert?: CompanyUpsertWithoutOvertimeInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutOvertimeInput, CompanyUpdateWithoutOvertimeInput>, CompanyUncheckedUpdateWithoutOvertimeInput>
  }

  export type UserUpdateOneRequiredWithoutOvertimeRequestsNestedInput = {
    create?: XOR<UserCreateWithoutOvertimeRequestsInput, UserUncheckedCreateWithoutOvertimeRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOvertimeRequestsInput
    upsert?: UserUpsertWithoutOvertimeRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOvertimeRequestsInput, UserUpdateWithoutOvertimeRequestsInput>, UserUncheckedUpdateWithoutOvertimeRequestsInput>
  }

  export type UserUpdateOneWithoutOvertimeApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutOvertimeApprovalsInput, UserUncheckedCreateWithoutOvertimeApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOvertimeApprovalsInput
    upsert?: UserUpsertWithoutOvertimeApprovalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOvertimeApprovalsInput, UserUpdateWithoutOvertimeApprovalsInput>, UserUncheckedUpdateWithoutOvertimeApprovalsInput>
  }

  export type CompanyCreateNestedOneWithoutAttendanceSummariesInput = {
    create?: XOR<CompanyCreateWithoutAttendanceSummariesInput, CompanyUncheckedCreateWithoutAttendanceSummariesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAttendanceSummariesInput
    connect?: CompanyWhereUniqueInput
  }

  export type PayrollCreateNestedManyWithoutAttendanceSummaryInput = {
    create?: XOR<PayrollCreateWithoutAttendanceSummaryInput, PayrollUncheckedCreateWithoutAttendanceSummaryInput> | PayrollCreateWithoutAttendanceSummaryInput[] | PayrollUncheckedCreateWithoutAttendanceSummaryInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutAttendanceSummaryInput | PayrollCreateOrConnectWithoutAttendanceSummaryInput[]
    createMany?: PayrollCreateManyAttendanceSummaryInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type PayrollUncheckedCreateNestedManyWithoutAttendanceSummaryInput = {
    create?: XOR<PayrollCreateWithoutAttendanceSummaryInput, PayrollUncheckedCreateWithoutAttendanceSummaryInput> | PayrollCreateWithoutAttendanceSummaryInput[] | PayrollUncheckedCreateWithoutAttendanceSummaryInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutAttendanceSummaryInput | PayrollCreateOrConnectWithoutAttendanceSummaryInput[]
    createMany?: PayrollCreateManyAttendanceSummaryInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutAttendanceSummariesNestedInput = {
    create?: XOR<CompanyCreateWithoutAttendanceSummariesInput, CompanyUncheckedCreateWithoutAttendanceSummariesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAttendanceSummariesInput
    upsert?: CompanyUpsertWithoutAttendanceSummariesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAttendanceSummariesInput, CompanyUpdateWithoutAttendanceSummariesInput>, CompanyUncheckedUpdateWithoutAttendanceSummariesInput>
  }

  export type PayrollUpdateManyWithoutAttendanceSummaryNestedInput = {
    create?: XOR<PayrollCreateWithoutAttendanceSummaryInput, PayrollUncheckedCreateWithoutAttendanceSummaryInput> | PayrollCreateWithoutAttendanceSummaryInput[] | PayrollUncheckedCreateWithoutAttendanceSummaryInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutAttendanceSummaryInput | PayrollCreateOrConnectWithoutAttendanceSummaryInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutAttendanceSummaryInput | PayrollUpsertWithWhereUniqueWithoutAttendanceSummaryInput[]
    createMany?: PayrollCreateManyAttendanceSummaryInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutAttendanceSummaryInput | PayrollUpdateWithWhereUniqueWithoutAttendanceSummaryInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutAttendanceSummaryInput | PayrollUpdateManyWithWhereWithoutAttendanceSummaryInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type PayrollUncheckedUpdateManyWithoutAttendanceSummaryNestedInput = {
    create?: XOR<PayrollCreateWithoutAttendanceSummaryInput, PayrollUncheckedCreateWithoutAttendanceSummaryInput> | PayrollCreateWithoutAttendanceSummaryInput[] | PayrollUncheckedCreateWithoutAttendanceSummaryInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutAttendanceSummaryInput | PayrollCreateOrConnectWithoutAttendanceSummaryInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutAttendanceSummaryInput | PayrollUpsertWithWhereUniqueWithoutAttendanceSummaryInput[]
    createMany?: PayrollCreateManyAttendanceSummaryInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutAttendanceSummaryInput | PayrollUpdateWithWhereUniqueWithoutAttendanceSummaryInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutAttendanceSummaryInput | PayrollUpdateManyWithWhereWithoutAttendanceSummaryInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutPayrollsInput = {
    create?: XOR<CompanyCreateWithoutPayrollsInput, CompanyUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPayrollsInput
    connect?: CompanyWhereUniqueInput
  }

  export type AttendanceSummaryCreateNestedOneWithoutPayrollsInput = {
    create?: XOR<AttendanceSummaryCreateWithoutPayrollsInput, AttendanceSummaryUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutPayrollsInput
    connect?: AttendanceSummaryWhereUniqueInput
  }

  export type PayrollExportCreateNestedManyWithoutPayrollInput = {
    create?: XOR<PayrollExportCreateWithoutPayrollInput, PayrollExportUncheckedCreateWithoutPayrollInput> | PayrollExportCreateWithoutPayrollInput[] | PayrollExportUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: PayrollExportCreateOrConnectWithoutPayrollInput | PayrollExportCreateOrConnectWithoutPayrollInput[]
    createMany?: PayrollExportCreateManyPayrollInputEnvelope
    connect?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
  }

  export type PayrollExportUncheckedCreateNestedManyWithoutPayrollInput = {
    create?: XOR<PayrollExportCreateWithoutPayrollInput, PayrollExportUncheckedCreateWithoutPayrollInput> | PayrollExportCreateWithoutPayrollInput[] | PayrollExportUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: PayrollExportCreateOrConnectWithoutPayrollInput | PayrollExportCreateOrConnectWithoutPayrollInput[]
    createMany?: PayrollExportCreateManyPayrollInputEnvelope
    connect?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
  }

  export type EnumPayrollStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayrollStatus
  }

  export type CompanyUpdateOneRequiredWithoutPayrollsNestedInput = {
    create?: XOR<CompanyCreateWithoutPayrollsInput, CompanyUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPayrollsInput
    upsert?: CompanyUpsertWithoutPayrollsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPayrollsInput, CompanyUpdateWithoutPayrollsInput>, CompanyUncheckedUpdateWithoutPayrollsInput>
  }

  export type AttendanceSummaryUpdateOneRequiredWithoutPayrollsNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutPayrollsInput, AttendanceSummaryUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutPayrollsInput
    upsert?: AttendanceSummaryUpsertWithoutPayrollsInput
    connect?: AttendanceSummaryWhereUniqueInput
    update?: XOR<XOR<AttendanceSummaryUpdateToOneWithWhereWithoutPayrollsInput, AttendanceSummaryUpdateWithoutPayrollsInput>, AttendanceSummaryUncheckedUpdateWithoutPayrollsInput>
  }

  export type PayrollExportUpdateManyWithoutPayrollNestedInput = {
    create?: XOR<PayrollExportCreateWithoutPayrollInput, PayrollExportUncheckedCreateWithoutPayrollInput> | PayrollExportCreateWithoutPayrollInput[] | PayrollExportUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: PayrollExportCreateOrConnectWithoutPayrollInput | PayrollExportCreateOrConnectWithoutPayrollInput[]
    upsert?: PayrollExportUpsertWithWhereUniqueWithoutPayrollInput | PayrollExportUpsertWithWhereUniqueWithoutPayrollInput[]
    createMany?: PayrollExportCreateManyPayrollInputEnvelope
    set?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    disconnect?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    delete?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    connect?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    update?: PayrollExportUpdateWithWhereUniqueWithoutPayrollInput | PayrollExportUpdateWithWhereUniqueWithoutPayrollInput[]
    updateMany?: PayrollExportUpdateManyWithWhereWithoutPayrollInput | PayrollExportUpdateManyWithWhereWithoutPayrollInput[]
    deleteMany?: PayrollExportScalarWhereInput | PayrollExportScalarWhereInput[]
  }

  export type PayrollExportUncheckedUpdateManyWithoutPayrollNestedInput = {
    create?: XOR<PayrollExportCreateWithoutPayrollInput, PayrollExportUncheckedCreateWithoutPayrollInput> | PayrollExportCreateWithoutPayrollInput[] | PayrollExportUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: PayrollExportCreateOrConnectWithoutPayrollInput | PayrollExportCreateOrConnectWithoutPayrollInput[]
    upsert?: PayrollExportUpsertWithWhereUniqueWithoutPayrollInput | PayrollExportUpsertWithWhereUniqueWithoutPayrollInput[]
    createMany?: PayrollExportCreateManyPayrollInputEnvelope
    set?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    disconnect?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    delete?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    connect?: PayrollExportWhereUniqueInput | PayrollExportWhereUniqueInput[]
    update?: PayrollExportUpdateWithWhereUniqueWithoutPayrollInput | PayrollExportUpdateWithWhereUniqueWithoutPayrollInput[]
    updateMany?: PayrollExportUpdateManyWithWhereWithoutPayrollInput | PayrollExportUpdateManyWithWhereWithoutPayrollInput[]
    deleteMany?: PayrollExportScalarWhereInput | PayrollExportScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutPayrollExportsInput = {
    create?: XOR<CompanyCreateWithoutPayrollExportsInput, CompanyUncheckedCreateWithoutPayrollExportsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPayrollExportsInput
    connect?: CompanyWhereUniqueInput
  }

  export type PayrollCreateNestedOneWithoutExportsInput = {
    create?: XOR<PayrollCreateWithoutExportsInput, PayrollUncheckedCreateWithoutExportsInput>
    connectOrCreate?: PayrollCreateOrConnectWithoutExportsInput
    connect?: PayrollWhereUniqueInput
  }

  export type EnumExportFormatFieldUpdateOperationsInput = {
    set?: $Enums.ExportFormat
  }

  export type CompanyUpdateOneRequiredWithoutPayrollExportsNestedInput = {
    create?: XOR<CompanyCreateWithoutPayrollExportsInput, CompanyUncheckedCreateWithoutPayrollExportsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPayrollExportsInput
    upsert?: CompanyUpsertWithoutPayrollExportsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPayrollExportsInput, CompanyUpdateWithoutPayrollExportsInput>, CompanyUncheckedUpdateWithoutPayrollExportsInput>
  }

  export type PayrollUpdateOneRequiredWithoutExportsNestedInput = {
    create?: XOR<PayrollCreateWithoutExportsInput, PayrollUncheckedCreateWithoutExportsInput>
    connectOrCreate?: PayrollCreateOrConnectWithoutExportsInput
    upsert?: PayrollUpsertWithoutExportsInput
    connect?: PayrollWhereUniqueInput
    update?: XOR<XOR<PayrollUpdateToOneWithWhereWithoutExportsInput, PayrollUpdateWithoutExportsInput>, PayrollUncheckedUpdateWithoutExportsInput>
  }

  export type CompanyCreateNestedOneWithoutReportsInput = {
    create?: XOR<CompanyCreateWithoutReportsInput, CompanyUncheckedCreateWithoutReportsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutReportsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportType
  }

  export type CompanyUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<CompanyCreateWithoutReportsInput, CompanyUncheckedCreateWithoutReportsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutReportsInput
    upsert?: CompanyUpsertWithoutReportsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutReportsInput, CompanyUpdateWithoutReportsInput>, CompanyUncheckedUpdateWithoutReportsInput>
  }

  export type CompanyCreateNestedOneWithoutPeriodClosuresInput = {
    create?: XOR<CompanyCreateWithoutPeriodClosuresInput, CompanyUncheckedCreateWithoutPeriodClosuresInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPeriodClosuresInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutPeriodClosuresNestedInput = {
    create?: XOR<CompanyCreateWithoutPeriodClosuresInput, CompanyUncheckedCreateWithoutPeriodClosuresInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPeriodClosuresInput
    upsert?: CompanyUpsertWithoutPeriodClosuresInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPeriodClosuresInput, CompanyUpdateWithoutPeriodClosuresInput>, CompanyUncheckedUpdateWithoutPeriodClosuresInput>
  }

  export type CompanyCreateNestedOneWithoutSchoolClassesInput = {
    create?: XOR<CompanyCreateWithoutSchoolClassesInput, CompanyUncheckedCreateWithoutSchoolClassesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSchoolClassesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CourseCreateNestedManyWithoutClassInput = {
    create?: XOR<CourseCreateWithoutClassInput, CourseUncheckedCreateWithoutClassInput> | CourseCreateWithoutClassInput[] | CourseUncheckedCreateWithoutClassInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutClassInput | CourseCreateOrConnectWithoutClassInput[]
    createMany?: CourseCreateManyClassInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<CourseCreateWithoutClassInput, CourseUncheckedCreateWithoutClassInput> | CourseCreateWithoutClassInput[] | CourseUncheckedCreateWithoutClassInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutClassInput | CourseCreateOrConnectWithoutClassInput[]
    createMany?: CourseCreateManyClassInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutSchoolClassesNestedInput = {
    create?: XOR<CompanyCreateWithoutSchoolClassesInput, CompanyUncheckedCreateWithoutSchoolClassesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSchoolClassesInput
    upsert?: CompanyUpsertWithoutSchoolClassesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSchoolClassesInput, CompanyUpdateWithoutSchoolClassesInput>, CompanyUncheckedUpdateWithoutSchoolClassesInput>
  }

  export type CourseUpdateManyWithoutClassNestedInput = {
    create?: XOR<CourseCreateWithoutClassInput, CourseUncheckedCreateWithoutClassInput> | CourseCreateWithoutClassInput[] | CourseUncheckedCreateWithoutClassInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutClassInput | CourseCreateOrConnectWithoutClassInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutClassInput | CourseUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: CourseCreateManyClassInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutClassInput | CourseUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutClassInput | CourseUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<CourseCreateWithoutClassInput, CourseUncheckedCreateWithoutClassInput> | CourseCreateWithoutClassInput[] | CourseUncheckedCreateWithoutClassInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutClassInput | CourseCreateOrConnectWithoutClassInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutClassInput | CourseUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: CourseCreateManyClassInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutClassInput | CourseUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutClassInput | CourseUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutCoursesInput = {
    create?: XOR<CompanyCreateWithoutCoursesInput, CompanyUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCoursesInput
    connect?: CompanyWhereUniqueInput
  }

  export type SchoolClassCreateNestedOneWithoutCoursesInput = {
    create?: XOR<SchoolClassCreateWithoutCoursesInput, SchoolClassUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: SchoolClassCreateOrConnectWithoutCoursesInput
    connect?: SchoolClassWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<CompanyCreateWithoutCoursesInput, CompanyUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCoursesInput
    upsert?: CompanyUpsertWithoutCoursesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCoursesInput, CompanyUpdateWithoutCoursesInput>, CompanyUncheckedUpdateWithoutCoursesInput>
  }

  export type SchoolClassUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<SchoolClassCreateWithoutCoursesInput, SchoolClassUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: SchoolClassCreateOrConnectWithoutCoursesInput
    upsert?: SchoolClassUpsertWithoutCoursesInput
    connect?: SchoolClassWhereUniqueInput
    update?: XOR<XOR<SchoolClassUpdateToOneWithWhereWithoutCoursesInput, SchoolClassUpdateWithoutCoursesInput>, SchoolClassUncheckedUpdateWithoutCoursesInput>
  }

  export type CompanyCreateNestedOneWithoutStudentsInput = {
    create?: XOR<CompanyCreateWithoutStudentsInput, CompanyUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStudentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type SchoolClassCreateNestedOneWithoutStudentsInput = {
    create?: XOR<SchoolClassCreateWithoutStudentsInput, SchoolClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolClassCreateOrConnectWithoutStudentsInput
    connect?: SchoolClassWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutStudentInput = {
    create?: XOR<PersonCreateWithoutStudentInput, PersonUncheckedCreateWithoutStudentInput>
    connectOrCreate?: PersonCreateOrConnectWithoutStudentInput
    connect?: PersonWhereUniqueInput
  }

  export type StudentAttendanceCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type AttendanceEventCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceEventCreateWithoutStudentInput, AttendanceEventUncheckedCreateWithoutStudentInput> | AttendanceEventCreateWithoutStudentInput[] | AttendanceEventUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutStudentInput | AttendanceEventCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceEventCreateManyStudentInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type AttendanceDailySummaryCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutStudentInput, AttendanceDailySummaryUncheckedCreateWithoutStudentInput> | AttendanceDailySummaryCreateWithoutStudentInput[] | AttendanceDailySummaryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutStudentInput | AttendanceDailySummaryCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceDailySummaryCreateManyStudentInputEnvelope
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
  }

  export type StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type AttendanceEventUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceEventCreateWithoutStudentInput, AttendanceEventUncheckedCreateWithoutStudentInput> | AttendanceEventCreateWithoutStudentInput[] | AttendanceEventUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutStudentInput | AttendanceEventCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceEventCreateManyStudentInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type AttendanceDailySummaryUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutStudentInput, AttendanceDailySummaryUncheckedCreateWithoutStudentInput> | AttendanceDailySummaryCreateWithoutStudentInput[] | AttendanceDailySummaryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutStudentInput | AttendanceDailySummaryCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceDailySummaryCreateManyStudentInputEnvelope
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<CompanyCreateWithoutStudentsInput, CompanyUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStudentsInput
    upsert?: CompanyUpsertWithoutStudentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutStudentsInput, CompanyUpdateWithoutStudentsInput>, CompanyUncheckedUpdateWithoutStudentsInput>
  }

  export type SchoolClassUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<SchoolClassCreateWithoutStudentsInput, SchoolClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolClassCreateOrConnectWithoutStudentsInput
    upsert?: SchoolClassUpsertWithoutStudentsInput
    connect?: SchoolClassWhereUniqueInput
    update?: XOR<XOR<SchoolClassUpdateToOneWithWhereWithoutStudentsInput, SchoolClassUpdateWithoutStudentsInput>, SchoolClassUncheckedUpdateWithoutStudentsInput>
  }

  export type PersonUpdateOneWithoutStudentNestedInput = {
    create?: XOR<PersonCreateWithoutStudentInput, PersonUncheckedCreateWithoutStudentInput>
    connectOrCreate?: PersonCreateOrConnectWithoutStudentInput
    upsert?: PersonUpsertWithoutStudentInput
    disconnect?: PersonWhereInput | boolean
    delete?: PersonWhereInput | boolean
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutStudentInput, PersonUpdateWithoutStudentInput>, PersonUncheckedUpdateWithoutStudentInput>
  }

  export type StudentAttendanceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput | StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput | StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutStudentInput | StudentAttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type AttendanceEventUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutStudentInput, AttendanceEventUncheckedCreateWithoutStudentInput> | AttendanceEventCreateWithoutStudentInput[] | AttendanceEventUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutStudentInput | AttendanceEventCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutStudentInput | AttendanceEventUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceEventCreateManyStudentInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutStudentInput | AttendanceEventUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutStudentInput | AttendanceEventUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type AttendanceDailySummaryUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutStudentInput, AttendanceDailySummaryUncheckedCreateWithoutStudentInput> | AttendanceDailySummaryCreateWithoutStudentInput[] | AttendanceDailySummaryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutStudentInput | AttendanceDailySummaryCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceDailySummaryUpsertWithWhereUniqueWithoutStudentInput | AttendanceDailySummaryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceDailySummaryCreateManyStudentInputEnvelope
    set?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    disconnect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    delete?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    update?: AttendanceDailySummaryUpdateWithWhereUniqueWithoutStudentInput | AttendanceDailySummaryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceDailySummaryUpdateManyWithWhereWithoutStudentInput | AttendanceDailySummaryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceDailySummaryScalarWhereInput | AttendanceDailySummaryScalarWhereInput[]
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput | StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput | StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutStudentInput | StudentAttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type AttendanceEventUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutStudentInput, AttendanceEventUncheckedCreateWithoutStudentInput> | AttendanceEventCreateWithoutStudentInput[] | AttendanceEventUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutStudentInput | AttendanceEventCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutStudentInput | AttendanceEventUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceEventCreateManyStudentInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutStudentInput | AttendanceEventUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutStudentInput | AttendanceEventUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type AttendanceDailySummaryUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutStudentInput, AttendanceDailySummaryUncheckedCreateWithoutStudentInput> | AttendanceDailySummaryCreateWithoutStudentInput[] | AttendanceDailySummaryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutStudentInput | AttendanceDailySummaryCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceDailySummaryUpsertWithWhereUniqueWithoutStudentInput | AttendanceDailySummaryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceDailySummaryCreateManyStudentInputEnvelope
    set?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    disconnect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    delete?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    update?: AttendanceDailySummaryUpdateWithWhereUniqueWithoutStudentInput | AttendanceDailySummaryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceDailySummaryUpdateManyWithWhereWithoutStudentInput | AttendanceDailySummaryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceDailySummaryScalarWhereInput | AttendanceDailySummaryScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutStudentAttendanceInput = {
    create?: XOR<CompanyCreateWithoutStudentAttendanceInput, CompanyUncheckedCreateWithoutStudentAttendanceInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStudentAttendanceInput
    connect?: CompanyWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceInput
    connect?: StudentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStudentAttendanceRecordsInput = {
    create?: XOR<UserCreateWithoutStudentAttendanceRecordsInput, UserUncheckedCreateWithoutStudentAttendanceRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentAttendanceRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumStudentAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudentAttendanceStatus
  }

  export type CompanyUpdateOneRequiredWithoutStudentAttendanceNestedInput = {
    create?: XOR<CompanyCreateWithoutStudentAttendanceInput, CompanyUncheckedCreateWithoutStudentAttendanceInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStudentAttendanceInput
    upsert?: CompanyUpsertWithoutStudentAttendanceInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutStudentAttendanceInput, CompanyUpdateWithoutStudentAttendanceInput>, CompanyUncheckedUpdateWithoutStudentAttendanceInput>
  }

  export type StudentUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceInput
    upsert?: StudentUpsertWithoutAttendanceInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAttendanceInput, StudentUpdateWithoutAttendanceInput>, StudentUncheckedUpdateWithoutAttendanceInput>
  }

  export type UserUpdateOneWithoutStudentAttendanceRecordsNestedInput = {
    create?: XOR<UserCreateWithoutStudentAttendanceRecordsInput, UserUncheckedCreateWithoutStudentAttendanceRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentAttendanceRecordsInput
    upsert?: UserUpsertWithoutStudentAttendanceRecordsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentAttendanceRecordsInput, UserUpdateWithoutStudentAttendanceRecordsInput>, UserUncheckedUpdateWithoutStudentAttendanceRecordsInput>
  }

  export type CompanyCreateNestedOneWithoutConstructionSitesInput = {
    create?: XOR<CompanyCreateWithoutConstructionSitesInput, CompanyUncheckedCreateWithoutConstructionSitesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutConstructionSitesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ConstructionTeamCreateNestedManyWithoutSiteInput = {
    create?: XOR<ConstructionTeamCreateWithoutSiteInput, ConstructionTeamUncheckedCreateWithoutSiteInput> | ConstructionTeamCreateWithoutSiteInput[] | ConstructionTeamUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ConstructionTeamCreateOrConnectWithoutSiteInput | ConstructionTeamCreateOrConnectWithoutSiteInput[]
    createMany?: ConstructionTeamCreateManySiteInputEnvelope
    connect?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
  }

  export type SiteAttendanceCreateNestedManyWithoutSiteInput = {
    create?: XOR<SiteAttendanceCreateWithoutSiteInput, SiteAttendanceUncheckedCreateWithoutSiteInput> | SiteAttendanceCreateWithoutSiteInput[] | SiteAttendanceUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteAttendanceCreateOrConnectWithoutSiteInput | SiteAttendanceCreateOrConnectWithoutSiteInput[]
    createMany?: SiteAttendanceCreateManySiteInputEnvelope
    connect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
  }

  export type ConstructionTeamUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<ConstructionTeamCreateWithoutSiteInput, ConstructionTeamUncheckedCreateWithoutSiteInput> | ConstructionTeamCreateWithoutSiteInput[] | ConstructionTeamUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ConstructionTeamCreateOrConnectWithoutSiteInput | ConstructionTeamCreateOrConnectWithoutSiteInput[]
    createMany?: ConstructionTeamCreateManySiteInputEnvelope
    connect?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
  }

  export type SiteAttendanceUncheckedCreateNestedManyWithoutSiteInput = {
    create?: XOR<SiteAttendanceCreateWithoutSiteInput, SiteAttendanceUncheckedCreateWithoutSiteInput> | SiteAttendanceCreateWithoutSiteInput[] | SiteAttendanceUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteAttendanceCreateOrConnectWithoutSiteInput | SiteAttendanceCreateOrConnectWithoutSiteInput[]
    createMany?: SiteAttendanceCreateManySiteInputEnvelope
    connect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateOneRequiredWithoutConstructionSitesNestedInput = {
    create?: XOR<CompanyCreateWithoutConstructionSitesInput, CompanyUncheckedCreateWithoutConstructionSitesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutConstructionSitesInput
    upsert?: CompanyUpsertWithoutConstructionSitesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutConstructionSitesInput, CompanyUpdateWithoutConstructionSitesInput>, CompanyUncheckedUpdateWithoutConstructionSitesInput>
  }

  export type ConstructionTeamUpdateManyWithoutSiteNestedInput = {
    create?: XOR<ConstructionTeamCreateWithoutSiteInput, ConstructionTeamUncheckedCreateWithoutSiteInput> | ConstructionTeamCreateWithoutSiteInput[] | ConstructionTeamUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ConstructionTeamCreateOrConnectWithoutSiteInput | ConstructionTeamCreateOrConnectWithoutSiteInput[]
    upsert?: ConstructionTeamUpsertWithWhereUniqueWithoutSiteInput | ConstructionTeamUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: ConstructionTeamCreateManySiteInputEnvelope
    set?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    disconnect?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    delete?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    connect?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    update?: ConstructionTeamUpdateWithWhereUniqueWithoutSiteInput | ConstructionTeamUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: ConstructionTeamUpdateManyWithWhereWithoutSiteInput | ConstructionTeamUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: ConstructionTeamScalarWhereInput | ConstructionTeamScalarWhereInput[]
  }

  export type SiteAttendanceUpdateManyWithoutSiteNestedInput = {
    create?: XOR<SiteAttendanceCreateWithoutSiteInput, SiteAttendanceUncheckedCreateWithoutSiteInput> | SiteAttendanceCreateWithoutSiteInput[] | SiteAttendanceUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteAttendanceCreateOrConnectWithoutSiteInput | SiteAttendanceCreateOrConnectWithoutSiteInput[]
    upsert?: SiteAttendanceUpsertWithWhereUniqueWithoutSiteInput | SiteAttendanceUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: SiteAttendanceCreateManySiteInputEnvelope
    set?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    disconnect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    delete?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    connect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    update?: SiteAttendanceUpdateWithWhereUniqueWithoutSiteInput | SiteAttendanceUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: SiteAttendanceUpdateManyWithWhereWithoutSiteInput | SiteAttendanceUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: SiteAttendanceScalarWhereInput | SiteAttendanceScalarWhereInput[]
  }

  export type ConstructionTeamUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<ConstructionTeamCreateWithoutSiteInput, ConstructionTeamUncheckedCreateWithoutSiteInput> | ConstructionTeamCreateWithoutSiteInput[] | ConstructionTeamUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: ConstructionTeamCreateOrConnectWithoutSiteInput | ConstructionTeamCreateOrConnectWithoutSiteInput[]
    upsert?: ConstructionTeamUpsertWithWhereUniqueWithoutSiteInput | ConstructionTeamUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: ConstructionTeamCreateManySiteInputEnvelope
    set?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    disconnect?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    delete?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    connect?: ConstructionTeamWhereUniqueInput | ConstructionTeamWhereUniqueInput[]
    update?: ConstructionTeamUpdateWithWhereUniqueWithoutSiteInput | ConstructionTeamUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: ConstructionTeamUpdateManyWithWhereWithoutSiteInput | ConstructionTeamUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: ConstructionTeamScalarWhereInput | ConstructionTeamScalarWhereInput[]
  }

  export type SiteAttendanceUncheckedUpdateManyWithoutSiteNestedInput = {
    create?: XOR<SiteAttendanceCreateWithoutSiteInput, SiteAttendanceUncheckedCreateWithoutSiteInput> | SiteAttendanceCreateWithoutSiteInput[] | SiteAttendanceUncheckedCreateWithoutSiteInput[]
    connectOrCreate?: SiteAttendanceCreateOrConnectWithoutSiteInput | SiteAttendanceCreateOrConnectWithoutSiteInput[]
    upsert?: SiteAttendanceUpsertWithWhereUniqueWithoutSiteInput | SiteAttendanceUpsertWithWhereUniqueWithoutSiteInput[]
    createMany?: SiteAttendanceCreateManySiteInputEnvelope
    set?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    disconnect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    delete?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    connect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    update?: SiteAttendanceUpdateWithWhereUniqueWithoutSiteInput | SiteAttendanceUpdateWithWhereUniqueWithoutSiteInput[]
    updateMany?: SiteAttendanceUpdateManyWithWhereWithoutSiteInput | SiteAttendanceUpdateManyWithWhereWithoutSiteInput[]
    deleteMany?: SiteAttendanceScalarWhereInput | SiteAttendanceScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutConstructionTeamsInput = {
    create?: XOR<CompanyCreateWithoutConstructionTeamsInput, CompanyUncheckedCreateWithoutConstructionTeamsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutConstructionTeamsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ConstructionSiteCreateNestedOneWithoutTeamsInput = {
    create?: XOR<ConstructionSiteCreateWithoutTeamsInput, ConstructionSiteUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: ConstructionSiteCreateOrConnectWithoutTeamsInput
    connect?: ConstructionSiteWhereUniqueInput
  }

  export type ConstructionWorkerCreateNestedManyWithoutTeamInput = {
    create?: XOR<ConstructionWorkerCreateWithoutTeamInput, ConstructionWorkerUncheckedCreateWithoutTeamInput> | ConstructionWorkerCreateWithoutTeamInput[] | ConstructionWorkerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutTeamInput | ConstructionWorkerCreateOrConnectWithoutTeamInput[]
    createMany?: ConstructionWorkerCreateManyTeamInputEnvelope
    connect?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
  }

  export type ConstructionWorkerUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ConstructionWorkerCreateWithoutTeamInput, ConstructionWorkerUncheckedCreateWithoutTeamInput> | ConstructionWorkerCreateWithoutTeamInput[] | ConstructionWorkerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutTeamInput | ConstructionWorkerCreateOrConnectWithoutTeamInput[]
    createMany?: ConstructionWorkerCreateManyTeamInputEnvelope
    connect?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutConstructionTeamsNestedInput = {
    create?: XOR<CompanyCreateWithoutConstructionTeamsInput, CompanyUncheckedCreateWithoutConstructionTeamsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutConstructionTeamsInput
    upsert?: CompanyUpsertWithoutConstructionTeamsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutConstructionTeamsInput, CompanyUpdateWithoutConstructionTeamsInput>, CompanyUncheckedUpdateWithoutConstructionTeamsInput>
  }

  export type ConstructionSiteUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<ConstructionSiteCreateWithoutTeamsInput, ConstructionSiteUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: ConstructionSiteCreateOrConnectWithoutTeamsInput
    upsert?: ConstructionSiteUpsertWithoutTeamsInput
    connect?: ConstructionSiteWhereUniqueInput
    update?: XOR<XOR<ConstructionSiteUpdateToOneWithWhereWithoutTeamsInput, ConstructionSiteUpdateWithoutTeamsInput>, ConstructionSiteUncheckedUpdateWithoutTeamsInput>
  }

  export type ConstructionWorkerUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ConstructionWorkerCreateWithoutTeamInput, ConstructionWorkerUncheckedCreateWithoutTeamInput> | ConstructionWorkerCreateWithoutTeamInput[] | ConstructionWorkerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutTeamInput | ConstructionWorkerCreateOrConnectWithoutTeamInput[]
    upsert?: ConstructionWorkerUpsertWithWhereUniqueWithoutTeamInput | ConstructionWorkerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ConstructionWorkerCreateManyTeamInputEnvelope
    set?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    disconnect?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    delete?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    connect?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    update?: ConstructionWorkerUpdateWithWhereUniqueWithoutTeamInput | ConstructionWorkerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ConstructionWorkerUpdateManyWithWhereWithoutTeamInput | ConstructionWorkerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ConstructionWorkerScalarWhereInput | ConstructionWorkerScalarWhereInput[]
  }

  export type ConstructionWorkerUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ConstructionWorkerCreateWithoutTeamInput, ConstructionWorkerUncheckedCreateWithoutTeamInput> | ConstructionWorkerCreateWithoutTeamInput[] | ConstructionWorkerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutTeamInput | ConstructionWorkerCreateOrConnectWithoutTeamInput[]
    upsert?: ConstructionWorkerUpsertWithWhereUniqueWithoutTeamInput | ConstructionWorkerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ConstructionWorkerCreateManyTeamInputEnvelope
    set?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    disconnect?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    delete?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    connect?: ConstructionWorkerWhereUniqueInput | ConstructionWorkerWhereUniqueInput[]
    update?: ConstructionWorkerUpdateWithWhereUniqueWithoutTeamInput | ConstructionWorkerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ConstructionWorkerUpdateManyWithWhereWithoutTeamInput | ConstructionWorkerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ConstructionWorkerScalarWhereInput | ConstructionWorkerScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutConstructionWorkersInput = {
    create?: XOR<CompanyCreateWithoutConstructionWorkersInput, CompanyUncheckedCreateWithoutConstructionWorkersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutConstructionWorkersInput
    connect?: CompanyWhereUniqueInput
  }

  export type ConstructionTeamCreateNestedOneWithoutWorkersInput = {
    create?: XOR<ConstructionTeamCreateWithoutWorkersInput, ConstructionTeamUncheckedCreateWithoutWorkersInput>
    connectOrCreate?: ConstructionTeamCreateOrConnectWithoutWorkersInput
    connect?: ConstructionTeamWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutConstructionWorkerInput = {
    create?: XOR<PersonCreateWithoutConstructionWorkerInput, PersonUncheckedCreateWithoutConstructionWorkerInput>
    connectOrCreate?: PersonCreateOrConnectWithoutConstructionWorkerInput
    connect?: PersonWhereUniqueInput
  }

  export type SiteAttendanceCreateNestedManyWithoutWorkerInput = {
    create?: XOR<SiteAttendanceCreateWithoutWorkerInput, SiteAttendanceUncheckedCreateWithoutWorkerInput> | SiteAttendanceCreateWithoutWorkerInput[] | SiteAttendanceUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: SiteAttendanceCreateOrConnectWithoutWorkerInput | SiteAttendanceCreateOrConnectWithoutWorkerInput[]
    createMany?: SiteAttendanceCreateManyWorkerInputEnvelope
    connect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
  }

  export type SiteAttendanceUncheckedCreateNestedManyWithoutWorkerInput = {
    create?: XOR<SiteAttendanceCreateWithoutWorkerInput, SiteAttendanceUncheckedCreateWithoutWorkerInput> | SiteAttendanceCreateWithoutWorkerInput[] | SiteAttendanceUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: SiteAttendanceCreateOrConnectWithoutWorkerInput | SiteAttendanceCreateOrConnectWithoutWorkerInput[]
    createMany?: SiteAttendanceCreateManyWorkerInputEnvelope
    connect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutConstructionWorkersNestedInput = {
    create?: XOR<CompanyCreateWithoutConstructionWorkersInput, CompanyUncheckedCreateWithoutConstructionWorkersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutConstructionWorkersInput
    upsert?: CompanyUpsertWithoutConstructionWorkersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutConstructionWorkersInput, CompanyUpdateWithoutConstructionWorkersInput>, CompanyUncheckedUpdateWithoutConstructionWorkersInput>
  }

  export type ConstructionTeamUpdateOneRequiredWithoutWorkersNestedInput = {
    create?: XOR<ConstructionTeamCreateWithoutWorkersInput, ConstructionTeamUncheckedCreateWithoutWorkersInput>
    connectOrCreate?: ConstructionTeamCreateOrConnectWithoutWorkersInput
    upsert?: ConstructionTeamUpsertWithoutWorkersInput
    connect?: ConstructionTeamWhereUniqueInput
    update?: XOR<XOR<ConstructionTeamUpdateToOneWithWhereWithoutWorkersInput, ConstructionTeamUpdateWithoutWorkersInput>, ConstructionTeamUncheckedUpdateWithoutWorkersInput>
  }

  export type PersonUpdateOneWithoutConstructionWorkerNestedInput = {
    create?: XOR<PersonCreateWithoutConstructionWorkerInput, PersonUncheckedCreateWithoutConstructionWorkerInput>
    connectOrCreate?: PersonCreateOrConnectWithoutConstructionWorkerInput
    upsert?: PersonUpsertWithoutConstructionWorkerInput
    disconnect?: PersonWhereInput | boolean
    delete?: PersonWhereInput | boolean
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutConstructionWorkerInput, PersonUpdateWithoutConstructionWorkerInput>, PersonUncheckedUpdateWithoutConstructionWorkerInput>
  }

  export type SiteAttendanceUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<SiteAttendanceCreateWithoutWorkerInput, SiteAttendanceUncheckedCreateWithoutWorkerInput> | SiteAttendanceCreateWithoutWorkerInput[] | SiteAttendanceUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: SiteAttendanceCreateOrConnectWithoutWorkerInput | SiteAttendanceCreateOrConnectWithoutWorkerInput[]
    upsert?: SiteAttendanceUpsertWithWhereUniqueWithoutWorkerInput | SiteAttendanceUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: SiteAttendanceCreateManyWorkerInputEnvelope
    set?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    disconnect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    delete?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    connect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    update?: SiteAttendanceUpdateWithWhereUniqueWithoutWorkerInput | SiteAttendanceUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: SiteAttendanceUpdateManyWithWhereWithoutWorkerInput | SiteAttendanceUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: SiteAttendanceScalarWhereInput | SiteAttendanceScalarWhereInput[]
  }

  export type SiteAttendanceUncheckedUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<SiteAttendanceCreateWithoutWorkerInput, SiteAttendanceUncheckedCreateWithoutWorkerInput> | SiteAttendanceCreateWithoutWorkerInput[] | SiteAttendanceUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: SiteAttendanceCreateOrConnectWithoutWorkerInput | SiteAttendanceCreateOrConnectWithoutWorkerInput[]
    upsert?: SiteAttendanceUpsertWithWhereUniqueWithoutWorkerInput | SiteAttendanceUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: SiteAttendanceCreateManyWorkerInputEnvelope
    set?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    disconnect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    delete?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    connect?: SiteAttendanceWhereUniqueInput | SiteAttendanceWhereUniqueInput[]
    update?: SiteAttendanceUpdateWithWhereUniqueWithoutWorkerInput | SiteAttendanceUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: SiteAttendanceUpdateManyWithWhereWithoutWorkerInput | SiteAttendanceUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: SiteAttendanceScalarWhereInput | SiteAttendanceScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutSiteAttendanceInput = {
    create?: XOR<CompanyCreateWithoutSiteAttendanceInput, CompanyUncheckedCreateWithoutSiteAttendanceInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSiteAttendanceInput
    connect?: CompanyWhereUniqueInput
  }

  export type ConstructionSiteCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<ConstructionSiteCreateWithoutAttendanceInput, ConstructionSiteUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: ConstructionSiteCreateOrConnectWithoutAttendanceInput
    connect?: ConstructionSiteWhereUniqueInput
  }

  export type ConstructionWorkerCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<ConstructionWorkerCreateWithoutAttendanceInput, ConstructionWorkerUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutAttendanceInput
    connect?: ConstructionWorkerWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutSiteAttendanceNestedInput = {
    create?: XOR<CompanyCreateWithoutSiteAttendanceInput, CompanyUncheckedCreateWithoutSiteAttendanceInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSiteAttendanceInput
    upsert?: CompanyUpsertWithoutSiteAttendanceInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSiteAttendanceInput, CompanyUpdateWithoutSiteAttendanceInput>, CompanyUncheckedUpdateWithoutSiteAttendanceInput>
  }

  export type ConstructionSiteUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<ConstructionSiteCreateWithoutAttendanceInput, ConstructionSiteUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: ConstructionSiteCreateOrConnectWithoutAttendanceInput
    upsert?: ConstructionSiteUpsertWithoutAttendanceInput
    connect?: ConstructionSiteWhereUniqueInput
    update?: XOR<XOR<ConstructionSiteUpdateToOneWithWhereWithoutAttendanceInput, ConstructionSiteUpdateWithoutAttendanceInput>, ConstructionSiteUncheckedUpdateWithoutAttendanceInput>
  }

  export type ConstructionWorkerUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<ConstructionWorkerCreateWithoutAttendanceInput, ConstructionWorkerUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutAttendanceInput
    upsert?: ConstructionWorkerUpsertWithoutAttendanceInput
    connect?: ConstructionWorkerWhereUniqueInput
    update?: XOR<XOR<ConstructionWorkerUpdateToOneWithWhereWithoutAttendanceInput, ConstructionWorkerUpdateWithoutAttendanceInput>, ConstructionWorkerUncheckedUpdateWithoutAttendanceInput>
  }

  export type CompanyCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction | null
  }

  export type NullableEnumAuditEntityFieldUpdateOperationsInput = {
    set?: $Enums.AuditEntity | null
  }

  export type CompanyUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAuditLogsInput
    upsert?: CompanyUpsertWithoutAuditLogsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAuditLogsInput, CompanyUpdateWithoutAuditLogsInput>, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<CompanyCreateWithoutUserRolesInput, CompanyUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserRolesInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type CompanyUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<CompanyCreateWithoutUserRolesInput, CompanyUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserRolesInput
    upsert?: CompanyUpsertWithoutUserRolesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUserRolesInput, CompanyUpdateWithoutUserRolesInput>, CompanyUncheckedUpdateWithoutUserRolesInput>
  }

  export type CompanyCreateNestedOneWithoutPersonsInput = {
    create?: XOR<CompanyCreateWithoutPersonsInput, CompanyUncheckedCreateWithoutPersonsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPersonsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPersonInput = {
    create?: XOR<UserCreateWithoutPersonInput, UserUncheckedCreateWithoutPersonInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutPersonInput = {
    create?: XOR<EmployeeCreateWithoutPersonInput, EmployeeUncheckedCreateWithoutPersonInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPersonInput
    connect?: EmployeeWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutPersonInput = {
    create?: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPersonInput
    connect?: StudentWhereUniqueInput
  }

  export type WorkerCreateNestedOneWithoutPersonInput = {
    create?: XOR<WorkerCreateWithoutPersonInput, WorkerUncheckedCreateWithoutPersonInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutPersonInput
    connect?: WorkerWhereUniqueInput
  }

  export type ConstructionWorkerCreateNestedOneWithoutPersonInput = {
    create?: XOR<ConstructionWorkerCreateWithoutPersonInput, ConstructionWorkerUncheckedCreateWithoutPersonInput>
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutPersonInput
    connect?: ConstructionWorkerWhereUniqueInput
  }

  export type DeviceCreateNestedManyWithoutPersonInput = {
    create?: XOR<DeviceCreateWithoutPersonInput, DeviceUncheckedCreateWithoutPersonInput> | DeviceCreateWithoutPersonInput[] | DeviceUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutPersonInput | DeviceCreateOrConnectWithoutPersonInput[]
    createMany?: DeviceCreateManyPersonInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutPersonInput = {
    create?: XOR<UserCreateWithoutPersonInput, UserUncheckedCreateWithoutPersonInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeUncheckedCreateNestedOneWithoutPersonInput = {
    create?: XOR<EmployeeCreateWithoutPersonInput, EmployeeUncheckedCreateWithoutPersonInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPersonInput
    connect?: EmployeeWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutPersonInput = {
    create?: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPersonInput
    connect?: StudentWhereUniqueInput
  }

  export type WorkerUncheckedCreateNestedOneWithoutPersonInput = {
    create?: XOR<WorkerCreateWithoutPersonInput, WorkerUncheckedCreateWithoutPersonInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutPersonInput
    connect?: WorkerWhereUniqueInput
  }

  export type ConstructionWorkerUncheckedCreateNestedOneWithoutPersonInput = {
    create?: XOR<ConstructionWorkerCreateWithoutPersonInput, ConstructionWorkerUncheckedCreateWithoutPersonInput>
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutPersonInput
    connect?: ConstructionWorkerWhereUniqueInput
  }

  export type DeviceUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<DeviceCreateWithoutPersonInput, DeviceUncheckedCreateWithoutPersonInput> | DeviceCreateWithoutPersonInput[] | DeviceUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutPersonInput | DeviceCreateOrConnectWithoutPersonInput[]
    createMany?: DeviceCreateManyPersonInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutPersonsNestedInput = {
    create?: XOR<CompanyCreateWithoutPersonsInput, CompanyUncheckedCreateWithoutPersonsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPersonsInput
    upsert?: CompanyUpsertWithoutPersonsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPersonsInput, CompanyUpdateWithoutPersonsInput>, CompanyUncheckedUpdateWithoutPersonsInput>
  }

  export type UserUpdateOneWithoutPersonNestedInput = {
    create?: XOR<UserCreateWithoutPersonInput, UserUncheckedCreateWithoutPersonInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonInput
    upsert?: UserUpsertWithoutPersonInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersonInput, UserUpdateWithoutPersonInput>, UserUncheckedUpdateWithoutPersonInput>
  }

  export type EmployeeUpdateOneWithoutPersonNestedInput = {
    create?: XOR<EmployeeCreateWithoutPersonInput, EmployeeUncheckedCreateWithoutPersonInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPersonInput
    upsert?: EmployeeUpsertWithoutPersonInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPersonInput, EmployeeUpdateWithoutPersonInput>, EmployeeUncheckedUpdateWithoutPersonInput>
  }

  export type StudentUpdateOneWithoutPersonNestedInput = {
    create?: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPersonInput
    upsert?: StudentUpsertWithoutPersonInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutPersonInput, StudentUpdateWithoutPersonInput>, StudentUncheckedUpdateWithoutPersonInput>
  }

  export type WorkerUpdateOneWithoutPersonNestedInput = {
    create?: XOR<WorkerCreateWithoutPersonInput, WorkerUncheckedCreateWithoutPersonInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutPersonInput
    upsert?: WorkerUpsertWithoutPersonInput
    disconnect?: WorkerWhereInput | boolean
    delete?: WorkerWhereInput | boolean
    connect?: WorkerWhereUniqueInput
    update?: XOR<XOR<WorkerUpdateToOneWithWhereWithoutPersonInput, WorkerUpdateWithoutPersonInput>, WorkerUncheckedUpdateWithoutPersonInput>
  }

  export type ConstructionWorkerUpdateOneWithoutPersonNestedInput = {
    create?: XOR<ConstructionWorkerCreateWithoutPersonInput, ConstructionWorkerUncheckedCreateWithoutPersonInput>
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutPersonInput
    upsert?: ConstructionWorkerUpsertWithoutPersonInput
    disconnect?: ConstructionWorkerWhereInput | boolean
    delete?: ConstructionWorkerWhereInput | boolean
    connect?: ConstructionWorkerWhereUniqueInput
    update?: XOR<XOR<ConstructionWorkerUpdateToOneWithWhereWithoutPersonInput, ConstructionWorkerUpdateWithoutPersonInput>, ConstructionWorkerUncheckedUpdateWithoutPersonInput>
  }

  export type DeviceUpdateManyWithoutPersonNestedInput = {
    create?: XOR<DeviceCreateWithoutPersonInput, DeviceUncheckedCreateWithoutPersonInput> | DeviceCreateWithoutPersonInput[] | DeviceUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutPersonInput | DeviceCreateOrConnectWithoutPersonInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutPersonInput | DeviceUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: DeviceCreateManyPersonInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutPersonInput | DeviceUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutPersonInput | DeviceUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutPersonNestedInput = {
    create?: XOR<UserCreateWithoutPersonInput, UserUncheckedCreateWithoutPersonInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonInput
    upsert?: UserUpsertWithoutPersonInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersonInput, UserUpdateWithoutPersonInput>, UserUncheckedUpdateWithoutPersonInput>
  }

  export type EmployeeUncheckedUpdateOneWithoutPersonNestedInput = {
    create?: XOR<EmployeeCreateWithoutPersonInput, EmployeeUncheckedCreateWithoutPersonInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPersonInput
    upsert?: EmployeeUpsertWithoutPersonInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPersonInput, EmployeeUpdateWithoutPersonInput>, EmployeeUncheckedUpdateWithoutPersonInput>
  }

  export type StudentUncheckedUpdateOneWithoutPersonNestedInput = {
    create?: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPersonInput
    upsert?: StudentUpsertWithoutPersonInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutPersonInput, StudentUpdateWithoutPersonInput>, StudentUncheckedUpdateWithoutPersonInput>
  }

  export type WorkerUncheckedUpdateOneWithoutPersonNestedInput = {
    create?: XOR<WorkerCreateWithoutPersonInput, WorkerUncheckedCreateWithoutPersonInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutPersonInput
    upsert?: WorkerUpsertWithoutPersonInput
    disconnect?: WorkerWhereInput | boolean
    delete?: WorkerWhereInput | boolean
    connect?: WorkerWhereUniqueInput
    update?: XOR<XOR<WorkerUpdateToOneWithWhereWithoutPersonInput, WorkerUpdateWithoutPersonInput>, WorkerUncheckedUpdateWithoutPersonInput>
  }

  export type ConstructionWorkerUncheckedUpdateOneWithoutPersonNestedInput = {
    create?: XOR<ConstructionWorkerCreateWithoutPersonInput, ConstructionWorkerUncheckedCreateWithoutPersonInput>
    connectOrCreate?: ConstructionWorkerCreateOrConnectWithoutPersonInput
    upsert?: ConstructionWorkerUpsertWithoutPersonInput
    disconnect?: ConstructionWorkerWhereInput | boolean
    delete?: ConstructionWorkerWhereInput | boolean
    connect?: ConstructionWorkerWhereUniqueInput
    update?: XOR<XOR<ConstructionWorkerUpdateToOneWithWhereWithoutPersonInput, ConstructionWorkerUpdateWithoutPersonInput>, ConstructionWorkerUncheckedUpdateWithoutPersonInput>
  }

  export type DeviceUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<DeviceCreateWithoutPersonInput, DeviceUncheckedCreateWithoutPersonInput> | DeviceCreateWithoutPersonInput[] | DeviceUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutPersonInput | DeviceCreateOrConnectWithoutPersonInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutPersonInput | DeviceUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: DeviceCreateManyPersonInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutPersonInput | DeviceUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutPersonInput | DeviceUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEmployeesInput
    connect?: CompanyWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<PersonCreateWithoutEmployeeInput, PersonUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: PersonCreateOrConnectWithoutEmployeeInput
    connect?: PersonWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type ScheduleCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<ScheduleCreateWithoutEmployeesInput, ScheduleUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutEmployeesInput
    connect?: ScheduleWhereUniqueInput
  }

  export type AttendanceEventCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceEventCreateWithoutEmployeeInput, AttendanceEventUncheckedCreateWithoutEmployeeInput> | AttendanceEventCreateWithoutEmployeeInput[] | AttendanceEventUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutEmployeeInput | AttendanceEventCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceEventCreateManyEmployeeInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type AttendanceDailySummaryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutEmployeeInput, AttendanceDailySummaryUncheckedCreateWithoutEmployeeInput> | AttendanceDailySummaryCreateWithoutEmployeeInput[] | AttendanceDailySummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutEmployeeInput | AttendanceDailySummaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceDailySummaryCreateManyEmployeeInputEnvelope
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
  }

  export type PayrollLineCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollLineCreateWithoutEmployeeInput, PayrollLineUncheckedCreateWithoutEmployeeInput> | PayrollLineCreateWithoutEmployeeInput[] | PayrollLineUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutEmployeeInput | PayrollLineCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollLineCreateManyEmployeeInputEnvelope
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
  }

  export type ContractCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type LeaveBalanceCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveBalanceCreateWithoutEmployeeInput, LeaveBalanceUncheckedCreateWithoutEmployeeInput> | LeaveBalanceCreateWithoutEmployeeInput[] | LeaveBalanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutEmployeeInput | LeaveBalanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveBalanceCreateManyEmployeeInputEnvelope
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceEventCreateWithoutEmployeeInput, AttendanceEventUncheckedCreateWithoutEmployeeInput> | AttendanceEventCreateWithoutEmployeeInput[] | AttendanceEventUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutEmployeeInput | AttendanceEventCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceEventCreateManyEmployeeInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type AttendanceDailySummaryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutEmployeeInput, AttendanceDailySummaryUncheckedCreateWithoutEmployeeInput> | AttendanceDailySummaryCreateWithoutEmployeeInput[] | AttendanceDailySummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutEmployeeInput | AttendanceDailySummaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceDailySummaryCreateManyEmployeeInputEnvelope
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
  }

  export type PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollLineCreateWithoutEmployeeInput, PayrollLineUncheckedCreateWithoutEmployeeInput> | PayrollLineCreateWithoutEmployeeInput[] | PayrollLineUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutEmployeeInput | PayrollLineCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollLineCreateManyEmployeeInputEnvelope
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveBalanceCreateWithoutEmployeeInput, LeaveBalanceUncheckedCreateWithoutEmployeeInput> | LeaveBalanceCreateWithoutEmployeeInput[] | LeaveBalanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutEmployeeInput | LeaveBalanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveBalanceCreateManyEmployeeInputEnvelope
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEmployeesInput
    upsert?: CompanyUpsertWithoutEmployeesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutEmployeesInput, CompanyUpdateWithoutEmployeesInput>, CompanyUncheckedUpdateWithoutEmployeesInput>
  }

  export type PersonUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<PersonCreateWithoutEmployeeInput, PersonUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: PersonCreateOrConnectWithoutEmployeeInput
    upsert?: PersonUpsertWithoutEmployeeInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutEmployeeInput, PersonUpdateWithoutEmployeeInput>, PersonUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type ScheduleUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<ScheduleCreateWithoutEmployeesInput, ScheduleUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutEmployeesInput
    upsert?: ScheduleUpsertWithoutEmployeesInput
    disconnect?: ScheduleWhereInput | boolean
    delete?: ScheduleWhereInput | boolean
    connect?: ScheduleWhereUniqueInput
    update?: XOR<XOR<ScheduleUpdateToOneWithWhereWithoutEmployeesInput, ScheduleUpdateWithoutEmployeesInput>, ScheduleUncheckedUpdateWithoutEmployeesInput>
  }

  export type AttendanceEventUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutEmployeeInput, AttendanceEventUncheckedCreateWithoutEmployeeInput> | AttendanceEventCreateWithoutEmployeeInput[] | AttendanceEventUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutEmployeeInput | AttendanceEventCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceEventUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceEventCreateManyEmployeeInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceEventUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutEmployeeInput | AttendanceEventUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type AttendanceDailySummaryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutEmployeeInput, AttendanceDailySummaryUncheckedCreateWithoutEmployeeInput> | AttendanceDailySummaryCreateWithoutEmployeeInput[] | AttendanceDailySummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutEmployeeInput | AttendanceDailySummaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceDailySummaryUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceDailySummaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceDailySummaryCreateManyEmployeeInputEnvelope
    set?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    disconnect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    delete?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    update?: AttendanceDailySummaryUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceDailySummaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceDailySummaryUpdateManyWithWhereWithoutEmployeeInput | AttendanceDailySummaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceDailySummaryScalarWhereInput | AttendanceDailySummaryScalarWhereInput[]
  }

  export type PayrollLineUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollLineCreateWithoutEmployeeInput, PayrollLineUncheckedCreateWithoutEmployeeInput> | PayrollLineCreateWithoutEmployeeInput[] | PayrollLineUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutEmployeeInput | PayrollLineCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollLineUpsertWithWhereUniqueWithoutEmployeeInput | PayrollLineUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollLineCreateManyEmployeeInputEnvelope
    set?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    disconnect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    delete?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    update?: PayrollLineUpdateWithWhereUniqueWithoutEmployeeInput | PayrollLineUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollLineUpdateManyWithWhereWithoutEmployeeInput | PayrollLineUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
  }

  export type ContractUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutEmployeeInput | ContractUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutEmployeeInput | ContractUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutEmployeeInput | ContractUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type LeaveBalanceUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutEmployeeInput, LeaveBalanceUncheckedCreateWithoutEmployeeInput> | LeaveBalanceCreateWithoutEmployeeInput[] | LeaveBalanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutEmployeeInput | LeaveBalanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutEmployeeInput | LeaveBalanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveBalanceCreateManyEmployeeInputEnvelope
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutEmployeeInput | LeaveBalanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutEmployeeInput | LeaveBalanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutEmployeeInput | LeaveRequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutEmployeeInput, AttendanceEventUncheckedCreateWithoutEmployeeInput> | AttendanceEventCreateWithoutEmployeeInput[] | AttendanceEventUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutEmployeeInput | AttendanceEventCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceEventUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceEventCreateManyEmployeeInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceEventUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutEmployeeInput | AttendanceEventUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type AttendanceDailySummaryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutEmployeeInput, AttendanceDailySummaryUncheckedCreateWithoutEmployeeInput> | AttendanceDailySummaryCreateWithoutEmployeeInput[] | AttendanceDailySummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutEmployeeInput | AttendanceDailySummaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceDailySummaryUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceDailySummaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceDailySummaryCreateManyEmployeeInputEnvelope
    set?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    disconnect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    delete?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    update?: AttendanceDailySummaryUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceDailySummaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceDailySummaryUpdateManyWithWhereWithoutEmployeeInput | AttendanceDailySummaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceDailySummaryScalarWhereInput | AttendanceDailySummaryScalarWhereInput[]
  }

  export type PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollLineCreateWithoutEmployeeInput, PayrollLineUncheckedCreateWithoutEmployeeInput> | PayrollLineCreateWithoutEmployeeInput[] | PayrollLineUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutEmployeeInput | PayrollLineCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollLineUpsertWithWhereUniqueWithoutEmployeeInput | PayrollLineUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollLineCreateManyEmployeeInputEnvelope
    set?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    disconnect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    delete?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    update?: PayrollLineUpdateWithWhereUniqueWithoutEmployeeInput | PayrollLineUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollLineUpdateManyWithWhereWithoutEmployeeInput | PayrollLineUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutEmployeeInput | ContractUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutEmployeeInput | ContractUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutEmployeeInput | ContractUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutEmployeeInput, LeaveBalanceUncheckedCreateWithoutEmployeeInput> | LeaveBalanceCreateWithoutEmployeeInput[] | LeaveBalanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutEmployeeInput | LeaveBalanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutEmployeeInput | LeaveBalanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveBalanceCreateManyEmployeeInputEnvelope
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutEmployeeInput | LeaveBalanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutEmployeeInput | LeaveBalanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutEmployeeInput | LeaveRequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutWorkersInput = {
    create?: XOR<CompanyCreateWithoutWorkersInput, CompanyUncheckedCreateWithoutWorkersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWorkersInput
    connect?: CompanyWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutWorkerInput = {
    create?: XOR<PersonCreateWithoutWorkerInput, PersonUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: PersonCreateOrConnectWithoutWorkerInput
    connect?: PersonWhereUniqueInput
  }

  export type AttendanceEventCreateNestedManyWithoutWorkerInput = {
    create?: XOR<AttendanceEventCreateWithoutWorkerInput, AttendanceEventUncheckedCreateWithoutWorkerInput> | AttendanceEventCreateWithoutWorkerInput[] | AttendanceEventUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutWorkerInput | AttendanceEventCreateOrConnectWithoutWorkerInput[]
    createMany?: AttendanceEventCreateManyWorkerInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type AttendanceDailySummaryCreateNestedManyWithoutWorkerInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutWorkerInput, AttendanceDailySummaryUncheckedCreateWithoutWorkerInput> | AttendanceDailySummaryCreateWithoutWorkerInput[] | AttendanceDailySummaryUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutWorkerInput | AttendanceDailySummaryCreateOrConnectWithoutWorkerInput[]
    createMany?: AttendanceDailySummaryCreateManyWorkerInputEnvelope
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
  }

  export type AttendanceEventUncheckedCreateNestedManyWithoutWorkerInput = {
    create?: XOR<AttendanceEventCreateWithoutWorkerInput, AttendanceEventUncheckedCreateWithoutWorkerInput> | AttendanceEventCreateWithoutWorkerInput[] | AttendanceEventUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutWorkerInput | AttendanceEventCreateOrConnectWithoutWorkerInput[]
    createMany?: AttendanceEventCreateManyWorkerInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type AttendanceDailySummaryUncheckedCreateNestedManyWithoutWorkerInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutWorkerInput, AttendanceDailySummaryUncheckedCreateWithoutWorkerInput> | AttendanceDailySummaryCreateWithoutWorkerInput[] | AttendanceDailySummaryUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutWorkerInput | AttendanceDailySummaryCreateOrConnectWithoutWorkerInput[]
    createMany?: AttendanceDailySummaryCreateManyWorkerInputEnvelope
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutWorkersNestedInput = {
    create?: XOR<CompanyCreateWithoutWorkersInput, CompanyUncheckedCreateWithoutWorkersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWorkersInput
    upsert?: CompanyUpsertWithoutWorkersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutWorkersInput, CompanyUpdateWithoutWorkersInput>, CompanyUncheckedUpdateWithoutWorkersInput>
  }

  export type PersonUpdateOneRequiredWithoutWorkerNestedInput = {
    create?: XOR<PersonCreateWithoutWorkerInput, PersonUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: PersonCreateOrConnectWithoutWorkerInput
    upsert?: PersonUpsertWithoutWorkerInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutWorkerInput, PersonUpdateWithoutWorkerInput>, PersonUncheckedUpdateWithoutWorkerInput>
  }

  export type AttendanceEventUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutWorkerInput, AttendanceEventUncheckedCreateWithoutWorkerInput> | AttendanceEventCreateWithoutWorkerInput[] | AttendanceEventUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutWorkerInput | AttendanceEventCreateOrConnectWithoutWorkerInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutWorkerInput | AttendanceEventUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: AttendanceEventCreateManyWorkerInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutWorkerInput | AttendanceEventUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutWorkerInput | AttendanceEventUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type AttendanceDailySummaryUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutWorkerInput, AttendanceDailySummaryUncheckedCreateWithoutWorkerInput> | AttendanceDailySummaryCreateWithoutWorkerInput[] | AttendanceDailySummaryUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutWorkerInput | AttendanceDailySummaryCreateOrConnectWithoutWorkerInput[]
    upsert?: AttendanceDailySummaryUpsertWithWhereUniqueWithoutWorkerInput | AttendanceDailySummaryUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: AttendanceDailySummaryCreateManyWorkerInputEnvelope
    set?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    disconnect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    delete?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    update?: AttendanceDailySummaryUpdateWithWhereUniqueWithoutWorkerInput | AttendanceDailySummaryUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: AttendanceDailySummaryUpdateManyWithWhereWithoutWorkerInput | AttendanceDailySummaryUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: AttendanceDailySummaryScalarWhereInput | AttendanceDailySummaryScalarWhereInput[]
  }

  export type AttendanceEventUncheckedUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutWorkerInput, AttendanceEventUncheckedCreateWithoutWorkerInput> | AttendanceEventCreateWithoutWorkerInput[] | AttendanceEventUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutWorkerInput | AttendanceEventCreateOrConnectWithoutWorkerInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutWorkerInput | AttendanceEventUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: AttendanceEventCreateManyWorkerInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutWorkerInput | AttendanceEventUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutWorkerInput | AttendanceEventUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type AttendanceDailySummaryUncheckedUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<AttendanceDailySummaryCreateWithoutWorkerInput, AttendanceDailySummaryUncheckedCreateWithoutWorkerInput> | AttendanceDailySummaryCreateWithoutWorkerInput[] | AttendanceDailySummaryUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: AttendanceDailySummaryCreateOrConnectWithoutWorkerInput | AttendanceDailySummaryCreateOrConnectWithoutWorkerInput[]
    upsert?: AttendanceDailySummaryUpsertWithWhereUniqueWithoutWorkerInput | AttendanceDailySummaryUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: AttendanceDailySummaryCreateManyWorkerInputEnvelope
    set?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    disconnect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    delete?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    connect?: AttendanceDailySummaryWhereUniqueInput | AttendanceDailySummaryWhereUniqueInput[]
    update?: AttendanceDailySummaryUpdateWithWhereUniqueWithoutWorkerInput | AttendanceDailySummaryUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: AttendanceDailySummaryUpdateManyWithWhereWithoutWorkerInput | AttendanceDailySummaryUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: AttendanceDailySummaryScalarWhereInput | AttendanceDailySummaryScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutAttendanceEventsInput = {
    create?: XOR<CompanyCreateWithoutAttendanceEventsInput, CompanyUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAttendanceEventsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendancesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAttendanceEventsInput = {
    create?: XOR<StudentCreateWithoutAttendanceEventsInput, StudentUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceEventsInput
    connect?: StudentWhereUniqueInput
  }

  export type WorkerCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<WorkerCreateWithoutAttendancesInput, WorkerUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutAttendancesInput
    connect?: WorkerWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutAttendanceEventsInput = {
    create?: XOR<DeviceCreateWithoutAttendanceEventsInput, DeviceUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutAttendanceEventsInput
    connect?: DeviceWhereUniqueInput
  }

  export type EnumAttendanceTypeFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceType
  }

  export type EnumPersonTypeFieldUpdateOperationsInput = {
    set?: $Enums.PersonType
  }

  export type CompanyUpdateOneRequiredWithoutAttendanceEventsNestedInput = {
    create?: XOR<CompanyCreateWithoutAttendanceEventsInput, CompanyUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAttendanceEventsInput
    upsert?: CompanyUpsertWithoutAttendanceEventsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAttendanceEventsInput, CompanyUpdateWithoutAttendanceEventsInput>, CompanyUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type EmployeeUpdateOneWithoutAttendancesNestedInput = {
    create?: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendancesInput
    upsert?: EmployeeUpsertWithoutAttendancesInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAttendancesInput, EmployeeUpdateWithoutAttendancesInput>, EmployeeUncheckedUpdateWithoutAttendancesInput>
  }

  export type StudentUpdateOneWithoutAttendanceEventsNestedInput = {
    create?: XOR<StudentCreateWithoutAttendanceEventsInput, StudentUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceEventsInput
    upsert?: StudentUpsertWithoutAttendanceEventsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAttendanceEventsInput, StudentUpdateWithoutAttendanceEventsInput>, StudentUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type WorkerUpdateOneWithoutAttendancesNestedInput = {
    create?: XOR<WorkerCreateWithoutAttendancesInput, WorkerUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutAttendancesInput
    upsert?: WorkerUpsertWithoutAttendancesInput
    disconnect?: WorkerWhereInput | boolean
    delete?: WorkerWhereInput | boolean
    connect?: WorkerWhereUniqueInput
    update?: XOR<XOR<WorkerUpdateToOneWithWhereWithoutAttendancesInput, WorkerUpdateWithoutAttendancesInput>, WorkerUncheckedUpdateWithoutAttendancesInput>
  }

  export type DeviceUpdateOneWithoutAttendanceEventsNestedInput = {
    create?: XOR<DeviceCreateWithoutAttendanceEventsInput, DeviceUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutAttendanceEventsInput
    upsert?: DeviceUpsertWithoutAttendanceEventsInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutAttendanceEventsInput, DeviceUpdateWithoutAttendanceEventsInput>, DeviceUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type CompanyCreateNestedOneWithoutAttendanceDailySummariesInput = {
    create?: XOR<CompanyCreateWithoutAttendanceDailySummariesInput, CompanyUncheckedCreateWithoutAttendanceDailySummariesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAttendanceDailySummariesInput
    connect?: CompanyWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutDailySummariesInput = {
    create?: XOR<EmployeeCreateWithoutDailySummariesInput, EmployeeUncheckedCreateWithoutDailySummariesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDailySummariesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutDailySummariesInput = {
    create?: XOR<StudentCreateWithoutDailySummariesInput, StudentUncheckedCreateWithoutDailySummariesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutDailySummariesInput
    connect?: StudentWhereUniqueInput
  }

  export type WorkerCreateNestedOneWithoutDailySummariesInput = {
    create?: XOR<WorkerCreateWithoutDailySummariesInput, WorkerUncheckedCreateWithoutDailySummariesInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutDailySummariesInput
    connect?: WorkerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAttendanceValidationsInput = {
    create?: XOR<UserCreateWithoutAttendanceValidationsInput, UserUncheckedCreateWithoutAttendanceValidationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceValidationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateOneRequiredWithoutAttendanceDailySummariesNestedInput = {
    create?: XOR<CompanyCreateWithoutAttendanceDailySummariesInput, CompanyUncheckedCreateWithoutAttendanceDailySummariesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAttendanceDailySummariesInput
    upsert?: CompanyUpsertWithoutAttendanceDailySummariesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAttendanceDailySummariesInput, CompanyUpdateWithoutAttendanceDailySummariesInput>, CompanyUncheckedUpdateWithoutAttendanceDailySummariesInput>
  }

  export type EmployeeUpdateOneWithoutDailySummariesNestedInput = {
    create?: XOR<EmployeeCreateWithoutDailySummariesInput, EmployeeUncheckedCreateWithoutDailySummariesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDailySummariesInput
    upsert?: EmployeeUpsertWithoutDailySummariesInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutDailySummariesInput, EmployeeUpdateWithoutDailySummariesInput>, EmployeeUncheckedUpdateWithoutDailySummariesInput>
  }

  export type StudentUpdateOneWithoutDailySummariesNestedInput = {
    create?: XOR<StudentCreateWithoutDailySummariesInput, StudentUncheckedCreateWithoutDailySummariesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutDailySummariesInput
    upsert?: StudentUpsertWithoutDailySummariesInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutDailySummariesInput, StudentUpdateWithoutDailySummariesInput>, StudentUncheckedUpdateWithoutDailySummariesInput>
  }

  export type WorkerUpdateOneWithoutDailySummariesNestedInput = {
    create?: XOR<WorkerCreateWithoutDailySummariesInput, WorkerUncheckedCreateWithoutDailySummariesInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutDailySummariesInput
    upsert?: WorkerUpsertWithoutDailySummariesInput
    disconnect?: WorkerWhereInput | boolean
    delete?: WorkerWhereInput | boolean
    connect?: WorkerWhereUniqueInput
    update?: XOR<XOR<WorkerUpdateToOneWithWhereWithoutDailySummariesInput, WorkerUpdateWithoutDailySummariesInput>, WorkerUncheckedUpdateWithoutDailySummariesInput>
  }

  export type UserUpdateOneWithoutAttendanceValidationsNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceValidationsInput, UserUncheckedCreateWithoutAttendanceValidationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceValidationsInput
    upsert?: UserUpsertWithoutAttendanceValidationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceValidationsInput, UserUpdateWithoutAttendanceValidationsInput>, UserUncheckedUpdateWithoutAttendanceValidationsInput>
  }

  export type PersonCreateNestedOneWithoutDevicesInput = {
    create?: XOR<PersonCreateWithoutDevicesInput, PersonUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDevicesInput
    connect?: PersonWhereUniqueInput
  }

  export type AttendanceEventCreateNestedManyWithoutDeviceInput = {
    create?: XOR<AttendanceEventCreateWithoutDeviceInput, AttendanceEventUncheckedCreateWithoutDeviceInput> | AttendanceEventCreateWithoutDeviceInput[] | AttendanceEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutDeviceInput | AttendanceEventCreateOrConnectWithoutDeviceInput[]
    createMany?: AttendanceEventCreateManyDeviceInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutDevicesInput = {
    create?: XOR<CompanyCreateWithoutDevicesInput, CompanyUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDevicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type AttendanceEventUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<AttendanceEventCreateWithoutDeviceInput, AttendanceEventUncheckedCreateWithoutDeviceInput> | AttendanceEventCreateWithoutDeviceInput[] | AttendanceEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutDeviceInput | AttendanceEventCreateOrConnectWithoutDeviceInput[]
    createMany?: AttendanceEventCreateManyDeviceInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type PersonUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<PersonCreateWithoutDevicesInput, PersonUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDevicesInput
    upsert?: PersonUpsertWithoutDevicesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutDevicesInput, PersonUpdateWithoutDevicesInput>, PersonUncheckedUpdateWithoutDevicesInput>
  }

  export type AttendanceEventUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutDeviceInput, AttendanceEventUncheckedCreateWithoutDeviceInput> | AttendanceEventCreateWithoutDeviceInput[] | AttendanceEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutDeviceInput | AttendanceEventCreateOrConnectWithoutDeviceInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutDeviceInput | AttendanceEventUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: AttendanceEventCreateManyDeviceInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutDeviceInput | AttendanceEventUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutDeviceInput | AttendanceEventUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<CompanyCreateWithoutDevicesInput, CompanyUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDevicesInput
    upsert?: CompanyUpsertWithoutDevicesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDevicesInput, CompanyUpdateWithoutDevicesInput>, CompanyUncheckedUpdateWithoutDevicesInput>
  }

  export type AttendanceEventUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutDeviceInput, AttendanceEventUncheckedCreateWithoutDeviceInput> | AttendanceEventCreateWithoutDeviceInput[] | AttendanceEventUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutDeviceInput | AttendanceEventCreateOrConnectWithoutDeviceInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutDeviceInput | AttendanceEventUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: AttendanceEventCreateManyDeviceInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutDeviceInput | AttendanceEventUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutDeviceInput | AttendanceEventUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutLeaveTypesInput = {
    create?: XOR<CompanyCreateWithoutLeaveTypesInput, CompanyUncheckedCreateWithoutLeaveTypesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutLeaveTypesInput
    connect?: CompanyWhereUniqueInput
  }

  export type LeaveBalanceCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LeaveBalanceCreateWithoutLeaveTypeInput, LeaveBalanceUncheckedCreateWithoutLeaveTypeInput> | LeaveBalanceCreateWithoutLeaveTypeInput[] | LeaveBalanceUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutLeaveTypeInput | LeaveBalanceCreateOrConnectWithoutLeaveTypeInput[]
    createMany?: LeaveBalanceCreateManyLeaveTypeInputEnvelope
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LeaveRequestCreateWithoutLeaveTypeInput, LeaveRequestUncheckedCreateWithoutLeaveTypeInput> | LeaveRequestCreateWithoutLeaveTypeInput[] | LeaveRequestUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutLeaveTypeInput | LeaveRequestCreateOrConnectWithoutLeaveTypeInput[]
    createMany?: LeaveRequestCreateManyLeaveTypeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type LeaveBalanceUncheckedCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LeaveBalanceCreateWithoutLeaveTypeInput, LeaveBalanceUncheckedCreateWithoutLeaveTypeInput> | LeaveBalanceCreateWithoutLeaveTypeInput[] | LeaveBalanceUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutLeaveTypeInput | LeaveBalanceCreateOrConnectWithoutLeaveTypeInput[]
    createMany?: LeaveBalanceCreateManyLeaveTypeInputEnvelope
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LeaveRequestCreateWithoutLeaveTypeInput, LeaveRequestUncheckedCreateWithoutLeaveTypeInput> | LeaveRequestCreateWithoutLeaveTypeInput[] | LeaveRequestUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutLeaveTypeInput | LeaveRequestCreateOrConnectWithoutLeaveTypeInput[]
    createMany?: LeaveRequestCreateManyLeaveTypeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutLeaveTypesNestedInput = {
    create?: XOR<CompanyCreateWithoutLeaveTypesInput, CompanyUncheckedCreateWithoutLeaveTypesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutLeaveTypesInput
    upsert?: CompanyUpsertWithoutLeaveTypesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutLeaveTypesInput, CompanyUpdateWithoutLeaveTypesInput>, CompanyUncheckedUpdateWithoutLeaveTypesInput>
  }

  export type LeaveBalanceUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutLeaveTypeInput, LeaveBalanceUncheckedCreateWithoutLeaveTypeInput> | LeaveBalanceCreateWithoutLeaveTypeInput[] | LeaveBalanceUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutLeaveTypeInput | LeaveBalanceCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutLeaveTypeInput | LeaveBalanceUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    createMany?: LeaveBalanceCreateManyLeaveTypeInputEnvelope
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutLeaveTypeInput | LeaveBalanceUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutLeaveTypeInput | LeaveBalanceUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutLeaveTypeInput, LeaveRequestUncheckedCreateWithoutLeaveTypeInput> | LeaveRequestCreateWithoutLeaveTypeInput[] | LeaveRequestUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutLeaveTypeInput | LeaveRequestCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutLeaveTypeInput | LeaveRequestUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    createMany?: LeaveRequestCreateManyLeaveTypeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutLeaveTypeInput | LeaveRequestUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutLeaveTypeInput | LeaveRequestUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutLeaveTypeInput, LeaveBalanceUncheckedCreateWithoutLeaveTypeInput> | LeaveBalanceCreateWithoutLeaveTypeInput[] | LeaveBalanceUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutLeaveTypeInput | LeaveBalanceCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutLeaveTypeInput | LeaveBalanceUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    createMany?: LeaveBalanceCreateManyLeaveTypeInputEnvelope
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutLeaveTypeInput | LeaveBalanceUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutLeaveTypeInput | LeaveBalanceUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutLeaveTypeInput, LeaveRequestUncheckedCreateWithoutLeaveTypeInput> | LeaveRequestCreateWithoutLeaveTypeInput[] | LeaveRequestUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutLeaveTypeInput | LeaveRequestCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutLeaveTypeInput | LeaveRequestUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    createMany?: LeaveRequestCreateManyLeaveTypeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutLeaveTypeInput | LeaveRequestUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutLeaveTypeInput | LeaveRequestUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutLeaveBalancesInput = {
    create?: XOR<CompanyCreateWithoutLeaveBalancesInput, CompanyUncheckedCreateWithoutLeaveBalancesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutLeaveBalancesInput
    connect?: CompanyWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutLeaveBalancesInput = {
    create?: XOR<EmployeeCreateWithoutLeaveBalancesInput, EmployeeUncheckedCreateWithoutLeaveBalancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveBalancesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type LeaveTypeCreateNestedOneWithoutBalancesInput = {
    create?: XOR<LeaveTypeCreateWithoutBalancesInput, LeaveTypeUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutBalancesInput
    connect?: LeaveTypeWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateOneRequiredWithoutLeaveBalancesNestedInput = {
    create?: XOR<CompanyCreateWithoutLeaveBalancesInput, CompanyUncheckedCreateWithoutLeaveBalancesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutLeaveBalancesInput
    upsert?: CompanyUpsertWithoutLeaveBalancesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutLeaveBalancesInput, CompanyUpdateWithoutLeaveBalancesInput>, CompanyUncheckedUpdateWithoutLeaveBalancesInput>
  }

  export type EmployeeUpdateOneRequiredWithoutLeaveBalancesNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeaveBalancesInput, EmployeeUncheckedCreateWithoutLeaveBalancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveBalancesInput
    upsert?: EmployeeUpsertWithoutLeaveBalancesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeaveBalancesInput, EmployeeUpdateWithoutLeaveBalancesInput>, EmployeeUncheckedUpdateWithoutLeaveBalancesInput>
  }

  export type LeaveTypeUpdateOneRequiredWithoutBalancesNestedInput = {
    create?: XOR<LeaveTypeCreateWithoutBalancesInput, LeaveTypeUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutBalancesInput
    upsert?: LeaveTypeUpsertWithoutBalancesInput
    connect?: LeaveTypeWhereUniqueInput
    update?: XOR<XOR<LeaveTypeUpdateToOneWithWhereWithoutBalancesInput, LeaveTypeUpdateWithoutBalancesInput>, LeaveTypeUncheckedUpdateWithoutBalancesInput>
  }

  export type CompanyCreateNestedOneWithoutLeaveRequestsInput = {
    create?: XOR<CompanyCreateWithoutLeaveRequestsInput, CompanyUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutLeaveRequestsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutLeaveRequestsInput = {
    create?: XOR<EmployeeCreateWithoutLeaveRequestsInput, EmployeeUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveRequestsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type LeaveTypeCreateNestedOneWithoutRequestsInput = {
    create?: XOR<LeaveTypeCreateWithoutRequestsInput, LeaveTypeUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutRequestsInput
    connect?: LeaveTypeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLeaveValidationsInput = {
    create?: XOR<UserCreateWithoutLeaveValidationsInput, UserUncheckedCreateWithoutLeaveValidationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveValidationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLeaveStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaveStatus
  }

  export type CompanyUpdateOneRequiredWithoutLeaveRequestsNestedInput = {
    create?: XOR<CompanyCreateWithoutLeaveRequestsInput, CompanyUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutLeaveRequestsInput
    upsert?: CompanyUpsertWithoutLeaveRequestsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutLeaveRequestsInput, CompanyUpdateWithoutLeaveRequestsInput>, CompanyUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutLeaveRequestsNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeaveRequestsInput, EmployeeUncheckedCreateWithoutLeaveRequestsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveRequestsInput
    upsert?: EmployeeUpsertWithoutLeaveRequestsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeaveRequestsInput, EmployeeUpdateWithoutLeaveRequestsInput>, EmployeeUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type LeaveTypeUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<LeaveTypeCreateWithoutRequestsInput, LeaveTypeUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutRequestsInput
    upsert?: LeaveTypeUpsertWithoutRequestsInput
    connect?: LeaveTypeWhereUniqueInput
    update?: XOR<XOR<LeaveTypeUpdateToOneWithWhereWithoutRequestsInput, LeaveTypeUpdateWithoutRequestsInput>, LeaveTypeUncheckedUpdateWithoutRequestsInput>
  }

  export type UserUpdateOneWithoutLeaveValidationsNestedInput = {
    create?: XOR<UserCreateWithoutLeaveValidationsInput, UserUncheckedCreateWithoutLeaveValidationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveValidationsInput
    upsert?: UserUpsertWithoutLeaveValidationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaveValidationsInput, UserUpdateWithoutLeaveValidationsInput>, UserUncheckedUpdateWithoutLeaveValidationsInput>
  }

  export type CompanyCreateNestedOneWithoutPublicHolidaysInput = {
    create?: XOR<CompanyCreateWithoutPublicHolidaysInput, CompanyUncheckedCreateWithoutPublicHolidaysInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPublicHolidaysInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutPublicHolidaysNestedInput = {
    create?: XOR<CompanyCreateWithoutPublicHolidaysInput, CompanyUncheckedCreateWithoutPublicHolidaysInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPublicHolidaysInput
    upsert?: CompanyUpsertWithoutPublicHolidaysInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPublicHolidaysInput, CompanyUpdateWithoutPublicHolidaysInput>, CompanyUncheckedUpdateWithoutPublicHolidaysInput>
  }

  export type CompanyCreateNestedOneWithoutContractsInput = {
    create?: XOR<CompanyCreateWithoutContractsInput, CompanyUncheckedCreateWithoutContractsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContractsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutContractsInput = {
    create?: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutContractsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumSalaryTypeFieldUpdateOperationsInput = {
    set?: $Enums.SalaryType
  }

  export type CompanyUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<CompanyCreateWithoutContractsInput, CompanyUncheckedCreateWithoutContractsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContractsInput
    upsert?: CompanyUpsertWithoutContractsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutContractsInput, CompanyUpdateWithoutContractsInput>, CompanyUncheckedUpdateWithoutContractsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutContractsInput
    upsert?: EmployeeUpsertWithoutContractsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutContractsInput, EmployeeUpdateWithoutContractsInput>, EmployeeUncheckedUpdateWithoutContractsInput>
  }

  export type CompanyCreateNestedOneWithoutPayrollPeriodsInput = {
    create?: XOR<CompanyCreateWithoutPayrollPeriodsInput, CompanyUncheckedCreateWithoutPayrollPeriodsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPayrollPeriodsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPayrollPeriodClosuresInput = {
    create?: XOR<UserCreateWithoutPayrollPeriodClosuresInput, UserUncheckedCreateWithoutPayrollPeriodClosuresInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollPeriodClosuresInput
    connect?: UserWhereUniqueInput
  }

  export type PayrollLineCreateNestedManyWithoutPayrollPeriodInput = {
    create?: XOR<PayrollLineCreateWithoutPayrollPeriodInput, PayrollLineUncheckedCreateWithoutPayrollPeriodInput> | PayrollLineCreateWithoutPayrollPeriodInput[] | PayrollLineUncheckedCreateWithoutPayrollPeriodInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutPayrollPeriodInput | PayrollLineCreateOrConnectWithoutPayrollPeriodInput[]
    createMany?: PayrollLineCreateManyPayrollPeriodInputEnvelope
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
  }

  export type PayrollLineUncheckedCreateNestedManyWithoutPayrollPeriodInput = {
    create?: XOR<PayrollLineCreateWithoutPayrollPeriodInput, PayrollLineUncheckedCreateWithoutPayrollPeriodInput> | PayrollLineCreateWithoutPayrollPeriodInput[] | PayrollLineUncheckedCreateWithoutPayrollPeriodInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutPayrollPeriodInput | PayrollLineCreateOrConnectWithoutPayrollPeriodInput[]
    createMany?: PayrollLineCreateManyPayrollPeriodInputEnvelope
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutPayrollPeriodsNestedInput = {
    create?: XOR<CompanyCreateWithoutPayrollPeriodsInput, CompanyUncheckedCreateWithoutPayrollPeriodsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPayrollPeriodsInput
    upsert?: CompanyUpsertWithoutPayrollPeriodsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPayrollPeriodsInput, CompanyUpdateWithoutPayrollPeriodsInput>, CompanyUncheckedUpdateWithoutPayrollPeriodsInput>
  }

  export type UserUpdateOneWithoutPayrollPeriodClosuresNestedInput = {
    create?: XOR<UserCreateWithoutPayrollPeriodClosuresInput, UserUncheckedCreateWithoutPayrollPeriodClosuresInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollPeriodClosuresInput
    upsert?: UserUpsertWithoutPayrollPeriodClosuresInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPayrollPeriodClosuresInput, UserUpdateWithoutPayrollPeriodClosuresInput>, UserUncheckedUpdateWithoutPayrollPeriodClosuresInput>
  }

  export type PayrollLineUpdateManyWithoutPayrollPeriodNestedInput = {
    create?: XOR<PayrollLineCreateWithoutPayrollPeriodInput, PayrollLineUncheckedCreateWithoutPayrollPeriodInput> | PayrollLineCreateWithoutPayrollPeriodInput[] | PayrollLineUncheckedCreateWithoutPayrollPeriodInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutPayrollPeriodInput | PayrollLineCreateOrConnectWithoutPayrollPeriodInput[]
    upsert?: PayrollLineUpsertWithWhereUniqueWithoutPayrollPeriodInput | PayrollLineUpsertWithWhereUniqueWithoutPayrollPeriodInput[]
    createMany?: PayrollLineCreateManyPayrollPeriodInputEnvelope
    set?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    disconnect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    delete?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    update?: PayrollLineUpdateWithWhereUniqueWithoutPayrollPeriodInput | PayrollLineUpdateWithWhereUniqueWithoutPayrollPeriodInput[]
    updateMany?: PayrollLineUpdateManyWithWhereWithoutPayrollPeriodInput | PayrollLineUpdateManyWithWhereWithoutPayrollPeriodInput[]
    deleteMany?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
  }

  export type PayrollLineUncheckedUpdateManyWithoutPayrollPeriodNestedInput = {
    create?: XOR<PayrollLineCreateWithoutPayrollPeriodInput, PayrollLineUncheckedCreateWithoutPayrollPeriodInput> | PayrollLineCreateWithoutPayrollPeriodInput[] | PayrollLineUncheckedCreateWithoutPayrollPeriodInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutPayrollPeriodInput | PayrollLineCreateOrConnectWithoutPayrollPeriodInput[]
    upsert?: PayrollLineUpsertWithWhereUniqueWithoutPayrollPeriodInput | PayrollLineUpsertWithWhereUniqueWithoutPayrollPeriodInput[]
    createMany?: PayrollLineCreateManyPayrollPeriodInputEnvelope
    set?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    disconnect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    delete?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    update?: PayrollLineUpdateWithWhereUniqueWithoutPayrollPeriodInput | PayrollLineUpdateWithWhereUniqueWithoutPayrollPeriodInput[]
    updateMany?: PayrollLineUpdateManyWithWhereWithoutPayrollPeriodInput | PayrollLineUpdateManyWithWhereWithoutPayrollPeriodInput[]
    deleteMany?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutPayrollLinesInput = {
    create?: XOR<CompanyCreateWithoutPayrollLinesInput, CompanyUncheckedCreateWithoutPayrollLinesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPayrollLinesInput
    connect?: CompanyWhereUniqueInput
  }

  export type PayrollPeriodCreateNestedOneWithoutLinesInput = {
    create?: XOR<PayrollPeriodCreateWithoutLinesInput, PayrollPeriodUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutLinesInput
    connect?: PayrollPeriodWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutPayrollLinesInput = {
    create?: XOR<EmployeeCreateWithoutPayrollLinesInput, EmployeeUncheckedCreateWithoutPayrollLinesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayrollLinesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutPayrollLinesNestedInput = {
    create?: XOR<CompanyCreateWithoutPayrollLinesInput, CompanyUncheckedCreateWithoutPayrollLinesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPayrollLinesInput
    upsert?: CompanyUpsertWithoutPayrollLinesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPayrollLinesInput, CompanyUpdateWithoutPayrollLinesInput>, CompanyUncheckedUpdateWithoutPayrollLinesInput>
  }

  export type PayrollPeriodUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<PayrollPeriodCreateWithoutLinesInput, PayrollPeriodUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutLinesInput
    upsert?: PayrollPeriodUpsertWithoutLinesInput
    connect?: PayrollPeriodWhereUniqueInput
    update?: XOR<XOR<PayrollPeriodUpdateToOneWithWhereWithoutLinesInput, PayrollPeriodUpdateWithoutLinesInput>, PayrollPeriodUncheckedUpdateWithoutLinesInput>
  }

  export type EmployeeUpdateOneRequiredWithoutPayrollLinesNestedInput = {
    create?: XOR<EmployeeCreateWithoutPayrollLinesInput, EmployeeUncheckedCreateWithoutPayrollLinesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayrollLinesInput
    upsert?: EmployeeUpsertWithoutPayrollLinesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPayrollLinesInput, EmployeeUpdateWithoutPayrollLinesInput>, EmployeeUncheckedUpdateWithoutPayrollLinesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumCompanyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyType | EnumCompanyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyTypeFilter<$PrismaModel> | $Enums.CompanyType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumCompanyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyType | EnumCompanyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CompanyType[] | ListEnumCompanyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompanyTypeWithAggregatesFilter<$PrismaModel> | $Enums.CompanyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyTypeFilter<$PrismaModel>
    _max?: NestedEnumCompanyTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumOvertimeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OvertimeStatus | EnumOvertimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOvertimeStatusFilter<$PrismaModel> | $Enums.OvertimeStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumOvertimeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OvertimeStatus | EnumOvertimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOvertimeStatusWithAggregatesFilter<$PrismaModel> | $Enums.OvertimeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOvertimeStatusFilter<$PrismaModel>
    _max?: NestedEnumOvertimeStatusFilter<$PrismaModel>
  }

  export type NestedEnumPayrollStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollStatus | EnumPayrollStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayrollStatusFilter<$PrismaModel> | $Enums.PayrollStatus
  }

  export type NestedEnumPayrollStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollStatus | EnumPayrollStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayrollStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayrollStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayrollStatusFilter<$PrismaModel>
    _max?: NestedEnumPayrollStatusFilter<$PrismaModel>
  }

  export type NestedEnumExportFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ExportFormat | EnumExportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumExportFormatFilter<$PrismaModel> | $Enums.ExportFormat
  }

  export type NestedEnumExportFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExportFormat | EnumExportFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExportFormat[] | ListEnumExportFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumExportFormatWithAggregatesFilter<$PrismaModel> | $Enums.ExportFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExportFormatFilter<$PrismaModel>
    _max?: NestedEnumExportFormatFilter<$PrismaModel>
  }

  export type NestedEnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type NestedEnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumStudentAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentAttendanceStatus | EnumStudentAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentAttendanceStatus[] | ListEnumStudentAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentAttendanceStatus[] | ListEnumStudentAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentAttendanceStatusFilter<$PrismaModel> | $Enums.StudentAttendanceStatus
  }

  export type NestedEnumStudentAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentAttendanceStatus | EnumStudentAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentAttendanceStatus[] | ListEnumStudentAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentAttendanceStatus[] | ListEnumStudentAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentAttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel> | null
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAuditActionNullableFilter<$PrismaModel> | $Enums.AuditAction | null
  }

  export type NestedEnumAuditEntityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntity | EnumAuditEntityFieldRefInput<$PrismaModel> | null
    in?: $Enums.AuditEntity[] | ListEnumAuditEntityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AuditEntity[] | ListEnumAuditEntityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAuditEntityNullableFilter<$PrismaModel> | $Enums.AuditEntity | null
  }

  export type NestedEnumAuditActionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel> | null
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAuditActionNullableWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAuditActionNullableFilter<$PrismaModel>
    _max?: NestedEnumAuditActionNullableFilter<$PrismaModel>
  }

  export type NestedEnumAuditEntityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntity | EnumAuditEntityFieldRefInput<$PrismaModel> | null
    in?: $Enums.AuditEntity[] | ListEnumAuditEntityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AuditEntity[] | ListEnumAuditEntityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAuditEntityNullableWithAggregatesFilter<$PrismaModel> | $Enums.AuditEntity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAuditEntityNullableFilter<$PrismaModel>
    _max?: NestedEnumAuditEntityNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceType | EnumAttendanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceTypeFilter<$PrismaModel> | $Enums.AttendanceType
  }

  export type NestedEnumPersonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonTypeFilter<$PrismaModel> | $Enums.PersonType
  }

  export type NestedEnumAttendanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceType | EnumAttendanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceTypeFilter<$PrismaModel>
    _max?: NestedEnumAttendanceTypeFilter<$PrismaModel>
  }

  export type NestedEnumPersonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonTypeWithAggregatesFilter<$PrismaModel> | $Enums.PersonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonTypeFilter<$PrismaModel>
    _max?: NestedEnumPersonTypeFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type NestedEnumSalaryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryType | EnumSalaryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryType[] | ListEnumSalaryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryType[] | ListEnumSalaryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryTypeFilter<$PrismaModel> | $Enums.SalaryType
  }

  export type NestedEnumSalaryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryType | EnumSalaryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryType[] | ListEnumSalaryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryType[] | ListEnumSalaryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryTypeWithAggregatesFilter<$PrismaModel> | $Enums.SalaryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalaryTypeFilter<$PrismaModel>
    _max?: NestedEnumSalaryTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    person?: PersonCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeUncheckedCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestUncheckedCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodUncheckedCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PersonCreateWithoutCompanyInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutPersonInput
    employee?: EmployeeCreateNestedOneWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    worker?: WorkerCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerCreateNestedOneWithoutPersonInput
    devices?: DeviceCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutCompanyInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserUncheckedCreateNestedOneWithoutPersonInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    worker?: WorkerUncheckedCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerUncheckedCreateNestedOneWithoutPersonInput
    devices?: DeviceUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutCompanyInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutCompanyInput, PersonUncheckedCreateWithoutCompanyInput>
  }

  export type PersonCreateManyCompanyInputEnvelope = {
    data: PersonCreateManyCompanyInput | PersonCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutCompanyInput = {
    id?: string
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    person: PersonCreateNestedOneWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    schedule?: ScheduleCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineCreateNestedManyWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutCompanyInput = {
    id?: string
    personId: string
    userId?: string | null
    scheduleId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutCompanyInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutCompanyInput, EmployeeUncheckedCreateWithoutCompanyInput>
  }

  export type EmployeeCreateManyCompanyInputEnvelope = {
    data: EmployeeCreateManyCompanyInput | EmployeeCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type WorkerCreateWithoutCompanyInput = {
    id?: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    person: PersonCreateNestedOneWithoutWorkerInput
    attendances?: AttendanceEventCreateNestedManyWithoutWorkerInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUncheckedCreateWithoutCompanyInput = {
    id?: string
    personId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutWorkerInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type WorkerCreateOrConnectWithoutCompanyInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutCompanyInput, WorkerUncheckedCreateWithoutCompanyInput>
  }

  export type WorkerCreateManyCompanyInputEnvelope = {
    data: WorkerCreateManyCompanyInput | WorkerCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutCompanyInput = {
    id?: string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutCompanyInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutCompanyInput, AttendanceUncheckedCreateWithoutCompanyInput>
  }

  export type AttendanceCreateManyCompanyInputEnvelope = {
    data: AttendanceCreateManyCompanyInput | AttendanceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceEventCreateWithoutCompanyInput = {
    id?: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    createdAt?: Date | string
    deletedAt?: Date | string | null
    employee?: EmployeeCreateNestedOneWithoutAttendancesInput
    student?: StudentCreateNestedOneWithoutAttendanceEventsInput
    worker?: WorkerCreateNestedOneWithoutAttendancesInput
    device?: DeviceCreateNestedOneWithoutAttendanceEventsInput
  }

  export type AttendanceEventUncheckedCreateWithoutCompanyInput = {
    id?: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    employeeId?: string | null
    studentId?: string | null
    workerId?: string | null
    deviceId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceEventCreateOrConnectWithoutCompanyInput = {
    where: AttendanceEventWhereUniqueInput
    create: XOR<AttendanceEventCreateWithoutCompanyInput, AttendanceEventUncheckedCreateWithoutCompanyInput>
  }

  export type AttendanceEventCreateManyCompanyInputEnvelope = {
    data: AttendanceEventCreateManyCompanyInput | AttendanceEventCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceDailySummaryCreateWithoutCompanyInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    employee?: EmployeeCreateNestedOneWithoutDailySummariesInput
    student?: StudentCreateNestedOneWithoutDailySummariesInput
    worker?: WorkerCreateNestedOneWithoutDailySummariesInput
    validatedBy?: UserCreateNestedOneWithoutAttendanceValidationsInput
  }

  export type AttendanceDailySummaryUncheckedCreateWithoutCompanyInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    employeeId?: string | null
    studentId?: string | null
    workerId?: string | null
    validatedByUserId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceDailySummaryCreateOrConnectWithoutCompanyInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    create: XOR<AttendanceDailySummaryCreateWithoutCompanyInput, AttendanceDailySummaryUncheckedCreateWithoutCompanyInput>
  }

  export type AttendanceDailySummaryCreateManyCompanyInputEnvelope = {
    data: AttendanceDailySummaryCreateManyCompanyInput | AttendanceDailySummaryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutCompanyInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    daysOfWeek?: ScheduleCreatedaysOfWeekInput | string[]
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    daysOfWeek?: ScheduleCreatedaysOfWeekInput | string[]
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleCreateOrConnectWithoutCompanyInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutCompanyInput, ScheduleUncheckedCreateWithoutCompanyInput>
  }

  export type ScheduleCreateManyCompanyInputEnvelope = {
    data: ScheduleCreateManyCompanyInput | ScheduleCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type OvertimeCreateWithoutCompanyInput = {
    id?: string
    date: Date | string
    hours: number
    reason?: string | null
    status?: $Enums.OvertimeStatus
    approvedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOvertimeRequestsInput
    approvedBy?: UserCreateNestedOneWithoutOvertimeApprovalsInput
  }

  export type OvertimeUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    date: Date | string
    hours: number
    reason?: string | null
    status?: $Enums.OvertimeStatus
    approvedByUserId?: string | null
    approvedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeCreateOrConnectWithoutCompanyInput = {
    where: OvertimeWhereUniqueInput
    create: XOR<OvertimeCreateWithoutCompanyInput, OvertimeUncheckedCreateWithoutCompanyInput>
  }

  export type OvertimeCreateManyCompanyInputEnvelope = {
    data: OvertimeCreateManyCompanyInput | OvertimeCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceSummaryCreateWithoutCompanyInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    totalHours: number
    overtimeHours: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrolls?: PayrollCreateNestedManyWithoutAttendanceSummaryInput
  }

  export type AttendanceSummaryUncheckedCreateWithoutCompanyInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    totalHours: number
    overtimeHours: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrolls?: PayrollUncheckedCreateNestedManyWithoutAttendanceSummaryInput
  }

  export type AttendanceSummaryCreateOrConnectWithoutCompanyInput = {
    where: AttendanceSummaryWhereUniqueInput
    create: XOR<AttendanceSummaryCreateWithoutCompanyInput, AttendanceSummaryUncheckedCreateWithoutCompanyInput>
  }

  export type AttendanceSummaryCreateManyCompanyInputEnvelope = {
    data: AttendanceSummaryCreateManyCompanyInput | AttendanceSummaryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PayrollCreateWithoutCompanyInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    grossPay: number
    netPay: number
    status?: $Enums.PayrollStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendanceSummary: AttendanceSummaryCreateNestedOneWithoutPayrollsInput
    exports?: PayrollExportCreateNestedManyWithoutPayrollInput
  }

  export type PayrollUncheckedCreateWithoutCompanyInput = {
    id?: string
    attendanceSummaryId: string
    periodStart: Date | string
    periodEnd: Date | string
    grossPay: number
    netPay: number
    status?: $Enums.PayrollStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exports?: PayrollExportUncheckedCreateNestedManyWithoutPayrollInput
  }

  export type PayrollCreateOrConnectWithoutCompanyInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutCompanyInput, PayrollUncheckedCreateWithoutCompanyInput>
  }

  export type PayrollCreateManyCompanyInputEnvelope = {
    data: PayrollCreateManyCompanyInput | PayrollCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PayrollPeriodCreateWithoutCompanyInput = {
    id?: string
    month: number
    year: number
    isClosed?: boolean
    closedAt?: Date | string | null
    deletedAt?: Date | string | null
    closedBy?: UserCreateNestedOneWithoutPayrollPeriodClosuresInput
    lines?: PayrollLineCreateNestedManyWithoutPayrollPeriodInput
  }

  export type PayrollPeriodUncheckedCreateWithoutCompanyInput = {
    id?: string
    month: number
    year: number
    isClosed?: boolean
    closedAt?: Date | string | null
    closedByUserId?: string | null
    deletedAt?: Date | string | null
    lines?: PayrollLineUncheckedCreateNestedManyWithoutPayrollPeriodInput
  }

  export type PayrollPeriodCreateOrConnectWithoutCompanyInput = {
    where: PayrollPeriodWhereUniqueInput
    create: XOR<PayrollPeriodCreateWithoutCompanyInput, PayrollPeriodUncheckedCreateWithoutCompanyInput>
  }

  export type PayrollPeriodCreateManyCompanyInputEnvelope = {
    data: PayrollPeriodCreateManyCompanyInput | PayrollPeriodCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PayrollLineCreateWithoutCompanyInput = {
    id?: string
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
    payrollPeriod: PayrollPeriodCreateNestedOneWithoutLinesInput
    employee: EmployeeCreateNestedOneWithoutPayrollLinesInput
  }

  export type PayrollLineUncheckedCreateWithoutCompanyInput = {
    id?: string
    payrollPeriodId: string
    employeeId: string
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PayrollLineCreateOrConnectWithoutCompanyInput = {
    where: PayrollLineWhereUniqueInput
    create: XOR<PayrollLineCreateWithoutCompanyInput, PayrollLineUncheckedCreateWithoutCompanyInput>
  }

  export type PayrollLineCreateManyCompanyInputEnvelope = {
    data: PayrollLineCreateManyCompanyInput | PayrollLineCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutCompanyInput = {
    id?: string
    salaryType: $Enums.SalaryType
    baseSalary: number
    hourlyRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutContractsInput
  }

  export type ContractUncheckedCreateWithoutCompanyInput = {
    id?: string
    employeeId: string
    salaryType: $Enums.SalaryType
    baseSalary: number
    hourlyRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ContractCreateOrConnectWithoutCompanyInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutCompanyInput, ContractUncheckedCreateWithoutCompanyInput>
  }

  export type ContractCreateManyCompanyInputEnvelope = {
    data: ContractCreateManyCompanyInput | ContractCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PayrollExportCreateWithoutCompanyInput = {
    id?: string
    format: $Enums.ExportFormat
    path: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payroll: PayrollCreateNestedOneWithoutExportsInput
  }

  export type PayrollExportUncheckedCreateWithoutCompanyInput = {
    id?: string
    payrollId: string
    format: $Enums.ExportFormat
    path: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollExportCreateOrConnectWithoutCompanyInput = {
    where: PayrollExportWhereUniqueInput
    create: XOR<PayrollExportCreateWithoutCompanyInput, PayrollExportUncheckedCreateWithoutCompanyInput>
  }

  export type PayrollExportCreateManyCompanyInputEnvelope = {
    data: PayrollExportCreateManyCompanyInput | PayrollExportCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutCompanyInput = {
    id?: string
    type: $Enums.ReportType
    periodStart: Date | string
    periodEnd: Date | string
    data: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUncheckedCreateWithoutCompanyInput = {
    id?: string
    type: $Enums.ReportType
    periodStart: Date | string
    periodEnd: Date | string
    data: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutCompanyInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput>
  }

  export type ReportCreateManyCompanyInputEnvelope = {
    data: ReportCreateManyCompanyInput | ReportCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type SchoolClassCreateWithoutCompanyInput = {
    id?: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
  }

  export type SchoolClassUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
  }

  export type SchoolClassCreateOrConnectWithoutCompanyInput = {
    where: SchoolClassWhereUniqueInput
    create: XOR<SchoolClassCreateWithoutCompanyInput, SchoolClassUncheckedCreateWithoutCompanyInput>
  }

  export type SchoolClassCreateManyCompanyInputEnvelope = {
    data: SchoolClassCreateManyCompanyInput | SchoolClassCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutCompanyInput = {
    id?: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class: SchoolClassCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutCompanyInput = {
    id?: string
    classId: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreateOrConnectWithoutCompanyInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCompanyInput, CourseUncheckedCreateWithoutCompanyInput>
  }

  export type CourseCreateManyCompanyInputEnvelope = {
    data: CourseCreateManyCompanyInput | CourseCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutCompanyInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class: SchoolClassCreateNestedOneWithoutStudentsInput
    person?: PersonCreateNestedOneWithoutStudentInput
    attendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutStudentInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCompanyInput = {
    id?: string
    classId: string
    firstName: string
    lastName: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutStudentInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCompanyInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCompanyInput, StudentUncheckedCreateWithoutCompanyInput>
  }

  export type StudentCreateManyCompanyInputEnvelope = {
    data: StudentCreateManyCompanyInput | StudentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type StudentAttendanceCreateWithoutCompanyInput = {
    id?: string
    date: Date | string
    status: $Enums.StudentAttendanceStatus
    note?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendanceInput
    recordedBy?: UserCreateNestedOneWithoutStudentAttendanceRecordsInput
  }

  export type StudentAttendanceUncheckedCreateWithoutCompanyInput = {
    id?: string
    studentId: string
    date: Date | string
    status: $Enums.StudentAttendanceStatus
    note?: string | null
    recordedByUserId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateOrConnectWithoutCompanyInput = {
    where: StudentAttendanceWhereUniqueInput
    create: XOR<StudentAttendanceCreateWithoutCompanyInput, StudentAttendanceUncheckedCreateWithoutCompanyInput>
  }

  export type StudentAttendanceCreateManyCompanyInputEnvelope = {
    data: StudentAttendanceCreateManyCompanyInput | StudentAttendanceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type LeaveTypeCreateWithoutCompanyInput = {
    id?: string
    name: string
    code: string
    isPaid: boolean
    maxDaysYear?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    balances?: LeaveBalanceCreateNestedManyWithoutLeaveTypeInput
    requests?: LeaveRequestCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    code: string
    isPaid: boolean
    maxDaysYear?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    balances?: LeaveBalanceUncheckedCreateNestedManyWithoutLeaveTypeInput
    requests?: LeaveRequestUncheckedCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeCreateOrConnectWithoutCompanyInput = {
    where: LeaveTypeWhereUniqueInput
    create: XOR<LeaveTypeCreateWithoutCompanyInput, LeaveTypeUncheckedCreateWithoutCompanyInput>
  }

  export type LeaveTypeCreateManyCompanyInputEnvelope = {
    data: LeaveTypeCreateManyCompanyInput | LeaveTypeCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type LeaveBalanceCreateWithoutCompanyInput = {
    id?: string
    year: number
    totalDays: number
    usedDays?: number
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutLeaveBalancesInput
    leaveType: LeaveTypeCreateNestedOneWithoutBalancesInput
  }

  export type LeaveBalanceUncheckedCreateWithoutCompanyInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    year: number
    totalDays: number
    usedDays?: number
    deletedAt?: Date | string | null
  }

  export type LeaveBalanceCreateOrConnectWithoutCompanyInput = {
    where: LeaveBalanceWhereUniqueInput
    create: XOR<LeaveBalanceCreateWithoutCompanyInput, LeaveBalanceUncheckedCreateWithoutCompanyInput>
  }

  export type LeaveBalanceCreateManyCompanyInputEnvelope = {
    data: LeaveBalanceCreateManyCompanyInput | LeaveBalanceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutCompanyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    deletedAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutLeaveRequestsInput
    leaveType: LeaveTypeCreateNestedOneWithoutRequestsInput
    validatedBy?: UserCreateNestedOneWithoutLeaveValidationsInput
  }

  export type LeaveRequestUncheckedCreateWithoutCompanyInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    validatedByUserId?: string | null
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateOrConnectWithoutCompanyInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutCompanyInput, LeaveRequestUncheckedCreateWithoutCompanyInput>
  }

  export type LeaveRequestCreateManyCompanyInputEnvelope = {
    data: LeaveRequestCreateManyCompanyInput | LeaveRequestCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PublicHolidayCreateWithoutCompanyInput = {
    id?: string
    date: Date | string
    name: string
    country: string
    deletedAt?: Date | string | null
  }

  export type PublicHolidayUncheckedCreateWithoutCompanyInput = {
    id?: string
    date: Date | string
    name: string
    country: string
    deletedAt?: Date | string | null
  }

  export type PublicHolidayCreateOrConnectWithoutCompanyInput = {
    where: PublicHolidayWhereUniqueInput
    create: XOR<PublicHolidayCreateWithoutCompanyInput, PublicHolidayUncheckedCreateWithoutCompanyInput>
  }

  export type PublicHolidayCreateManyCompanyInputEnvelope = {
    data: PublicHolidayCreateManyCompanyInput | PublicHolidayCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ConstructionSiteCreateWithoutCompanyInput = {
    id?: string
    name: string
    location?: string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: ConstructionTeamCreateNestedManyWithoutSiteInput
    attendance?: SiteAttendanceCreateNestedManyWithoutSiteInput
  }

  export type ConstructionSiteUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    location?: string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: ConstructionTeamUncheckedCreateNestedManyWithoutSiteInput
    attendance?: SiteAttendanceUncheckedCreateNestedManyWithoutSiteInput
  }

  export type ConstructionSiteCreateOrConnectWithoutCompanyInput = {
    where: ConstructionSiteWhereUniqueInput
    create: XOR<ConstructionSiteCreateWithoutCompanyInput, ConstructionSiteUncheckedCreateWithoutCompanyInput>
  }

  export type ConstructionSiteCreateManyCompanyInputEnvelope = {
    data: ConstructionSiteCreateManyCompanyInput | ConstructionSiteCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ConstructionTeamCreateWithoutCompanyInput = {
    id?: string
    name: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site: ConstructionSiteCreateNestedOneWithoutTeamsInput
    workers?: ConstructionWorkerCreateNestedManyWithoutTeamInput
  }

  export type ConstructionTeamUncheckedCreateWithoutCompanyInput = {
    id?: string
    siteId: string
    name: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workers?: ConstructionWorkerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type ConstructionTeamCreateOrConnectWithoutCompanyInput = {
    where: ConstructionTeamWhereUniqueInput
    create: XOR<ConstructionTeamCreateWithoutCompanyInput, ConstructionTeamUncheckedCreateWithoutCompanyInput>
  }

  export type ConstructionTeamCreateManyCompanyInputEnvelope = {
    data: ConstructionTeamCreateManyCompanyInput | ConstructionTeamCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ConstructionWorkerCreateWithoutCompanyInput = {
    id?: string
    name: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team: ConstructionTeamCreateNestedOneWithoutWorkersInput
    person?: PersonCreateNestedOneWithoutConstructionWorkerInput
    attendance?: SiteAttendanceCreateNestedManyWithoutWorkerInput
  }

  export type ConstructionWorkerUncheckedCreateWithoutCompanyInput = {
    id?: string
    teamId: string
    name: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: SiteAttendanceUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type ConstructionWorkerCreateOrConnectWithoutCompanyInput = {
    where: ConstructionWorkerWhereUniqueInput
    create: XOR<ConstructionWorkerCreateWithoutCompanyInput, ConstructionWorkerUncheckedCreateWithoutCompanyInput>
  }

  export type ConstructionWorkerCreateManyCompanyInputEnvelope = {
    data: ConstructionWorkerCreateManyCompanyInput | ConstructionWorkerCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type SiteAttendanceCreateWithoutCompanyInput = {
    id?: string
    date: Date | string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    site: ConstructionSiteCreateNestedOneWithoutAttendanceInput
    worker: ConstructionWorkerCreateNestedOneWithoutAttendanceInput
  }

  export type SiteAttendanceUncheckedCreateWithoutCompanyInput = {
    id?: string
    siteId: string
    workerId: string
    date: Date | string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteAttendanceCreateOrConnectWithoutCompanyInput = {
    where: SiteAttendanceWhereUniqueInput
    create: XOR<SiteAttendanceCreateWithoutCompanyInput, SiteAttendanceUncheckedCreateWithoutCompanyInput>
  }

  export type SiteAttendanceCreateManyCompanyInputEnvelope = {
    data: SiteAttendanceCreateManyCompanyInput | SiteAttendanceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutCompanyInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    actionType?: $Enums.AuditAction | null
    entityType?: $Enums.AuditEntity | null
    ip?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutCompanyInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    actionType?: $Enums.AuditAction | null
    entityType?: $Enums.AuditEntity | null
    ip?: string | null
    userId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogCreateManyCompanyInputEnvelope = {
    data: AuditLogCreateManyCompanyInput | AuditLogCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutCompanyInput = {
    id?: string
    role: $Enums.Role
    deletedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutCompanyInput = {
    id?: string
    role: $Enums.Role
    userId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutCompanyInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutCompanyInput, UserRoleUncheckedCreateWithoutCompanyInput>
  }

  export type UserRoleCreateManyCompanyInputEnvelope = {
    data: UserRoleCreateManyCompanyInput | UserRoleCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DeviceCreateWithoutCompanyInput = {
    id?: string
    uuid: string
    platform: string
    model: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    person: PersonCreateNestedOneWithoutDevicesInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutCompanyInput = {
    id?: string
    uuid: string
    platform: string
    model: string
    personId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutCompanyInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutCompanyInput, DeviceUncheckedCreateWithoutCompanyInput>
  }

  export type DeviceCreateManyCompanyInputEnvelope = {
    data: DeviceCreateManyCompanyInput | DeviceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PeriodClosureCreateWithoutCompanyInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    closedAt?: Date | string
  }

  export type PeriodClosureUncheckedCreateWithoutCompanyInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    closedAt?: Date | string
  }

  export type PeriodClosureCreateOrConnectWithoutCompanyInput = {
    where: PeriodClosureWhereUniqueInput
    create: XOR<PeriodClosureCreateWithoutCompanyInput, PeriodClosureUncheckedCreateWithoutCompanyInput>
  }

  export type PeriodClosureCreateManyCompanyInputEnvelope = {
    data: PeriodClosureCreateManyCompanyInput | PeriodClosureCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    roles?: EnumRoleNullableListFilter<"User">
    isActive?: BoolFilter<"User"> | boolean
    companyId?: StringFilter<"User"> | string
    personId?: StringNullableFilter<"User"> | string | null
    refreshTokenHash?: StringNullableFilter<"User"> | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type PersonUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PersonWhereUniqueInput
    update: XOR<PersonUpdateWithoutCompanyInput, PersonUncheckedUpdateWithoutCompanyInput>
    create: XOR<PersonCreateWithoutCompanyInput, PersonUncheckedCreateWithoutCompanyInput>
  }

  export type PersonUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PersonWhereUniqueInput
    data: XOR<PersonUpdateWithoutCompanyInput, PersonUncheckedUpdateWithoutCompanyInput>
  }

  export type PersonUpdateManyWithWhereWithoutCompanyInput = {
    where: PersonScalarWhereInput
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PersonScalarWhereInput = {
    AND?: PersonScalarWhereInput | PersonScalarWhereInput[]
    OR?: PersonScalarWhereInput[]
    NOT?: PersonScalarWhereInput | PersonScalarWhereInput[]
    id?: StringFilter<"Person"> | string
    firstName?: StringFilter<"Person"> | string
    lastName?: StringFilter<"Person"> | string
    phone?: StringNullableFilter<"Person"> | string | null
    companyId?: StringFilter<"Person"> | string
    createdAt?: DateTimeFilter<"Person"> | Date | string
    updatedAt?: DateTimeFilter<"Person"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Person"> | Date | string | null
  }

  export type EmployeeUpsertWithWhereUniqueWithoutCompanyInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutCompanyInput, EmployeeUncheckedUpdateWithoutCompanyInput>
    create: XOR<EmployeeCreateWithoutCompanyInput, EmployeeUncheckedCreateWithoutCompanyInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutCompanyInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutCompanyInput, EmployeeUncheckedUpdateWithoutCompanyInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutCompanyInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutCompanyInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    companyId?: StringFilter<"Employee"> | string
    personId?: StringFilter<"Employee"> | string
    userId?: StringNullableFilter<"Employee"> | string | null
    scheduleId?: StringNullableFilter<"Employee"> | string | null
    matricule?: StringNullableFilter<"Employee"> | string | null
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
  }

  export type WorkerUpsertWithWhereUniqueWithoutCompanyInput = {
    where: WorkerWhereUniqueInput
    update: XOR<WorkerUpdateWithoutCompanyInput, WorkerUncheckedUpdateWithoutCompanyInput>
    create: XOR<WorkerCreateWithoutCompanyInput, WorkerUncheckedCreateWithoutCompanyInput>
  }

  export type WorkerUpdateWithWhereUniqueWithoutCompanyInput = {
    where: WorkerWhereUniqueInput
    data: XOR<WorkerUpdateWithoutCompanyInput, WorkerUncheckedUpdateWithoutCompanyInput>
  }

  export type WorkerUpdateManyWithWhereWithoutCompanyInput = {
    where: WorkerScalarWhereInput
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyWithoutCompanyInput>
  }

  export type WorkerScalarWhereInput = {
    AND?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
    OR?: WorkerScalarWhereInput[]
    NOT?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
    id?: StringFilter<"Worker"> | string
    companyId?: StringFilter<"Worker"> | string
    personId?: StringFilter<"Worker"> | string
    deletedAt?: DateTimeNullableFilter<"Worker"> | Date | string | null
    createdAt?: DateTimeFilter<"Worker"> | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutCompanyInput, AttendanceUncheckedUpdateWithoutCompanyInput>
    create: XOR<AttendanceCreateWithoutCompanyInput, AttendanceUncheckedCreateWithoutCompanyInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutCompanyInput, AttendanceUncheckedUpdateWithoutCompanyInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutCompanyInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    userId?: StringFilter<"Attendance"> | string
    companyId?: StringFilter<"Attendance"> | string
    checkInAt?: DateTimeFilter<"Attendance"> | Date | string
    checkOutAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type AttendanceEventUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AttendanceEventWhereUniqueInput
    update: XOR<AttendanceEventUpdateWithoutCompanyInput, AttendanceEventUncheckedUpdateWithoutCompanyInput>
    create: XOR<AttendanceEventCreateWithoutCompanyInput, AttendanceEventUncheckedCreateWithoutCompanyInput>
  }

  export type AttendanceEventUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AttendanceEventWhereUniqueInput
    data: XOR<AttendanceEventUpdateWithoutCompanyInput, AttendanceEventUncheckedUpdateWithoutCompanyInput>
  }

  export type AttendanceEventUpdateManyWithWhereWithoutCompanyInput = {
    where: AttendanceEventScalarWhereInput
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AttendanceEventScalarWhereInput = {
    AND?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
    OR?: AttendanceEventScalarWhereInput[]
    NOT?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
    id?: StringFilter<"AttendanceEvent"> | string
    companyId?: StringFilter<"AttendanceEvent"> | string
    type?: EnumAttendanceTypeFilter<"AttendanceEvent"> | $Enums.AttendanceType
    timestamp?: DateTimeFilter<"AttendanceEvent"> | Date | string
    date?: DateTimeFilter<"AttendanceEvent"> | Date | string
    personType?: EnumPersonTypeFilter<"AttendanceEvent"> | $Enums.PersonType
    employeeId?: StringNullableFilter<"AttendanceEvent"> | string | null
    studentId?: StringNullableFilter<"AttendanceEvent"> | string | null
    workerId?: StringNullableFilter<"AttendanceEvent"> | string | null
    deviceId?: StringNullableFilter<"AttendanceEvent"> | string | null
    createdAt?: DateTimeFilter<"AttendanceEvent"> | Date | string
    deletedAt?: DateTimeNullableFilter<"AttendanceEvent"> | Date | string | null
  }

  export type AttendanceDailySummaryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    update: XOR<AttendanceDailySummaryUpdateWithoutCompanyInput, AttendanceDailySummaryUncheckedUpdateWithoutCompanyInput>
    create: XOR<AttendanceDailySummaryCreateWithoutCompanyInput, AttendanceDailySummaryUncheckedCreateWithoutCompanyInput>
  }

  export type AttendanceDailySummaryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    data: XOR<AttendanceDailySummaryUpdateWithoutCompanyInput, AttendanceDailySummaryUncheckedUpdateWithoutCompanyInput>
  }

  export type AttendanceDailySummaryUpdateManyWithWhereWithoutCompanyInput = {
    where: AttendanceDailySummaryScalarWhereInput
    data: XOR<AttendanceDailySummaryUpdateManyMutationInput, AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AttendanceDailySummaryScalarWhereInput = {
    AND?: AttendanceDailySummaryScalarWhereInput | AttendanceDailySummaryScalarWhereInput[]
    OR?: AttendanceDailySummaryScalarWhereInput[]
    NOT?: AttendanceDailySummaryScalarWhereInput | AttendanceDailySummaryScalarWhereInput[]
    id?: StringFilter<"AttendanceDailySummary"> | string
    companyId?: StringFilter<"AttendanceDailySummary"> | string
    date?: DateTimeFilter<"AttendanceDailySummary"> | Date | string
    status?: EnumAttendanceStatusFilter<"AttendanceDailySummary"> | $Enums.AttendanceStatus
    lateMinutes?: IntNullableFilter<"AttendanceDailySummary"> | number | null
    earlyMinutes?: IntNullableFilter<"AttendanceDailySummary"> | number | null
    workedMinutes?: IntNullableFilter<"AttendanceDailySummary"> | number | null
    employeeId?: StringNullableFilter<"AttendanceDailySummary"> | string | null
    studentId?: StringNullableFilter<"AttendanceDailySummary"> | string | null
    workerId?: StringNullableFilter<"AttendanceDailySummary"> | string | null
    validatedByUserId?: StringNullableFilter<"AttendanceDailySummary"> | string | null
    createdAt?: DateTimeFilter<"AttendanceDailySummary"> | Date | string
    deletedAt?: DateTimeNullableFilter<"AttendanceDailySummary"> | Date | string | null
  }

  export type ScheduleUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutCompanyInput, ScheduleUncheckedUpdateWithoutCompanyInput>
    create: XOR<ScheduleCreateWithoutCompanyInput, ScheduleUncheckedCreateWithoutCompanyInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutCompanyInput, ScheduleUncheckedUpdateWithoutCompanyInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutCompanyInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: StringFilter<"Schedule"> | string
    companyId?: StringFilter<"Schedule"> | string
    name?: StringFilter<"Schedule"> | string
    startTime?: StringFilter<"Schedule"> | string
    endTime?: StringFilter<"Schedule"> | string
    daysOfWeek?: StringNullableListFilter<"Schedule">
    deletedAt?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
  }

  export type OvertimeUpsertWithWhereUniqueWithoutCompanyInput = {
    where: OvertimeWhereUniqueInput
    update: XOR<OvertimeUpdateWithoutCompanyInput, OvertimeUncheckedUpdateWithoutCompanyInput>
    create: XOR<OvertimeCreateWithoutCompanyInput, OvertimeUncheckedCreateWithoutCompanyInput>
  }

  export type OvertimeUpdateWithWhereUniqueWithoutCompanyInput = {
    where: OvertimeWhereUniqueInput
    data: XOR<OvertimeUpdateWithoutCompanyInput, OvertimeUncheckedUpdateWithoutCompanyInput>
  }

  export type OvertimeUpdateManyWithWhereWithoutCompanyInput = {
    where: OvertimeScalarWhereInput
    data: XOR<OvertimeUpdateManyMutationInput, OvertimeUncheckedUpdateManyWithoutCompanyInput>
  }

  export type OvertimeScalarWhereInput = {
    AND?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
    OR?: OvertimeScalarWhereInput[]
    NOT?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
    id?: StringFilter<"Overtime"> | string
    companyId?: StringFilter<"Overtime"> | string
    userId?: StringFilter<"Overtime"> | string
    date?: DateTimeFilter<"Overtime"> | Date | string
    hours?: FloatFilter<"Overtime"> | number
    reason?: StringNullableFilter<"Overtime"> | string | null
    status?: EnumOvertimeStatusFilter<"Overtime"> | $Enums.OvertimeStatus
    approvedByUserId?: StringNullableFilter<"Overtime"> | string | null
    approvedAt?: DateTimeNullableFilter<"Overtime"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Overtime"> | Date | string | null
    createdAt?: DateTimeFilter<"Overtime"> | Date | string
    updatedAt?: DateTimeFilter<"Overtime"> | Date | string
  }

  export type AttendanceSummaryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AttendanceSummaryWhereUniqueInput
    update: XOR<AttendanceSummaryUpdateWithoutCompanyInput, AttendanceSummaryUncheckedUpdateWithoutCompanyInput>
    create: XOR<AttendanceSummaryCreateWithoutCompanyInput, AttendanceSummaryUncheckedCreateWithoutCompanyInput>
  }

  export type AttendanceSummaryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AttendanceSummaryWhereUniqueInput
    data: XOR<AttendanceSummaryUpdateWithoutCompanyInput, AttendanceSummaryUncheckedUpdateWithoutCompanyInput>
  }

  export type AttendanceSummaryUpdateManyWithWhereWithoutCompanyInput = {
    where: AttendanceSummaryScalarWhereInput
    data: XOR<AttendanceSummaryUpdateManyMutationInput, AttendanceSummaryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AttendanceSummaryScalarWhereInput = {
    AND?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
    OR?: AttendanceSummaryScalarWhereInput[]
    NOT?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
    id?: StringFilter<"AttendanceSummary"> | string
    companyId?: StringFilter<"AttendanceSummary"> | string
    periodStart?: DateTimeFilter<"AttendanceSummary"> | Date | string
    periodEnd?: DateTimeFilter<"AttendanceSummary"> | Date | string
    totalHours?: FloatFilter<"AttendanceSummary"> | number
    overtimeHours?: FloatFilter<"AttendanceSummary"> | number
    deletedAt?: DateTimeNullableFilter<"AttendanceSummary"> | Date | string | null
    createdAt?: DateTimeFilter<"AttendanceSummary"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceSummary"> | Date | string
  }

  export type PayrollUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PayrollWhereUniqueInput
    update: XOR<PayrollUpdateWithoutCompanyInput, PayrollUncheckedUpdateWithoutCompanyInput>
    create: XOR<PayrollCreateWithoutCompanyInput, PayrollUncheckedCreateWithoutCompanyInput>
  }

  export type PayrollUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PayrollWhereUniqueInput
    data: XOR<PayrollUpdateWithoutCompanyInput, PayrollUncheckedUpdateWithoutCompanyInput>
  }

  export type PayrollUpdateManyWithWhereWithoutCompanyInput = {
    where: PayrollScalarWhereInput
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PayrollScalarWhereInput = {
    AND?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    OR?: PayrollScalarWhereInput[]
    NOT?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    id?: StringFilter<"Payroll"> | string
    companyId?: StringFilter<"Payroll"> | string
    attendanceSummaryId?: StringFilter<"Payroll"> | string
    periodStart?: DateTimeFilter<"Payroll"> | Date | string
    periodEnd?: DateTimeFilter<"Payroll"> | Date | string
    grossPay?: FloatFilter<"Payroll"> | number
    netPay?: FloatFilter<"Payroll"> | number
    status?: EnumPayrollStatusFilter<"Payroll"> | $Enums.PayrollStatus
    deletedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
  }

  export type PayrollPeriodUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PayrollPeriodWhereUniqueInput
    update: XOR<PayrollPeriodUpdateWithoutCompanyInput, PayrollPeriodUncheckedUpdateWithoutCompanyInput>
    create: XOR<PayrollPeriodCreateWithoutCompanyInput, PayrollPeriodUncheckedCreateWithoutCompanyInput>
  }

  export type PayrollPeriodUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PayrollPeriodWhereUniqueInput
    data: XOR<PayrollPeriodUpdateWithoutCompanyInput, PayrollPeriodUncheckedUpdateWithoutCompanyInput>
  }

  export type PayrollPeriodUpdateManyWithWhereWithoutCompanyInput = {
    where: PayrollPeriodScalarWhereInput
    data: XOR<PayrollPeriodUpdateManyMutationInput, PayrollPeriodUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PayrollPeriodScalarWhereInput = {
    AND?: PayrollPeriodScalarWhereInput | PayrollPeriodScalarWhereInput[]
    OR?: PayrollPeriodScalarWhereInput[]
    NOT?: PayrollPeriodScalarWhereInput | PayrollPeriodScalarWhereInput[]
    id?: StringFilter<"PayrollPeriod"> | string
    month?: IntFilter<"PayrollPeriod"> | number
    year?: IntFilter<"PayrollPeriod"> | number
    companyId?: StringFilter<"PayrollPeriod"> | string
    isClosed?: BoolFilter<"PayrollPeriod"> | boolean
    closedAt?: DateTimeNullableFilter<"PayrollPeriod"> | Date | string | null
    closedByUserId?: StringNullableFilter<"PayrollPeriod"> | string | null
    deletedAt?: DateTimeNullableFilter<"PayrollPeriod"> | Date | string | null
  }

  export type PayrollLineUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PayrollLineWhereUniqueInput
    update: XOR<PayrollLineUpdateWithoutCompanyInput, PayrollLineUncheckedUpdateWithoutCompanyInput>
    create: XOR<PayrollLineCreateWithoutCompanyInput, PayrollLineUncheckedCreateWithoutCompanyInput>
  }

  export type PayrollLineUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PayrollLineWhereUniqueInput
    data: XOR<PayrollLineUpdateWithoutCompanyInput, PayrollLineUncheckedUpdateWithoutCompanyInput>
  }

  export type PayrollLineUpdateManyWithWhereWithoutCompanyInput = {
    where: PayrollLineScalarWhereInput
    data: XOR<PayrollLineUpdateManyMutationInput, PayrollLineUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PayrollLineScalarWhereInput = {
    AND?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
    OR?: PayrollLineScalarWhereInput[]
    NOT?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
    id?: StringFilter<"PayrollLine"> | string
    companyId?: StringFilter<"PayrollLine"> | string
    payrollPeriodId?: StringFilter<"PayrollLine"> | string
    employeeId?: StringFilter<"PayrollLine"> | string
    workedDays?: IntFilter<"PayrollLine"> | number
    absentDays?: IntFilter<"PayrollLine"> | number
    lateMinutes?: IntFilter<"PayrollLine"> | number
    overtimeHours?: FloatFilter<"PayrollLine"> | number
    grossSalary?: FloatFilter<"PayrollLine"> | number
    deductions?: FloatFilter<"PayrollLine"> | number
    netSalary?: FloatFilter<"PayrollLine"> | number
    deletedAt?: DateTimeNullableFilter<"PayrollLine"> | Date | string | null
    createdAt?: DateTimeFilter<"PayrollLine"> | Date | string
  }

  export type ContractUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutCompanyInput, ContractUncheckedUpdateWithoutCompanyInput>
    create: XOR<ContractCreateWithoutCompanyInput, ContractUncheckedCreateWithoutCompanyInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutCompanyInput, ContractUncheckedUpdateWithoutCompanyInput>
  }

  export type ContractUpdateManyWithWhereWithoutCompanyInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ContractScalarWhereInput = {
    AND?: ContractScalarWhereInput | ContractScalarWhereInput[]
    OR?: ContractScalarWhereInput[]
    NOT?: ContractScalarWhereInput | ContractScalarWhereInput[]
    id?: StringFilter<"Contract"> | string
    companyId?: StringFilter<"Contract"> | string
    employeeId?: StringFilter<"Contract"> | string
    salaryType?: EnumSalaryTypeFilter<"Contract"> | $Enums.SalaryType
    baseSalary?: FloatFilter<"Contract"> | number
    hourlyRate?: FloatNullableFilter<"Contract"> | number | null
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Contract"> | Date | string | null
  }

  export type PayrollExportUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PayrollExportWhereUniqueInput
    update: XOR<PayrollExportUpdateWithoutCompanyInput, PayrollExportUncheckedUpdateWithoutCompanyInput>
    create: XOR<PayrollExportCreateWithoutCompanyInput, PayrollExportUncheckedCreateWithoutCompanyInput>
  }

  export type PayrollExportUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PayrollExportWhereUniqueInput
    data: XOR<PayrollExportUpdateWithoutCompanyInput, PayrollExportUncheckedUpdateWithoutCompanyInput>
  }

  export type PayrollExportUpdateManyWithWhereWithoutCompanyInput = {
    where: PayrollExportScalarWhereInput
    data: XOR<PayrollExportUpdateManyMutationInput, PayrollExportUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PayrollExportScalarWhereInput = {
    AND?: PayrollExportScalarWhereInput | PayrollExportScalarWhereInput[]
    OR?: PayrollExportScalarWhereInput[]
    NOT?: PayrollExportScalarWhereInput | PayrollExportScalarWhereInput[]
    id?: StringFilter<"PayrollExport"> | string
    companyId?: StringFilter<"PayrollExport"> | string
    payrollId?: StringFilter<"PayrollExport"> | string
    format?: EnumExportFormatFilter<"PayrollExport"> | $Enums.ExportFormat
    path?: StringFilter<"PayrollExport"> | string
    deletedAt?: DateTimeNullableFilter<"PayrollExport"> | Date | string | null
    createdAt?: DateTimeFilter<"PayrollExport"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollExport"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutCompanyInput, ReportUncheckedUpdateWithoutCompanyInput>
    create: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutCompanyInput, ReportUncheckedUpdateWithoutCompanyInput>
  }

  export type ReportUpdateManyWithWhereWithoutCompanyInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    companyId?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    periodStart?: DateTimeFilter<"Report"> | Date | string
    periodEnd?: DateTimeFilter<"Report"> | Date | string
    data?: JsonFilter<"Report">
    deletedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type SchoolClassUpsertWithWhereUniqueWithoutCompanyInput = {
    where: SchoolClassWhereUniqueInput
    update: XOR<SchoolClassUpdateWithoutCompanyInput, SchoolClassUncheckedUpdateWithoutCompanyInput>
    create: XOR<SchoolClassCreateWithoutCompanyInput, SchoolClassUncheckedCreateWithoutCompanyInput>
  }

  export type SchoolClassUpdateWithWhereUniqueWithoutCompanyInput = {
    where: SchoolClassWhereUniqueInput
    data: XOR<SchoolClassUpdateWithoutCompanyInput, SchoolClassUncheckedUpdateWithoutCompanyInput>
  }

  export type SchoolClassUpdateManyWithWhereWithoutCompanyInput = {
    where: SchoolClassScalarWhereInput
    data: XOR<SchoolClassUpdateManyMutationInput, SchoolClassUncheckedUpdateManyWithoutCompanyInput>
  }

  export type SchoolClassScalarWhereInput = {
    AND?: SchoolClassScalarWhereInput | SchoolClassScalarWhereInput[]
    OR?: SchoolClassScalarWhereInput[]
    NOT?: SchoolClassScalarWhereInput | SchoolClassScalarWhereInput[]
    id?: StringFilter<"SchoolClass"> | string
    companyId?: StringFilter<"SchoolClass"> | string
    name?: StringFilter<"SchoolClass"> | string
    code?: StringFilter<"SchoolClass"> | string
    deletedAt?: DateTimeNullableFilter<"SchoolClass"> | Date | string | null
    createdAt?: DateTimeFilter<"SchoolClass"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolClass"> | Date | string
  }

  export type CourseUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCompanyInput, CourseUncheckedUpdateWithoutCompanyInput>
    create: XOR<CourseCreateWithoutCompanyInput, CourseUncheckedCreateWithoutCompanyInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCompanyInput, CourseUncheckedUpdateWithoutCompanyInput>
  }

  export type CourseUpdateManyWithWhereWithoutCompanyInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: StringFilter<"Course"> | string
    companyId?: StringFilter<"Course"> | string
    classId?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    deletedAt?: DateTimeNullableFilter<"Course"> | Date | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
  }

  export type StudentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutCompanyInput, StudentUncheckedUpdateWithoutCompanyInput>
    create: XOR<StudentCreateWithoutCompanyInput, StudentUncheckedCreateWithoutCompanyInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutCompanyInput, StudentUncheckedUpdateWithoutCompanyInput>
  }

  export type StudentUpdateManyWithWhereWithoutCompanyInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    companyId?: StringFilter<"Student"> | string
    classId?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    email?: StringNullableFilter<"Student"> | string | null
    personId?: StringNullableFilter<"Student"> | string | null
    deletedAt?: DateTimeNullableFilter<"Student"> | Date | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type StudentAttendanceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: StudentAttendanceWhereUniqueInput
    update: XOR<StudentAttendanceUpdateWithoutCompanyInput, StudentAttendanceUncheckedUpdateWithoutCompanyInput>
    create: XOR<StudentAttendanceCreateWithoutCompanyInput, StudentAttendanceUncheckedCreateWithoutCompanyInput>
  }

  export type StudentAttendanceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: StudentAttendanceWhereUniqueInput
    data: XOR<StudentAttendanceUpdateWithoutCompanyInput, StudentAttendanceUncheckedUpdateWithoutCompanyInput>
  }

  export type StudentAttendanceUpdateManyWithWhereWithoutCompanyInput = {
    where: StudentAttendanceScalarWhereInput
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type StudentAttendanceScalarWhereInput = {
    AND?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
    OR?: StudentAttendanceScalarWhereInput[]
    NOT?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
    id?: StringFilter<"StudentAttendance"> | string
    companyId?: StringFilter<"StudentAttendance"> | string
    studentId?: StringFilter<"StudentAttendance"> | string
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: EnumStudentAttendanceStatusFilter<"StudentAttendance"> | $Enums.StudentAttendanceStatus
    note?: StringNullableFilter<"StudentAttendance"> | string | null
    recordedByUserId?: StringNullableFilter<"StudentAttendance"> | string | null
    deletedAt?: DateTimeNullableFilter<"StudentAttendance"> | Date | string | null
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAttendance"> | Date | string
  }

  export type LeaveTypeUpsertWithWhereUniqueWithoutCompanyInput = {
    where: LeaveTypeWhereUniqueInput
    update: XOR<LeaveTypeUpdateWithoutCompanyInput, LeaveTypeUncheckedUpdateWithoutCompanyInput>
    create: XOR<LeaveTypeCreateWithoutCompanyInput, LeaveTypeUncheckedCreateWithoutCompanyInput>
  }

  export type LeaveTypeUpdateWithWhereUniqueWithoutCompanyInput = {
    where: LeaveTypeWhereUniqueInput
    data: XOR<LeaveTypeUpdateWithoutCompanyInput, LeaveTypeUncheckedUpdateWithoutCompanyInput>
  }

  export type LeaveTypeUpdateManyWithWhereWithoutCompanyInput = {
    where: LeaveTypeScalarWhereInput
    data: XOR<LeaveTypeUpdateManyMutationInput, LeaveTypeUncheckedUpdateManyWithoutCompanyInput>
  }

  export type LeaveTypeScalarWhereInput = {
    AND?: LeaveTypeScalarWhereInput | LeaveTypeScalarWhereInput[]
    OR?: LeaveTypeScalarWhereInput[]
    NOT?: LeaveTypeScalarWhereInput | LeaveTypeScalarWhereInput[]
    id?: StringFilter<"LeaveType"> | string
    companyId?: StringFilter<"LeaveType"> | string
    name?: StringFilter<"LeaveType"> | string
    code?: StringFilter<"LeaveType"> | string
    isPaid?: BoolFilter<"LeaveType"> | boolean
    maxDaysYear?: IntNullableFilter<"LeaveType"> | number | null
    createdAt?: DateTimeFilter<"LeaveType"> | Date | string
    deletedAt?: DateTimeNullableFilter<"LeaveType"> | Date | string | null
  }

  export type LeaveBalanceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: LeaveBalanceWhereUniqueInput
    update: XOR<LeaveBalanceUpdateWithoutCompanyInput, LeaveBalanceUncheckedUpdateWithoutCompanyInput>
    create: XOR<LeaveBalanceCreateWithoutCompanyInput, LeaveBalanceUncheckedCreateWithoutCompanyInput>
  }

  export type LeaveBalanceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: LeaveBalanceWhereUniqueInput
    data: XOR<LeaveBalanceUpdateWithoutCompanyInput, LeaveBalanceUncheckedUpdateWithoutCompanyInput>
  }

  export type LeaveBalanceUpdateManyWithWhereWithoutCompanyInput = {
    where: LeaveBalanceScalarWhereInput
    data: XOR<LeaveBalanceUpdateManyMutationInput, LeaveBalanceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type LeaveBalanceScalarWhereInput = {
    AND?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
    OR?: LeaveBalanceScalarWhereInput[]
    NOT?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
    id?: StringFilter<"LeaveBalance"> | string
    companyId?: StringFilter<"LeaveBalance"> | string
    employeeId?: StringFilter<"LeaveBalance"> | string
    leaveTypeId?: StringFilter<"LeaveBalance"> | string
    year?: IntFilter<"LeaveBalance"> | number
    totalDays?: IntFilter<"LeaveBalance"> | number
    usedDays?: IntFilter<"LeaveBalance"> | number
    deletedAt?: DateTimeNullableFilter<"LeaveBalance"> | Date | string | null
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutCompanyInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutCompanyInput, LeaveRequestUncheckedUpdateWithoutCompanyInput>
    create: XOR<LeaveRequestCreateWithoutCompanyInput, LeaveRequestUncheckedCreateWithoutCompanyInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutCompanyInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutCompanyInput, LeaveRequestUncheckedUpdateWithoutCompanyInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutCompanyInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutCompanyInput>
  }

  export type LeaveRequestScalarWhereInput = {
    AND?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    OR?: LeaveRequestScalarWhereInput[]
    NOT?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    companyId?: StringFilter<"LeaveRequest"> | string
    employeeId?: StringFilter<"LeaveRequest"> | string
    leaveTypeId?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    days?: IntFilter<"LeaveRequest"> | number
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    requestedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    validatedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    validatedByUserId?: StringNullableFilter<"LeaveRequest"> | string | null
    deletedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
  }

  export type PublicHolidayUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PublicHolidayWhereUniqueInput
    update: XOR<PublicHolidayUpdateWithoutCompanyInput, PublicHolidayUncheckedUpdateWithoutCompanyInput>
    create: XOR<PublicHolidayCreateWithoutCompanyInput, PublicHolidayUncheckedCreateWithoutCompanyInput>
  }

  export type PublicHolidayUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PublicHolidayWhereUniqueInput
    data: XOR<PublicHolidayUpdateWithoutCompanyInput, PublicHolidayUncheckedUpdateWithoutCompanyInput>
  }

  export type PublicHolidayUpdateManyWithWhereWithoutCompanyInput = {
    where: PublicHolidayScalarWhereInput
    data: XOR<PublicHolidayUpdateManyMutationInput, PublicHolidayUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PublicHolidayScalarWhereInput = {
    AND?: PublicHolidayScalarWhereInput | PublicHolidayScalarWhereInput[]
    OR?: PublicHolidayScalarWhereInput[]
    NOT?: PublicHolidayScalarWhereInput | PublicHolidayScalarWhereInput[]
    id?: StringFilter<"PublicHoliday"> | string
    date?: DateTimeFilter<"PublicHoliday"> | Date | string
    name?: StringFilter<"PublicHoliday"> | string
    country?: StringFilter<"PublicHoliday"> | string
    companyId?: StringNullableFilter<"PublicHoliday"> | string | null
    deletedAt?: DateTimeNullableFilter<"PublicHoliday"> | Date | string | null
  }

  export type ConstructionSiteUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ConstructionSiteWhereUniqueInput
    update: XOR<ConstructionSiteUpdateWithoutCompanyInput, ConstructionSiteUncheckedUpdateWithoutCompanyInput>
    create: XOR<ConstructionSiteCreateWithoutCompanyInput, ConstructionSiteUncheckedCreateWithoutCompanyInput>
  }

  export type ConstructionSiteUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ConstructionSiteWhereUniqueInput
    data: XOR<ConstructionSiteUpdateWithoutCompanyInput, ConstructionSiteUncheckedUpdateWithoutCompanyInput>
  }

  export type ConstructionSiteUpdateManyWithWhereWithoutCompanyInput = {
    where: ConstructionSiteScalarWhereInput
    data: XOR<ConstructionSiteUpdateManyMutationInput, ConstructionSiteUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ConstructionSiteScalarWhereInput = {
    AND?: ConstructionSiteScalarWhereInput | ConstructionSiteScalarWhereInput[]
    OR?: ConstructionSiteScalarWhereInput[]
    NOT?: ConstructionSiteScalarWhereInput | ConstructionSiteScalarWhereInput[]
    id?: StringFilter<"ConstructionSite"> | string
    companyId?: StringFilter<"ConstructionSite"> | string
    name?: StringFilter<"ConstructionSite"> | string
    location?: StringNullableFilter<"ConstructionSite"> | string | null
    latitude?: FloatNullableFilter<"ConstructionSite"> | number | null
    longitude?: FloatNullableFilter<"ConstructionSite"> | number | null
    deletedAt?: DateTimeNullableFilter<"ConstructionSite"> | Date | string | null
    createdAt?: DateTimeFilter<"ConstructionSite"> | Date | string
    updatedAt?: DateTimeFilter<"ConstructionSite"> | Date | string
  }

  export type ConstructionTeamUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ConstructionTeamWhereUniqueInput
    update: XOR<ConstructionTeamUpdateWithoutCompanyInput, ConstructionTeamUncheckedUpdateWithoutCompanyInput>
    create: XOR<ConstructionTeamCreateWithoutCompanyInput, ConstructionTeamUncheckedCreateWithoutCompanyInput>
  }

  export type ConstructionTeamUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ConstructionTeamWhereUniqueInput
    data: XOR<ConstructionTeamUpdateWithoutCompanyInput, ConstructionTeamUncheckedUpdateWithoutCompanyInput>
  }

  export type ConstructionTeamUpdateManyWithWhereWithoutCompanyInput = {
    where: ConstructionTeamScalarWhereInput
    data: XOR<ConstructionTeamUpdateManyMutationInput, ConstructionTeamUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ConstructionTeamScalarWhereInput = {
    AND?: ConstructionTeamScalarWhereInput | ConstructionTeamScalarWhereInput[]
    OR?: ConstructionTeamScalarWhereInput[]
    NOT?: ConstructionTeamScalarWhereInput | ConstructionTeamScalarWhereInput[]
    id?: StringFilter<"ConstructionTeam"> | string
    companyId?: StringFilter<"ConstructionTeam"> | string
    siteId?: StringFilter<"ConstructionTeam"> | string
    name?: StringFilter<"ConstructionTeam"> | string
    deletedAt?: DateTimeNullableFilter<"ConstructionTeam"> | Date | string | null
    createdAt?: DateTimeFilter<"ConstructionTeam"> | Date | string
    updatedAt?: DateTimeFilter<"ConstructionTeam"> | Date | string
  }

  export type ConstructionWorkerUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ConstructionWorkerWhereUniqueInput
    update: XOR<ConstructionWorkerUpdateWithoutCompanyInput, ConstructionWorkerUncheckedUpdateWithoutCompanyInput>
    create: XOR<ConstructionWorkerCreateWithoutCompanyInput, ConstructionWorkerUncheckedCreateWithoutCompanyInput>
  }

  export type ConstructionWorkerUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ConstructionWorkerWhereUniqueInput
    data: XOR<ConstructionWorkerUpdateWithoutCompanyInput, ConstructionWorkerUncheckedUpdateWithoutCompanyInput>
  }

  export type ConstructionWorkerUpdateManyWithWhereWithoutCompanyInput = {
    where: ConstructionWorkerScalarWhereInput
    data: XOR<ConstructionWorkerUpdateManyMutationInput, ConstructionWorkerUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ConstructionWorkerScalarWhereInput = {
    AND?: ConstructionWorkerScalarWhereInput | ConstructionWorkerScalarWhereInput[]
    OR?: ConstructionWorkerScalarWhereInput[]
    NOT?: ConstructionWorkerScalarWhereInput | ConstructionWorkerScalarWhereInput[]
    id?: StringFilter<"ConstructionWorker"> | string
    companyId?: StringFilter<"ConstructionWorker"> | string
    teamId?: StringFilter<"ConstructionWorker"> | string
    name?: StringFilter<"ConstructionWorker"> | string
    email?: StringNullableFilter<"ConstructionWorker"> | string | null
    personId?: StringNullableFilter<"ConstructionWorker"> | string | null
    deletedAt?: DateTimeNullableFilter<"ConstructionWorker"> | Date | string | null
    createdAt?: DateTimeFilter<"ConstructionWorker"> | Date | string
    updatedAt?: DateTimeFilter<"ConstructionWorker"> | Date | string
  }

  export type SiteAttendanceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: SiteAttendanceWhereUniqueInput
    update: XOR<SiteAttendanceUpdateWithoutCompanyInput, SiteAttendanceUncheckedUpdateWithoutCompanyInput>
    create: XOR<SiteAttendanceCreateWithoutCompanyInput, SiteAttendanceUncheckedCreateWithoutCompanyInput>
  }

  export type SiteAttendanceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: SiteAttendanceWhereUniqueInput
    data: XOR<SiteAttendanceUpdateWithoutCompanyInput, SiteAttendanceUncheckedUpdateWithoutCompanyInput>
  }

  export type SiteAttendanceUpdateManyWithWhereWithoutCompanyInput = {
    where: SiteAttendanceScalarWhereInput
    data: XOR<SiteAttendanceUpdateManyMutationInput, SiteAttendanceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type SiteAttendanceScalarWhereInput = {
    AND?: SiteAttendanceScalarWhereInput | SiteAttendanceScalarWhereInput[]
    OR?: SiteAttendanceScalarWhereInput[]
    NOT?: SiteAttendanceScalarWhereInput | SiteAttendanceScalarWhereInput[]
    id?: StringFilter<"SiteAttendance"> | string
    companyId?: StringFilter<"SiteAttendance"> | string
    siteId?: StringFilter<"SiteAttendance"> | string
    workerId?: StringFilter<"SiteAttendance"> | string
    date?: DateTimeFilter<"SiteAttendance"> | Date | string
    checkInAt?: DateTimeFilter<"SiteAttendance"> | Date | string
    checkOutAt?: DateTimeNullableFilter<"SiteAttendance"> | Date | string | null
    latitude?: FloatNullableFilter<"SiteAttendance"> | number | null
    longitude?: FloatNullableFilter<"SiteAttendance"> | number | null
    deletedAt?: DateTimeNullableFilter<"SiteAttendance"> | Date | string | null
    createdAt?: DateTimeFilter<"SiteAttendance"> | Date | string
    updatedAt?: DateTimeFilter<"SiteAttendance"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
    create: XOR<AuditLogCreateWithoutCompanyInput, AuditLogUncheckedCreateWithoutCompanyInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutCompanyInput, AuditLogUncheckedUpdateWithoutCompanyInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutCompanyInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    companyId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    actionType?: EnumAuditActionNullableFilter<"AuditLog"> | $Enums.AuditAction | null
    entityType?: EnumAuditEntityNullableFilter<"AuditLog"> | $Enums.AuditEntity | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    data?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutCompanyInput, UserRoleUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserRoleCreateWithoutCompanyInput, UserRoleUncheckedCreateWithoutCompanyInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutCompanyInput, UserRoleUncheckedUpdateWithoutCompanyInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutCompanyInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: StringFilter<"UserRole"> | string
    companyId?: StringFilter<"UserRole"> | string
    role?: EnumRoleFilter<"UserRole"> | $Enums.Role
    userId?: StringFilter<"UserRole"> | string
    deletedAt?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
  }

  export type DeviceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutCompanyInput, DeviceUncheckedUpdateWithoutCompanyInput>
    create: XOR<DeviceCreateWithoutCompanyInput, DeviceUncheckedCreateWithoutCompanyInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutCompanyInput, DeviceUncheckedUpdateWithoutCompanyInput>
  }

  export type DeviceUpdateManyWithWhereWithoutCompanyInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DeviceScalarWhereInput = {
    AND?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    OR?: DeviceScalarWhereInput[]
    NOT?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    id?: StringFilter<"Device"> | string
    uuid?: StringFilter<"Device"> | string
    platform?: StringFilter<"Device"> | string
    model?: StringFilter<"Device"> | string
    personId?: StringFilter<"Device"> | string
    companyId?: StringFilter<"Device"> | string
    deletedAt?: DateTimeNullableFilter<"Device"> | Date | string | null
    createdAt?: DateTimeFilter<"Device"> | Date | string
  }

  export type PeriodClosureUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PeriodClosureWhereUniqueInput
    update: XOR<PeriodClosureUpdateWithoutCompanyInput, PeriodClosureUncheckedUpdateWithoutCompanyInput>
    create: XOR<PeriodClosureCreateWithoutCompanyInput, PeriodClosureUncheckedCreateWithoutCompanyInput>
  }

  export type PeriodClosureUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PeriodClosureWhereUniqueInput
    data: XOR<PeriodClosureUpdateWithoutCompanyInput, PeriodClosureUncheckedUpdateWithoutCompanyInput>
  }

  export type PeriodClosureUpdateManyWithWhereWithoutCompanyInput = {
    where: PeriodClosureScalarWhereInput
    data: XOR<PeriodClosureUpdateManyMutationInput, PeriodClosureUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PeriodClosureScalarWhereInput = {
    AND?: PeriodClosureScalarWhereInput | PeriodClosureScalarWhereInput[]
    OR?: PeriodClosureScalarWhereInput[]
    NOT?: PeriodClosureScalarWhereInput | PeriodClosureScalarWhereInput[]
    id?: StringFilter<"PeriodClosure"> | string
    companyId?: StringFilter<"PeriodClosure"> | string
    periodStart?: DateTimeFilter<"PeriodClosure"> | Date | string
    periodEnd?: DateTimeFilter<"PeriodClosure"> | Date | string
    closedAt?: DateTimeFilter<"PeriodClosure"> | Date | string
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type PersonCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPersonsInput
    employee?: EmployeeCreateNestedOneWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    worker?: WorkerCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerCreateNestedOneWithoutPersonInput
    devices?: DeviceCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    employee?: EmployeeUncheckedCreateNestedOneWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    worker?: WorkerUncheckedCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerUncheckedCreateNestedOneWithoutPersonInput
    devices?: DeviceUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutUserInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutUserInput, PersonUncheckedCreateWithoutUserInput>
  }

  export type EmployeeCreateWithoutUserInput = {
    id?: string
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutEmployeesInput
    person: PersonCreateNestedOneWithoutEmployeeInput
    schedule?: ScheduleCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineCreateNestedManyWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    personId: string
    scheduleId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateWithoutUserInput = {
    id?: string
    role: $Enums.Role
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    role: $Enums.Role
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutUserInput = {
    id?: string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceCreateManyUserInputEnvelope = {
    data: AttendanceCreateManyUserInput | AttendanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OvertimeCreateWithoutUserInput = {
    id?: string
    date: Date | string
    hours: number
    reason?: string | null
    status?: $Enums.OvertimeStatus
    approvedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutOvertimeInput
    approvedBy?: UserCreateNestedOneWithoutOvertimeApprovalsInput
  }

  export type OvertimeUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    date: Date | string
    hours: number
    reason?: string | null
    status?: $Enums.OvertimeStatus
    approvedByUserId?: string | null
    approvedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeCreateOrConnectWithoutUserInput = {
    where: OvertimeWhereUniqueInput
    create: XOR<OvertimeCreateWithoutUserInput, OvertimeUncheckedCreateWithoutUserInput>
  }

  export type OvertimeCreateManyUserInputEnvelope = {
    data: OvertimeCreateManyUserInput | OvertimeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OvertimeCreateWithoutApprovedByInput = {
    id?: string
    date: Date | string
    hours: number
    reason?: string | null
    status?: $Enums.OvertimeStatus
    approvedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutOvertimeInput
    user: UserCreateNestedOneWithoutOvertimeRequestsInput
  }

  export type OvertimeUncheckedCreateWithoutApprovedByInput = {
    id?: string
    companyId: string
    userId: string
    date: Date | string
    hours: number
    reason?: string | null
    status?: $Enums.OvertimeStatus
    approvedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeCreateOrConnectWithoutApprovedByInput = {
    where: OvertimeWhereUniqueInput
    create: XOR<OvertimeCreateWithoutApprovedByInput, OvertimeUncheckedCreateWithoutApprovedByInput>
  }

  export type OvertimeCreateManyApprovedByInputEnvelope = {
    data: OvertimeCreateManyApprovedByInput | OvertimeCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type StudentAttendanceCreateWithoutRecordedByInput = {
    id?: string
    date: Date | string
    status: $Enums.StudentAttendanceStatus
    note?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStudentAttendanceInput
    student: StudentCreateNestedOneWithoutAttendanceInput
  }

  export type StudentAttendanceUncheckedCreateWithoutRecordedByInput = {
    id?: string
    companyId: string
    studentId: string
    date: Date | string
    status: $Enums.StudentAttendanceStatus
    note?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateOrConnectWithoutRecordedByInput = {
    where: StudentAttendanceWhereUniqueInput
    create: XOR<StudentAttendanceCreateWithoutRecordedByInput, StudentAttendanceUncheckedCreateWithoutRecordedByInput>
  }

  export type StudentAttendanceCreateManyRecordedByInputEnvelope = {
    data: StudentAttendanceCreateManyRecordedByInput | StudentAttendanceCreateManyRecordedByInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceDailySummaryCreateWithoutValidatedByInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutAttendanceDailySummariesInput
    employee?: EmployeeCreateNestedOneWithoutDailySummariesInput
    student?: StudentCreateNestedOneWithoutDailySummariesInput
    worker?: WorkerCreateNestedOneWithoutDailySummariesInput
  }

  export type AttendanceDailySummaryUncheckedCreateWithoutValidatedByInput = {
    id?: string
    companyId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    employeeId?: string | null
    studentId?: string | null
    workerId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceDailySummaryCreateOrConnectWithoutValidatedByInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    create: XOR<AttendanceDailySummaryCreateWithoutValidatedByInput, AttendanceDailySummaryUncheckedCreateWithoutValidatedByInput>
  }

  export type AttendanceDailySummaryCreateManyValidatedByInputEnvelope = {
    data: AttendanceDailySummaryCreateManyValidatedByInput | AttendanceDailySummaryCreateManyValidatedByInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutValidatedByInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutLeaveRequestsInput
    employee: EmployeeCreateNestedOneWithoutLeaveRequestsInput
    leaveType: LeaveTypeCreateNestedOneWithoutRequestsInput
  }

  export type LeaveRequestUncheckedCreateWithoutValidatedByInput = {
    id?: string
    companyId: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateOrConnectWithoutValidatedByInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutValidatedByInput, LeaveRequestUncheckedCreateWithoutValidatedByInput>
  }

  export type LeaveRequestCreateManyValidatedByInputEnvelope = {
    data: LeaveRequestCreateManyValidatedByInput | LeaveRequestCreateManyValidatedByInput[]
    skipDuplicates?: boolean
  }

  export type PayrollPeriodCreateWithoutClosedByInput = {
    id?: string
    month: number
    year: number
    isClosed?: boolean
    closedAt?: Date | string | null
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPayrollPeriodsInput
    lines?: PayrollLineCreateNestedManyWithoutPayrollPeriodInput
  }

  export type PayrollPeriodUncheckedCreateWithoutClosedByInput = {
    id?: string
    month: number
    year: number
    companyId: string
    isClosed?: boolean
    closedAt?: Date | string | null
    deletedAt?: Date | string | null
    lines?: PayrollLineUncheckedCreateNestedManyWithoutPayrollPeriodInput
  }

  export type PayrollPeriodCreateOrConnectWithoutClosedByInput = {
    where: PayrollPeriodWhereUniqueInput
    create: XOR<PayrollPeriodCreateWithoutClosedByInput, PayrollPeriodUncheckedCreateWithoutClosedByInput>
  }

  export type PayrollPeriodCreateManyClosedByInputEnvelope = {
    data: PayrollPeriodCreateManyClosedByInput | PayrollPeriodCreateManyClosedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    actionType?: $Enums.AuditAction | null
    entityType?: $Enums.AuditEntity | null
    ip?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    action: string
    entity: string
    entityId: string
    actionType?: $Enums.AuditAction | null
    entityType?: $Enums.AuditEntity | null
    ip?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PersonUpsertWithoutUserInput = {
    update: XOR<PersonUpdateWithoutUserInput, PersonUncheckedUpdateWithoutUserInput>
    create: XOR<PersonCreateWithoutUserInput, PersonUncheckedCreateWithoutUserInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutUserInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutUserInput, PersonUncheckedUpdateWithoutUserInput>
  }

  export type PersonUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPersonsNestedInput
    employee?: EmployeeUpdateOneWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    worker?: WorkerUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUpdateOneWithoutPersonNestedInput
    devices?: DeviceUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUncheckedUpdateOneWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUncheckedUpdateOneWithoutPersonNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type EmployeeUpsertWithoutUserInput = {
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
    person?: PersonUpdateOneRequiredWithoutEmployeeNestedInput
    schedule?: ScheduleUpdateOneWithoutEmployeesNestedInput
    attendances?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutUserInput>
  }

  export type OvertimeUpsertWithWhereUniqueWithoutUserInput = {
    where: OvertimeWhereUniqueInput
    update: XOR<OvertimeUpdateWithoutUserInput, OvertimeUncheckedUpdateWithoutUserInput>
    create: XOR<OvertimeCreateWithoutUserInput, OvertimeUncheckedCreateWithoutUserInput>
  }

  export type OvertimeUpdateWithWhereUniqueWithoutUserInput = {
    where: OvertimeWhereUniqueInput
    data: XOR<OvertimeUpdateWithoutUserInput, OvertimeUncheckedUpdateWithoutUserInput>
  }

  export type OvertimeUpdateManyWithWhereWithoutUserInput = {
    where: OvertimeScalarWhereInput
    data: XOR<OvertimeUpdateManyMutationInput, OvertimeUncheckedUpdateManyWithoutUserInput>
  }

  export type OvertimeUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: OvertimeWhereUniqueInput
    update: XOR<OvertimeUpdateWithoutApprovedByInput, OvertimeUncheckedUpdateWithoutApprovedByInput>
    create: XOR<OvertimeCreateWithoutApprovedByInput, OvertimeUncheckedCreateWithoutApprovedByInput>
  }

  export type OvertimeUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: OvertimeWhereUniqueInput
    data: XOR<OvertimeUpdateWithoutApprovedByInput, OvertimeUncheckedUpdateWithoutApprovedByInput>
  }

  export type OvertimeUpdateManyWithWhereWithoutApprovedByInput = {
    where: OvertimeScalarWhereInput
    data: XOR<OvertimeUpdateManyMutationInput, OvertimeUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type StudentAttendanceUpsertWithWhereUniqueWithoutRecordedByInput = {
    where: StudentAttendanceWhereUniqueInput
    update: XOR<StudentAttendanceUpdateWithoutRecordedByInput, StudentAttendanceUncheckedUpdateWithoutRecordedByInput>
    create: XOR<StudentAttendanceCreateWithoutRecordedByInput, StudentAttendanceUncheckedCreateWithoutRecordedByInput>
  }

  export type StudentAttendanceUpdateWithWhereUniqueWithoutRecordedByInput = {
    where: StudentAttendanceWhereUniqueInput
    data: XOR<StudentAttendanceUpdateWithoutRecordedByInput, StudentAttendanceUncheckedUpdateWithoutRecordedByInput>
  }

  export type StudentAttendanceUpdateManyWithWhereWithoutRecordedByInput = {
    where: StudentAttendanceScalarWhereInput
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyWithoutRecordedByInput>
  }

  export type AttendanceDailySummaryUpsertWithWhereUniqueWithoutValidatedByInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    update: XOR<AttendanceDailySummaryUpdateWithoutValidatedByInput, AttendanceDailySummaryUncheckedUpdateWithoutValidatedByInput>
    create: XOR<AttendanceDailySummaryCreateWithoutValidatedByInput, AttendanceDailySummaryUncheckedCreateWithoutValidatedByInput>
  }

  export type AttendanceDailySummaryUpdateWithWhereUniqueWithoutValidatedByInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    data: XOR<AttendanceDailySummaryUpdateWithoutValidatedByInput, AttendanceDailySummaryUncheckedUpdateWithoutValidatedByInput>
  }

  export type AttendanceDailySummaryUpdateManyWithWhereWithoutValidatedByInput = {
    where: AttendanceDailySummaryScalarWhereInput
    data: XOR<AttendanceDailySummaryUpdateManyMutationInput, AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByInput>
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutValidatedByInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutValidatedByInput, LeaveRequestUncheckedUpdateWithoutValidatedByInput>
    create: XOR<LeaveRequestCreateWithoutValidatedByInput, LeaveRequestUncheckedCreateWithoutValidatedByInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutValidatedByInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutValidatedByInput, LeaveRequestUncheckedUpdateWithoutValidatedByInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutValidatedByInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutValidatedByInput>
  }

  export type PayrollPeriodUpsertWithWhereUniqueWithoutClosedByInput = {
    where: PayrollPeriodWhereUniqueInput
    update: XOR<PayrollPeriodUpdateWithoutClosedByInput, PayrollPeriodUncheckedUpdateWithoutClosedByInput>
    create: XOR<PayrollPeriodCreateWithoutClosedByInput, PayrollPeriodUncheckedCreateWithoutClosedByInput>
  }

  export type PayrollPeriodUpdateWithWhereUniqueWithoutClosedByInput = {
    where: PayrollPeriodWhereUniqueInput
    data: XOR<PayrollPeriodUpdateWithoutClosedByInput, PayrollPeriodUncheckedUpdateWithoutClosedByInput>
  }

  export type PayrollPeriodUpdateManyWithWhereWithoutClosedByInput = {
    where: PayrollPeriodScalarWhereInput
    data: XOR<PayrollPeriodUpdateManyMutationInput, PayrollPeriodUncheckedUpdateManyWithoutClosedByInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutAttendanceInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    person?: PersonCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttendanceInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    companyId: string
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeUncheckedCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestUncheckedCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodUncheckedCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttendanceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
  }

  export type CompanyCreateWithoutAttendanceInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAttendanceInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAttendanceInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAttendanceInput, CompanyUncheckedCreateWithoutAttendanceInput>
  }

  export type UserUpsertWithoutAttendanceInput = {
    update: XOR<UserUpdateWithoutAttendanceInput, UserUncheckedUpdateWithoutAttendanceInput>
    create: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceInput, UserUncheckedUpdateWithoutAttendanceInput>
  }

  export type UserUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUncheckedUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUncheckedUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUncheckedUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutAttendanceInput = {
    update: XOR<CompanyUpdateWithoutAttendanceInput, CompanyUncheckedUpdateWithoutAttendanceInput>
    create: XOR<CompanyCreateWithoutAttendanceInput, CompanyUncheckedCreateWithoutAttendanceInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAttendanceInput, CompanyUncheckedUpdateWithoutAttendanceInput>
  }

  export type CompanyUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutSchedulesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSchedulesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSchedulesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSchedulesInput, CompanyUncheckedCreateWithoutSchedulesInput>
  }

  export type EmployeeCreateWithoutScheduleInput = {
    id?: string
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutEmployeesInput
    person: PersonCreateNestedOneWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    attendances?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineCreateNestedManyWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutScheduleInput = {
    id?: string
    companyId: string
    personId: string
    userId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutScheduleInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutScheduleInput, EmployeeUncheckedCreateWithoutScheduleInput>
  }

  export type EmployeeCreateManyScheduleInputEnvelope = {
    data: EmployeeCreateManyScheduleInput | EmployeeCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutSchedulesInput = {
    update: XOR<CompanyUpdateWithoutSchedulesInput, CompanyUncheckedUpdateWithoutSchedulesInput>
    create: XOR<CompanyCreateWithoutSchedulesInput, CompanyUncheckedCreateWithoutSchedulesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSchedulesInput, CompanyUncheckedUpdateWithoutSchedulesInput>
  }

  export type CompanyUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type EmployeeUpsertWithWhereUniqueWithoutScheduleInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutScheduleInput, EmployeeUncheckedUpdateWithoutScheduleInput>
    create: XOR<EmployeeCreateWithoutScheduleInput, EmployeeUncheckedCreateWithoutScheduleInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutScheduleInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutScheduleInput, EmployeeUncheckedUpdateWithoutScheduleInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutScheduleInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutScheduleInput>
  }

  export type CompanyCreateWithoutOvertimeInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutOvertimeInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutOvertimeInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutOvertimeInput, CompanyUncheckedCreateWithoutOvertimeInput>
  }

  export type UserCreateWithoutOvertimeRequestsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    person?: PersonCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOvertimeRequestsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    companyId: string
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeUncheckedCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestUncheckedCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodUncheckedCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOvertimeRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOvertimeRequestsInput, UserUncheckedCreateWithoutOvertimeRequestsInput>
  }

  export type UserCreateWithoutOvertimeApprovalsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    person?: PersonCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeCreateNestedManyWithoutUserInput
    studentAttendanceRecords?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOvertimeApprovalsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    companyId: string
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    studentAttendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestUncheckedCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodUncheckedCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOvertimeApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOvertimeApprovalsInput, UserUncheckedCreateWithoutOvertimeApprovalsInput>
  }

  export type CompanyUpsertWithoutOvertimeInput = {
    update: XOR<CompanyUpdateWithoutOvertimeInput, CompanyUncheckedUpdateWithoutOvertimeInput>
    create: XOR<CompanyCreateWithoutOvertimeInput, CompanyUncheckedCreateWithoutOvertimeInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutOvertimeInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutOvertimeInput, CompanyUncheckedUpdateWithoutOvertimeInput>
  }

  export type CompanyUpdateWithoutOvertimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutOvertimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutOvertimeRequestsInput = {
    update: XOR<UserUpdateWithoutOvertimeRequestsInput, UserUncheckedUpdateWithoutOvertimeRequestsInput>
    create: XOR<UserCreateWithoutOvertimeRequestsInput, UserUncheckedCreateWithoutOvertimeRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOvertimeRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOvertimeRequestsInput, UserUncheckedUpdateWithoutOvertimeRequestsInput>
  }

  export type UserUpdateWithoutOvertimeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOvertimeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUncheckedUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUncheckedUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUncheckedUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutOvertimeApprovalsInput = {
    update: XOR<UserUpdateWithoutOvertimeApprovalsInput, UserUncheckedUpdateWithoutOvertimeApprovalsInput>
    create: XOR<UserCreateWithoutOvertimeApprovalsInput, UserUncheckedCreateWithoutOvertimeApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOvertimeApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOvertimeApprovalsInput, UserUncheckedUpdateWithoutOvertimeApprovalsInput>
  }

  export type UserUpdateWithoutOvertimeApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUpdateManyWithoutUserNestedInput
    studentAttendanceRecords?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOvertimeApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    studentAttendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUncheckedUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUncheckedUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutAttendanceSummariesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAttendanceSummariesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAttendanceSummariesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAttendanceSummariesInput, CompanyUncheckedCreateWithoutAttendanceSummariesInput>
  }

  export type PayrollCreateWithoutAttendanceSummaryInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    grossPay: number
    netPay: number
    status?: $Enums.PayrollStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPayrollsInput
    exports?: PayrollExportCreateNestedManyWithoutPayrollInput
  }

  export type PayrollUncheckedCreateWithoutAttendanceSummaryInput = {
    id?: string
    companyId: string
    periodStart: Date | string
    periodEnd: Date | string
    grossPay: number
    netPay: number
    status?: $Enums.PayrollStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exports?: PayrollExportUncheckedCreateNestedManyWithoutPayrollInput
  }

  export type PayrollCreateOrConnectWithoutAttendanceSummaryInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutAttendanceSummaryInput, PayrollUncheckedCreateWithoutAttendanceSummaryInput>
  }

  export type PayrollCreateManyAttendanceSummaryInputEnvelope = {
    data: PayrollCreateManyAttendanceSummaryInput | PayrollCreateManyAttendanceSummaryInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutAttendanceSummariesInput = {
    update: XOR<CompanyUpdateWithoutAttendanceSummariesInput, CompanyUncheckedUpdateWithoutAttendanceSummariesInput>
    create: XOR<CompanyCreateWithoutAttendanceSummariesInput, CompanyUncheckedCreateWithoutAttendanceSummariesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAttendanceSummariesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAttendanceSummariesInput, CompanyUncheckedUpdateWithoutAttendanceSummariesInput>
  }

  export type CompanyUpdateWithoutAttendanceSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAttendanceSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PayrollUpsertWithWhereUniqueWithoutAttendanceSummaryInput = {
    where: PayrollWhereUniqueInput
    update: XOR<PayrollUpdateWithoutAttendanceSummaryInput, PayrollUncheckedUpdateWithoutAttendanceSummaryInput>
    create: XOR<PayrollCreateWithoutAttendanceSummaryInput, PayrollUncheckedCreateWithoutAttendanceSummaryInput>
  }

  export type PayrollUpdateWithWhereUniqueWithoutAttendanceSummaryInput = {
    where: PayrollWhereUniqueInput
    data: XOR<PayrollUpdateWithoutAttendanceSummaryInput, PayrollUncheckedUpdateWithoutAttendanceSummaryInput>
  }

  export type PayrollUpdateManyWithWhereWithoutAttendanceSummaryInput = {
    where: PayrollScalarWhereInput
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyWithoutAttendanceSummaryInput>
  }

  export type CompanyCreateWithoutPayrollsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPayrollsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPayrollsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPayrollsInput, CompanyUncheckedCreateWithoutPayrollsInput>
  }

  export type AttendanceSummaryCreateWithoutPayrollsInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    totalHours: number
    overtimeHours: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutAttendanceSummariesInput
  }

  export type AttendanceSummaryUncheckedCreateWithoutPayrollsInput = {
    id?: string
    companyId: string
    periodStart: Date | string
    periodEnd: Date | string
    totalHours: number
    overtimeHours: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceSummaryCreateOrConnectWithoutPayrollsInput = {
    where: AttendanceSummaryWhereUniqueInput
    create: XOR<AttendanceSummaryCreateWithoutPayrollsInput, AttendanceSummaryUncheckedCreateWithoutPayrollsInput>
  }

  export type PayrollExportCreateWithoutPayrollInput = {
    id?: string
    format: $Enums.ExportFormat
    path: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPayrollExportsInput
  }

  export type PayrollExportUncheckedCreateWithoutPayrollInput = {
    id?: string
    companyId: string
    format: $Enums.ExportFormat
    path: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollExportCreateOrConnectWithoutPayrollInput = {
    where: PayrollExportWhereUniqueInput
    create: XOR<PayrollExportCreateWithoutPayrollInput, PayrollExportUncheckedCreateWithoutPayrollInput>
  }

  export type PayrollExportCreateManyPayrollInputEnvelope = {
    data: PayrollExportCreateManyPayrollInput | PayrollExportCreateManyPayrollInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutPayrollsInput = {
    update: XOR<CompanyUpdateWithoutPayrollsInput, CompanyUncheckedUpdateWithoutPayrollsInput>
    create: XOR<CompanyCreateWithoutPayrollsInput, CompanyUncheckedCreateWithoutPayrollsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPayrollsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPayrollsInput, CompanyUncheckedUpdateWithoutPayrollsInput>
  }

  export type CompanyUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AttendanceSummaryUpsertWithoutPayrollsInput = {
    update: XOR<AttendanceSummaryUpdateWithoutPayrollsInput, AttendanceSummaryUncheckedUpdateWithoutPayrollsInput>
    create: XOR<AttendanceSummaryCreateWithoutPayrollsInput, AttendanceSummaryUncheckedCreateWithoutPayrollsInput>
    where?: AttendanceSummaryWhereInput
  }

  export type AttendanceSummaryUpdateToOneWithWhereWithoutPayrollsInput = {
    where?: AttendanceSummaryWhereInput
    data: XOR<AttendanceSummaryUpdateWithoutPayrollsInput, AttendanceSummaryUncheckedUpdateWithoutPayrollsInput>
  }

  export type AttendanceSummaryUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAttendanceSummariesNestedInput
  }

  export type AttendanceSummaryUncheckedUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollExportUpsertWithWhereUniqueWithoutPayrollInput = {
    where: PayrollExportWhereUniqueInput
    update: XOR<PayrollExportUpdateWithoutPayrollInput, PayrollExportUncheckedUpdateWithoutPayrollInput>
    create: XOR<PayrollExportCreateWithoutPayrollInput, PayrollExportUncheckedCreateWithoutPayrollInput>
  }

  export type PayrollExportUpdateWithWhereUniqueWithoutPayrollInput = {
    where: PayrollExportWhereUniqueInput
    data: XOR<PayrollExportUpdateWithoutPayrollInput, PayrollExportUncheckedUpdateWithoutPayrollInput>
  }

  export type PayrollExportUpdateManyWithWhereWithoutPayrollInput = {
    where: PayrollExportScalarWhereInput
    data: XOR<PayrollExportUpdateManyMutationInput, PayrollExportUncheckedUpdateManyWithoutPayrollInput>
  }

  export type CompanyCreateWithoutPayrollExportsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPayrollExportsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPayrollExportsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPayrollExportsInput, CompanyUncheckedCreateWithoutPayrollExportsInput>
  }

  export type PayrollCreateWithoutExportsInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    grossPay: number
    netPay: number
    status?: $Enums.PayrollStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPayrollsInput
    attendanceSummary: AttendanceSummaryCreateNestedOneWithoutPayrollsInput
  }

  export type PayrollUncheckedCreateWithoutExportsInput = {
    id?: string
    companyId: string
    attendanceSummaryId: string
    periodStart: Date | string
    periodEnd: Date | string
    grossPay: number
    netPay: number
    status?: $Enums.PayrollStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateOrConnectWithoutExportsInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutExportsInput, PayrollUncheckedCreateWithoutExportsInput>
  }

  export type CompanyUpsertWithoutPayrollExportsInput = {
    update: XOR<CompanyUpdateWithoutPayrollExportsInput, CompanyUncheckedUpdateWithoutPayrollExportsInput>
    create: XOR<CompanyCreateWithoutPayrollExportsInput, CompanyUncheckedCreateWithoutPayrollExportsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPayrollExportsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPayrollExportsInput, CompanyUncheckedUpdateWithoutPayrollExportsInput>
  }

  export type CompanyUpdateWithoutPayrollExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPayrollExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PayrollUpsertWithoutExportsInput = {
    update: XOR<PayrollUpdateWithoutExportsInput, PayrollUncheckedUpdateWithoutExportsInput>
    create: XOR<PayrollCreateWithoutExportsInput, PayrollUncheckedCreateWithoutExportsInput>
    where?: PayrollWhereInput
  }

  export type PayrollUpdateToOneWithWhereWithoutExportsInput = {
    where?: PayrollWhereInput
    data: XOR<PayrollUpdateWithoutExportsInput, PayrollUncheckedUpdateWithoutExportsInput>
  }

  export type PayrollUpdateWithoutExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossPay?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPayrollsNestedInput
    attendanceSummary?: AttendanceSummaryUpdateOneRequiredWithoutPayrollsNestedInput
  }

  export type PayrollUncheckedUpdateWithoutExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    attendanceSummaryId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossPay?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateWithoutReportsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutReportsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutReportsInput, CompanyUncheckedCreateWithoutReportsInput>
  }

  export type CompanyUpsertWithoutReportsInput = {
    update: XOR<CompanyUpdateWithoutReportsInput, CompanyUncheckedUpdateWithoutReportsInput>
    create: XOR<CompanyCreateWithoutReportsInput, CompanyUncheckedCreateWithoutReportsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutReportsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutReportsInput, CompanyUncheckedUpdateWithoutReportsInput>
  }

  export type CompanyUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutPeriodClosuresInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPeriodClosuresInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPeriodClosuresInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPeriodClosuresInput, CompanyUncheckedCreateWithoutPeriodClosuresInput>
  }

  export type CompanyUpsertWithoutPeriodClosuresInput = {
    update: XOR<CompanyUpdateWithoutPeriodClosuresInput, CompanyUncheckedUpdateWithoutPeriodClosuresInput>
    create: XOR<CompanyCreateWithoutPeriodClosuresInput, CompanyUncheckedCreateWithoutPeriodClosuresInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPeriodClosuresInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPeriodClosuresInput, CompanyUncheckedUpdateWithoutPeriodClosuresInput>
  }

  export type CompanyUpdateWithoutPeriodClosuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPeriodClosuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutSchoolClassesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSchoolClassesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSchoolClassesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSchoolClassesInput, CompanyUncheckedCreateWithoutSchoolClassesInput>
  }

  export type CourseCreateWithoutClassInput = {
    id?: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutClassInput = {
    id?: string
    companyId: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreateOrConnectWithoutClassInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutClassInput, CourseUncheckedCreateWithoutClassInput>
  }

  export type CourseCreateManyClassInputEnvelope = {
    data: CourseCreateManyClassInput | CourseCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutClassInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStudentsInput
    person?: PersonCreateNestedOneWithoutStudentInput
    attendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutStudentInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutClassInput = {
    id?: string
    companyId: string
    firstName: string
    lastName: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutStudentInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutClassInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentCreateManyClassInputEnvelope = {
    data: StudentCreateManyClassInput | StudentCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutSchoolClassesInput = {
    update: XOR<CompanyUpdateWithoutSchoolClassesInput, CompanyUncheckedUpdateWithoutSchoolClassesInput>
    create: XOR<CompanyCreateWithoutSchoolClassesInput, CompanyUncheckedCreateWithoutSchoolClassesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSchoolClassesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSchoolClassesInput, CompanyUncheckedUpdateWithoutSchoolClassesInput>
  }

  export type CompanyUpdateWithoutSchoolClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSchoolClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CourseUpsertWithWhereUniqueWithoutClassInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutClassInput, CourseUncheckedUpdateWithoutClassInput>
    create: XOR<CourseCreateWithoutClassInput, CourseUncheckedCreateWithoutClassInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutClassInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutClassInput, CourseUncheckedUpdateWithoutClassInput>
  }

  export type CourseUpdateManyWithWhereWithoutClassInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutClassInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
  }

  export type StudentUpdateManyWithWhereWithoutClassInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutClassInput>
  }

  export type CompanyCreateWithoutCoursesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCoursesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCoursesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCoursesInput, CompanyUncheckedCreateWithoutCoursesInput>
  }

  export type SchoolClassCreateWithoutCoursesInput = {
    id?: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSchoolClassesInput
    students?: StudentCreateNestedManyWithoutClassInput
  }

  export type SchoolClassUncheckedCreateWithoutCoursesInput = {
    id?: string
    companyId: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
  }

  export type SchoolClassCreateOrConnectWithoutCoursesInput = {
    where: SchoolClassWhereUniqueInput
    create: XOR<SchoolClassCreateWithoutCoursesInput, SchoolClassUncheckedCreateWithoutCoursesInput>
  }

  export type CompanyUpsertWithoutCoursesInput = {
    update: XOR<CompanyUpdateWithoutCoursesInput, CompanyUncheckedUpdateWithoutCoursesInput>
    create: XOR<CompanyCreateWithoutCoursesInput, CompanyUncheckedCreateWithoutCoursesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCoursesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCoursesInput, CompanyUncheckedUpdateWithoutCoursesInput>
  }

  export type CompanyUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type SchoolClassUpsertWithoutCoursesInput = {
    update: XOR<SchoolClassUpdateWithoutCoursesInput, SchoolClassUncheckedUpdateWithoutCoursesInput>
    create: XOR<SchoolClassCreateWithoutCoursesInput, SchoolClassUncheckedCreateWithoutCoursesInput>
    where?: SchoolClassWhereInput
  }

  export type SchoolClassUpdateToOneWithWhereWithoutCoursesInput = {
    where?: SchoolClassWhereInput
    data: XOR<SchoolClassUpdateWithoutCoursesInput, SchoolClassUncheckedUpdateWithoutCoursesInput>
  }

  export type SchoolClassUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSchoolClassesNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
  }

  export type SchoolClassUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type CompanyCreateWithoutStudentsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutStudentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutStudentsInput, CompanyUncheckedCreateWithoutStudentsInput>
  }

  export type SchoolClassCreateWithoutStudentsInput = {
    id?: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSchoolClassesInput
    courses?: CourseCreateNestedManyWithoutClassInput
  }

  export type SchoolClassUncheckedCreateWithoutStudentsInput = {
    id?: string
    companyId: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutClassInput
  }

  export type SchoolClassCreateOrConnectWithoutStudentsInput = {
    where: SchoolClassWhereUniqueInput
    create: XOR<SchoolClassCreateWithoutStudentsInput, SchoolClassUncheckedCreateWithoutStudentsInput>
  }

  export type PersonCreateWithoutStudentInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPersonsInput
    user?: UserCreateNestedOneWithoutPersonInput
    employee?: EmployeeCreateNestedOneWithoutPersonInput
    worker?: WorkerCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerCreateNestedOneWithoutPersonInput
    devices?: DeviceCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutStudentInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserUncheckedCreateNestedOneWithoutPersonInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutPersonInput
    worker?: WorkerUncheckedCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerUncheckedCreateNestedOneWithoutPersonInput
    devices?: DeviceUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutStudentInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutStudentInput, PersonUncheckedCreateWithoutStudentInput>
  }

  export type StudentAttendanceCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    status: $Enums.StudentAttendanceStatus
    note?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStudentAttendanceInput
    recordedBy?: UserCreateNestedOneWithoutStudentAttendanceRecordsInput
  }

  export type StudentAttendanceUncheckedCreateWithoutStudentInput = {
    id?: string
    companyId: string
    date: Date | string
    status: $Enums.StudentAttendanceStatus
    note?: string | null
    recordedByUserId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateOrConnectWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    create: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput>
  }

  export type StudentAttendanceCreateManyStudentInputEnvelope = {
    data: StudentAttendanceCreateManyStudentInput | StudentAttendanceCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceEventCreateWithoutStudentInput = {
    id?: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    createdAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutAttendanceEventsInput
    employee?: EmployeeCreateNestedOneWithoutAttendancesInput
    worker?: WorkerCreateNestedOneWithoutAttendancesInput
    device?: DeviceCreateNestedOneWithoutAttendanceEventsInput
  }

  export type AttendanceEventUncheckedCreateWithoutStudentInput = {
    id?: string
    companyId: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    employeeId?: string | null
    workerId?: string | null
    deviceId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceEventCreateOrConnectWithoutStudentInput = {
    where: AttendanceEventWhereUniqueInput
    create: XOR<AttendanceEventCreateWithoutStudentInput, AttendanceEventUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceEventCreateManyStudentInputEnvelope = {
    data: AttendanceEventCreateManyStudentInput | AttendanceEventCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceDailySummaryCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutAttendanceDailySummariesInput
    employee?: EmployeeCreateNestedOneWithoutDailySummariesInput
    worker?: WorkerCreateNestedOneWithoutDailySummariesInput
    validatedBy?: UserCreateNestedOneWithoutAttendanceValidationsInput
  }

  export type AttendanceDailySummaryUncheckedCreateWithoutStudentInput = {
    id?: string
    companyId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    employeeId?: string | null
    workerId?: string | null
    validatedByUserId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceDailySummaryCreateOrConnectWithoutStudentInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    create: XOR<AttendanceDailySummaryCreateWithoutStudentInput, AttendanceDailySummaryUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceDailySummaryCreateManyStudentInputEnvelope = {
    data: AttendanceDailySummaryCreateManyStudentInput | AttendanceDailySummaryCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutStudentsInput = {
    update: XOR<CompanyUpdateWithoutStudentsInput, CompanyUncheckedUpdateWithoutStudentsInput>
    create: XOR<CompanyCreateWithoutStudentsInput, CompanyUncheckedCreateWithoutStudentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutStudentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutStudentsInput, CompanyUncheckedUpdateWithoutStudentsInput>
  }

  export type CompanyUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type SchoolClassUpsertWithoutStudentsInput = {
    update: XOR<SchoolClassUpdateWithoutStudentsInput, SchoolClassUncheckedUpdateWithoutStudentsInput>
    create: XOR<SchoolClassCreateWithoutStudentsInput, SchoolClassUncheckedCreateWithoutStudentsInput>
    where?: SchoolClassWhereInput
  }

  export type SchoolClassUpdateToOneWithWhereWithoutStudentsInput = {
    where?: SchoolClassWhereInput
    data: XOR<SchoolClassUpdateWithoutStudentsInput, SchoolClassUncheckedUpdateWithoutStudentsInput>
  }

  export type SchoolClassUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSchoolClassesNestedInput
    courses?: CourseUpdateManyWithoutClassNestedInput
  }

  export type SchoolClassUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutClassNestedInput
  }

  export type PersonUpsertWithoutStudentInput = {
    update: XOR<PersonUpdateWithoutStudentInput, PersonUncheckedUpdateWithoutStudentInput>
    create: XOR<PersonCreateWithoutStudentInput, PersonUncheckedCreateWithoutStudentInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutStudentInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutStudentInput, PersonUncheckedUpdateWithoutStudentInput>
  }

  export type PersonUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPersonsNestedInput
    user?: UserUpdateOneWithoutPersonNestedInput
    employee?: EmployeeUpdateOneWithoutPersonNestedInput
    worker?: WorkerUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUpdateOneWithoutPersonNestedInput
    devices?: DeviceUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateOneWithoutPersonNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutPersonNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUncheckedUpdateOneWithoutPersonNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    update: XOR<StudentAttendanceUpdateWithoutStudentInput, StudentAttendanceUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput>
  }

  export type StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    data: XOR<StudentAttendanceUpdateWithoutStudentInput, StudentAttendanceUncheckedUpdateWithoutStudentInput>
  }

  export type StudentAttendanceUpdateManyWithWhereWithoutStudentInput = {
    where: StudentAttendanceScalarWhereInput
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceEventUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceEventWhereUniqueInput
    update: XOR<AttendanceEventUpdateWithoutStudentInput, AttendanceEventUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceEventCreateWithoutStudentInput, AttendanceEventUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceEventUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceEventWhereUniqueInput
    data: XOR<AttendanceEventUpdateWithoutStudentInput, AttendanceEventUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceEventUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceEventScalarWhereInput
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceDailySummaryUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    update: XOR<AttendanceDailySummaryUpdateWithoutStudentInput, AttendanceDailySummaryUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceDailySummaryCreateWithoutStudentInput, AttendanceDailySummaryUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceDailySummaryUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    data: XOR<AttendanceDailySummaryUpdateWithoutStudentInput, AttendanceDailySummaryUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceDailySummaryUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceDailySummaryScalarWhereInput
    data: XOR<AttendanceDailySummaryUpdateManyMutationInput, AttendanceDailySummaryUncheckedUpdateManyWithoutStudentInput>
  }

  export type CompanyCreateWithoutStudentAttendanceInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutStudentAttendanceInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutStudentAttendanceInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutStudentAttendanceInput, CompanyUncheckedCreateWithoutStudentAttendanceInput>
  }

  export type StudentCreateWithoutAttendanceInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStudentsInput
    class: SchoolClassCreateNestedOneWithoutStudentsInput
    person?: PersonCreateNestedOneWithoutStudentInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutStudentInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAttendanceInput = {
    id?: string
    companyId: string
    classId: string
    firstName: string
    lastName: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutStudentInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAttendanceInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
  }

  export type UserCreateWithoutStudentAttendanceRecordsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    person?: PersonCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeCreateNestedManyWithoutApprovedByInput
    attendanceValidations?: AttendanceDailySummaryCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentAttendanceRecordsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    companyId: string
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeUncheckedCreateNestedManyWithoutApprovedByInput
    attendanceValidations?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestUncheckedCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodUncheckedCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentAttendanceRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentAttendanceRecordsInput, UserUncheckedCreateWithoutStudentAttendanceRecordsInput>
  }

  export type CompanyUpsertWithoutStudentAttendanceInput = {
    update: XOR<CompanyUpdateWithoutStudentAttendanceInput, CompanyUncheckedUpdateWithoutStudentAttendanceInput>
    create: XOR<CompanyCreateWithoutStudentAttendanceInput, CompanyUncheckedCreateWithoutStudentAttendanceInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutStudentAttendanceInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutStudentAttendanceInput, CompanyUncheckedUpdateWithoutStudentAttendanceInput>
  }

  export type CompanyUpdateWithoutStudentAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutStudentAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type StudentUpsertWithoutAttendanceInput = {
    update: XOR<StudentUpdateWithoutAttendanceInput, StudentUncheckedUpdateWithoutAttendanceInput>
    create: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAttendanceInput, StudentUncheckedUpdateWithoutAttendanceInput>
  }

  export type StudentUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStudentsNestedInput
    class?: SchoolClassUpdateOneRequiredWithoutStudentsNestedInput
    person?: PersonUpdateOneWithoutStudentNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutStudentNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutStudentNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserUpsertWithoutStudentAttendanceRecordsInput = {
    update: XOR<UserUpdateWithoutStudentAttendanceRecordsInput, UserUncheckedUpdateWithoutStudentAttendanceRecordsInput>
    create: XOR<UserCreateWithoutStudentAttendanceRecordsInput, UserUncheckedCreateWithoutStudentAttendanceRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentAttendanceRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentAttendanceRecordsInput, UserUncheckedUpdateWithoutStudentAttendanceRecordsInput>
  }

  export type UserUpdateWithoutStudentAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUpdateManyWithoutApprovedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUncheckedUpdateManyWithoutApprovedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUncheckedUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUncheckedUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutConstructionSitesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutConstructionSitesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutConstructionSitesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutConstructionSitesInput, CompanyUncheckedCreateWithoutConstructionSitesInput>
  }

  export type ConstructionTeamCreateWithoutSiteInput = {
    id?: string
    name: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutConstructionTeamsInput
    workers?: ConstructionWorkerCreateNestedManyWithoutTeamInput
  }

  export type ConstructionTeamUncheckedCreateWithoutSiteInput = {
    id?: string
    companyId: string
    name: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workers?: ConstructionWorkerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type ConstructionTeamCreateOrConnectWithoutSiteInput = {
    where: ConstructionTeamWhereUniqueInput
    create: XOR<ConstructionTeamCreateWithoutSiteInput, ConstructionTeamUncheckedCreateWithoutSiteInput>
  }

  export type ConstructionTeamCreateManySiteInputEnvelope = {
    data: ConstructionTeamCreateManySiteInput | ConstructionTeamCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type SiteAttendanceCreateWithoutSiteInput = {
    id?: string
    date: Date | string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSiteAttendanceInput
    worker: ConstructionWorkerCreateNestedOneWithoutAttendanceInput
  }

  export type SiteAttendanceUncheckedCreateWithoutSiteInput = {
    id?: string
    companyId: string
    workerId: string
    date: Date | string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteAttendanceCreateOrConnectWithoutSiteInput = {
    where: SiteAttendanceWhereUniqueInput
    create: XOR<SiteAttendanceCreateWithoutSiteInput, SiteAttendanceUncheckedCreateWithoutSiteInput>
  }

  export type SiteAttendanceCreateManySiteInputEnvelope = {
    data: SiteAttendanceCreateManySiteInput | SiteAttendanceCreateManySiteInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutConstructionSitesInput = {
    update: XOR<CompanyUpdateWithoutConstructionSitesInput, CompanyUncheckedUpdateWithoutConstructionSitesInput>
    create: XOR<CompanyCreateWithoutConstructionSitesInput, CompanyUncheckedCreateWithoutConstructionSitesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutConstructionSitesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutConstructionSitesInput, CompanyUncheckedUpdateWithoutConstructionSitesInput>
  }

  export type CompanyUpdateWithoutConstructionSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutConstructionSitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ConstructionTeamUpsertWithWhereUniqueWithoutSiteInput = {
    where: ConstructionTeamWhereUniqueInput
    update: XOR<ConstructionTeamUpdateWithoutSiteInput, ConstructionTeamUncheckedUpdateWithoutSiteInput>
    create: XOR<ConstructionTeamCreateWithoutSiteInput, ConstructionTeamUncheckedCreateWithoutSiteInput>
  }

  export type ConstructionTeamUpdateWithWhereUniqueWithoutSiteInput = {
    where: ConstructionTeamWhereUniqueInput
    data: XOR<ConstructionTeamUpdateWithoutSiteInput, ConstructionTeamUncheckedUpdateWithoutSiteInput>
  }

  export type ConstructionTeamUpdateManyWithWhereWithoutSiteInput = {
    where: ConstructionTeamScalarWhereInput
    data: XOR<ConstructionTeamUpdateManyMutationInput, ConstructionTeamUncheckedUpdateManyWithoutSiteInput>
  }

  export type SiteAttendanceUpsertWithWhereUniqueWithoutSiteInput = {
    where: SiteAttendanceWhereUniqueInput
    update: XOR<SiteAttendanceUpdateWithoutSiteInput, SiteAttendanceUncheckedUpdateWithoutSiteInput>
    create: XOR<SiteAttendanceCreateWithoutSiteInput, SiteAttendanceUncheckedCreateWithoutSiteInput>
  }

  export type SiteAttendanceUpdateWithWhereUniqueWithoutSiteInput = {
    where: SiteAttendanceWhereUniqueInput
    data: XOR<SiteAttendanceUpdateWithoutSiteInput, SiteAttendanceUncheckedUpdateWithoutSiteInput>
  }

  export type SiteAttendanceUpdateManyWithWhereWithoutSiteInput = {
    where: SiteAttendanceScalarWhereInput
    data: XOR<SiteAttendanceUpdateManyMutationInput, SiteAttendanceUncheckedUpdateManyWithoutSiteInput>
  }

  export type CompanyCreateWithoutConstructionTeamsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutConstructionTeamsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutConstructionTeamsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutConstructionTeamsInput, CompanyUncheckedCreateWithoutConstructionTeamsInput>
  }

  export type ConstructionSiteCreateWithoutTeamsInput = {
    id?: string
    name: string
    location?: string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutConstructionSitesInput
    attendance?: SiteAttendanceCreateNestedManyWithoutSiteInput
  }

  export type ConstructionSiteUncheckedCreateWithoutTeamsInput = {
    id?: string
    companyId: string
    name: string
    location?: string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: SiteAttendanceUncheckedCreateNestedManyWithoutSiteInput
  }

  export type ConstructionSiteCreateOrConnectWithoutTeamsInput = {
    where: ConstructionSiteWhereUniqueInput
    create: XOR<ConstructionSiteCreateWithoutTeamsInput, ConstructionSiteUncheckedCreateWithoutTeamsInput>
  }

  export type ConstructionWorkerCreateWithoutTeamInput = {
    id?: string
    name: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutConstructionWorkersInput
    person?: PersonCreateNestedOneWithoutConstructionWorkerInput
    attendance?: SiteAttendanceCreateNestedManyWithoutWorkerInput
  }

  export type ConstructionWorkerUncheckedCreateWithoutTeamInput = {
    id?: string
    companyId: string
    name: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: SiteAttendanceUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type ConstructionWorkerCreateOrConnectWithoutTeamInput = {
    where: ConstructionWorkerWhereUniqueInput
    create: XOR<ConstructionWorkerCreateWithoutTeamInput, ConstructionWorkerUncheckedCreateWithoutTeamInput>
  }

  export type ConstructionWorkerCreateManyTeamInputEnvelope = {
    data: ConstructionWorkerCreateManyTeamInput | ConstructionWorkerCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutConstructionTeamsInput = {
    update: XOR<CompanyUpdateWithoutConstructionTeamsInput, CompanyUncheckedUpdateWithoutConstructionTeamsInput>
    create: XOR<CompanyCreateWithoutConstructionTeamsInput, CompanyUncheckedCreateWithoutConstructionTeamsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutConstructionTeamsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutConstructionTeamsInput, CompanyUncheckedUpdateWithoutConstructionTeamsInput>
  }

  export type CompanyUpdateWithoutConstructionTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutConstructionTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ConstructionSiteUpsertWithoutTeamsInput = {
    update: XOR<ConstructionSiteUpdateWithoutTeamsInput, ConstructionSiteUncheckedUpdateWithoutTeamsInput>
    create: XOR<ConstructionSiteCreateWithoutTeamsInput, ConstructionSiteUncheckedCreateWithoutTeamsInput>
    where?: ConstructionSiteWhereInput
  }

  export type ConstructionSiteUpdateToOneWithWhereWithoutTeamsInput = {
    where?: ConstructionSiteWhereInput
    data: XOR<ConstructionSiteUpdateWithoutTeamsInput, ConstructionSiteUncheckedUpdateWithoutTeamsInput>
  }

  export type ConstructionSiteUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutConstructionSitesNestedInput
    attendance?: SiteAttendanceUpdateManyWithoutSiteNestedInput
  }

  export type ConstructionSiteUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: SiteAttendanceUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type ConstructionWorkerUpsertWithWhereUniqueWithoutTeamInput = {
    where: ConstructionWorkerWhereUniqueInput
    update: XOR<ConstructionWorkerUpdateWithoutTeamInput, ConstructionWorkerUncheckedUpdateWithoutTeamInput>
    create: XOR<ConstructionWorkerCreateWithoutTeamInput, ConstructionWorkerUncheckedCreateWithoutTeamInput>
  }

  export type ConstructionWorkerUpdateWithWhereUniqueWithoutTeamInput = {
    where: ConstructionWorkerWhereUniqueInput
    data: XOR<ConstructionWorkerUpdateWithoutTeamInput, ConstructionWorkerUncheckedUpdateWithoutTeamInput>
  }

  export type ConstructionWorkerUpdateManyWithWhereWithoutTeamInput = {
    where: ConstructionWorkerScalarWhereInput
    data: XOR<ConstructionWorkerUpdateManyMutationInput, ConstructionWorkerUncheckedUpdateManyWithoutTeamInput>
  }

  export type CompanyCreateWithoutConstructionWorkersInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutConstructionWorkersInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutConstructionWorkersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutConstructionWorkersInput, CompanyUncheckedCreateWithoutConstructionWorkersInput>
  }

  export type ConstructionTeamCreateWithoutWorkersInput = {
    id?: string
    name: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutConstructionTeamsInput
    site: ConstructionSiteCreateNestedOneWithoutTeamsInput
  }

  export type ConstructionTeamUncheckedCreateWithoutWorkersInput = {
    id?: string
    companyId: string
    siteId: string
    name: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConstructionTeamCreateOrConnectWithoutWorkersInput = {
    where: ConstructionTeamWhereUniqueInput
    create: XOR<ConstructionTeamCreateWithoutWorkersInput, ConstructionTeamUncheckedCreateWithoutWorkersInput>
  }

  export type PersonCreateWithoutConstructionWorkerInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPersonsInput
    user?: UserCreateNestedOneWithoutPersonInput
    employee?: EmployeeCreateNestedOneWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    worker?: WorkerCreateNestedOneWithoutPersonInput
    devices?: DeviceCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutConstructionWorkerInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserUncheckedCreateNestedOneWithoutPersonInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    worker?: WorkerUncheckedCreateNestedOneWithoutPersonInput
    devices?: DeviceUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutConstructionWorkerInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutConstructionWorkerInput, PersonUncheckedCreateWithoutConstructionWorkerInput>
  }

  export type SiteAttendanceCreateWithoutWorkerInput = {
    id?: string
    date: Date | string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSiteAttendanceInput
    site: ConstructionSiteCreateNestedOneWithoutAttendanceInput
  }

  export type SiteAttendanceUncheckedCreateWithoutWorkerInput = {
    id?: string
    companyId: string
    siteId: string
    date: Date | string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteAttendanceCreateOrConnectWithoutWorkerInput = {
    where: SiteAttendanceWhereUniqueInput
    create: XOR<SiteAttendanceCreateWithoutWorkerInput, SiteAttendanceUncheckedCreateWithoutWorkerInput>
  }

  export type SiteAttendanceCreateManyWorkerInputEnvelope = {
    data: SiteAttendanceCreateManyWorkerInput | SiteAttendanceCreateManyWorkerInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutConstructionWorkersInput = {
    update: XOR<CompanyUpdateWithoutConstructionWorkersInput, CompanyUncheckedUpdateWithoutConstructionWorkersInput>
    create: XOR<CompanyCreateWithoutConstructionWorkersInput, CompanyUncheckedCreateWithoutConstructionWorkersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutConstructionWorkersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutConstructionWorkersInput, CompanyUncheckedUpdateWithoutConstructionWorkersInput>
  }

  export type CompanyUpdateWithoutConstructionWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutConstructionWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ConstructionTeamUpsertWithoutWorkersInput = {
    update: XOR<ConstructionTeamUpdateWithoutWorkersInput, ConstructionTeamUncheckedUpdateWithoutWorkersInput>
    create: XOR<ConstructionTeamCreateWithoutWorkersInput, ConstructionTeamUncheckedCreateWithoutWorkersInput>
    where?: ConstructionTeamWhereInput
  }

  export type ConstructionTeamUpdateToOneWithWhereWithoutWorkersInput = {
    where?: ConstructionTeamWhereInput
    data: XOR<ConstructionTeamUpdateWithoutWorkersInput, ConstructionTeamUncheckedUpdateWithoutWorkersInput>
  }

  export type ConstructionTeamUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutConstructionTeamsNestedInput
    site?: ConstructionSiteUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type ConstructionTeamUncheckedUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonUpsertWithoutConstructionWorkerInput = {
    update: XOR<PersonUpdateWithoutConstructionWorkerInput, PersonUncheckedUpdateWithoutConstructionWorkerInput>
    create: XOR<PersonCreateWithoutConstructionWorkerInput, PersonUncheckedCreateWithoutConstructionWorkerInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutConstructionWorkerInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutConstructionWorkerInput, PersonUncheckedUpdateWithoutConstructionWorkerInput>
  }

  export type PersonUpdateWithoutConstructionWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPersonsNestedInput
    user?: UserUpdateOneWithoutPersonNestedInput
    employee?: EmployeeUpdateOneWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    worker?: WorkerUpdateOneWithoutPersonNestedInput
    devices?: DeviceUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutConstructionWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateOneWithoutPersonNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutPersonNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type SiteAttendanceUpsertWithWhereUniqueWithoutWorkerInput = {
    where: SiteAttendanceWhereUniqueInput
    update: XOR<SiteAttendanceUpdateWithoutWorkerInput, SiteAttendanceUncheckedUpdateWithoutWorkerInput>
    create: XOR<SiteAttendanceCreateWithoutWorkerInput, SiteAttendanceUncheckedCreateWithoutWorkerInput>
  }

  export type SiteAttendanceUpdateWithWhereUniqueWithoutWorkerInput = {
    where: SiteAttendanceWhereUniqueInput
    data: XOR<SiteAttendanceUpdateWithoutWorkerInput, SiteAttendanceUncheckedUpdateWithoutWorkerInput>
  }

  export type SiteAttendanceUpdateManyWithWhereWithoutWorkerInput = {
    where: SiteAttendanceScalarWhereInput
    data: XOR<SiteAttendanceUpdateManyMutationInput, SiteAttendanceUncheckedUpdateManyWithoutWorkerInput>
  }

  export type CompanyCreateWithoutSiteAttendanceInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSiteAttendanceInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSiteAttendanceInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSiteAttendanceInput, CompanyUncheckedCreateWithoutSiteAttendanceInput>
  }

  export type ConstructionSiteCreateWithoutAttendanceInput = {
    id?: string
    name: string
    location?: string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutConstructionSitesInput
    teams?: ConstructionTeamCreateNestedManyWithoutSiteInput
  }

  export type ConstructionSiteUncheckedCreateWithoutAttendanceInput = {
    id?: string
    companyId: string
    name: string
    location?: string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: ConstructionTeamUncheckedCreateNestedManyWithoutSiteInput
  }

  export type ConstructionSiteCreateOrConnectWithoutAttendanceInput = {
    where: ConstructionSiteWhereUniqueInput
    create: XOR<ConstructionSiteCreateWithoutAttendanceInput, ConstructionSiteUncheckedCreateWithoutAttendanceInput>
  }

  export type ConstructionWorkerCreateWithoutAttendanceInput = {
    id?: string
    name: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutConstructionWorkersInput
    team: ConstructionTeamCreateNestedOneWithoutWorkersInput
    person?: PersonCreateNestedOneWithoutConstructionWorkerInput
  }

  export type ConstructionWorkerUncheckedCreateWithoutAttendanceInput = {
    id?: string
    companyId: string
    teamId: string
    name: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConstructionWorkerCreateOrConnectWithoutAttendanceInput = {
    where: ConstructionWorkerWhereUniqueInput
    create: XOR<ConstructionWorkerCreateWithoutAttendanceInput, ConstructionWorkerUncheckedCreateWithoutAttendanceInput>
  }

  export type CompanyUpsertWithoutSiteAttendanceInput = {
    update: XOR<CompanyUpdateWithoutSiteAttendanceInput, CompanyUncheckedUpdateWithoutSiteAttendanceInput>
    create: XOR<CompanyCreateWithoutSiteAttendanceInput, CompanyUncheckedCreateWithoutSiteAttendanceInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSiteAttendanceInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSiteAttendanceInput, CompanyUncheckedUpdateWithoutSiteAttendanceInput>
  }

  export type CompanyUpdateWithoutSiteAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSiteAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ConstructionSiteUpsertWithoutAttendanceInput = {
    update: XOR<ConstructionSiteUpdateWithoutAttendanceInput, ConstructionSiteUncheckedUpdateWithoutAttendanceInput>
    create: XOR<ConstructionSiteCreateWithoutAttendanceInput, ConstructionSiteUncheckedCreateWithoutAttendanceInput>
    where?: ConstructionSiteWhereInput
  }

  export type ConstructionSiteUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: ConstructionSiteWhereInput
    data: XOR<ConstructionSiteUpdateWithoutAttendanceInput, ConstructionSiteUncheckedUpdateWithoutAttendanceInput>
  }

  export type ConstructionSiteUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutConstructionSitesNestedInput
    teams?: ConstructionTeamUpdateManyWithoutSiteNestedInput
  }

  export type ConstructionSiteUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: ConstructionTeamUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type ConstructionWorkerUpsertWithoutAttendanceInput = {
    update: XOR<ConstructionWorkerUpdateWithoutAttendanceInput, ConstructionWorkerUncheckedUpdateWithoutAttendanceInput>
    create: XOR<ConstructionWorkerCreateWithoutAttendanceInput, ConstructionWorkerUncheckedCreateWithoutAttendanceInput>
    where?: ConstructionWorkerWhereInput
  }

  export type ConstructionWorkerUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: ConstructionWorkerWhereInput
    data: XOR<ConstructionWorkerUpdateWithoutAttendanceInput, ConstructionWorkerUncheckedUpdateWithoutAttendanceInput>
  }

  export type ConstructionWorkerUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutConstructionWorkersNestedInput
    team?: ConstructionTeamUpdateOneRequiredWithoutWorkersNestedInput
    person?: PersonUpdateOneWithoutConstructionWorkerNestedInput
  }

  export type ConstructionWorkerUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAuditLogsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    person?: PersonCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodCreateNestedManyWithoutClosedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    companyId: string
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeUncheckedCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestUncheckedCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodUncheckedCreateNestedManyWithoutClosedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type CompanyUpsertWithoutAuditLogsInput = {
    update: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<CompanyCreateWithoutAuditLogsInput, CompanyUncheckedCreateWithoutAuditLogsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAuditLogsInput, CompanyUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CompanyUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUpdateManyWithoutClosedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUncheckedUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUncheckedUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUncheckedUpdateManyWithoutClosedByNestedInput
  }

  export type UserCreateWithoutUserRolesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    person?: PersonCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    companyId: string
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeUncheckedCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestUncheckedCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodUncheckedCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type CompanyCreateWithoutUserRolesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUserRolesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUserRolesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUserRolesInput, CompanyUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUncheckedUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUncheckedUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUncheckedUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutUserRolesInput = {
    update: XOR<CompanyUpdateWithoutUserRolesInput, CompanyUncheckedUpdateWithoutUserRolesInput>
    create: XOR<CompanyCreateWithoutUserRolesInput, CompanyUncheckedCreateWithoutUserRolesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUserRolesInput, CompanyUncheckedUpdateWithoutUserRolesInput>
  }

  export type CompanyUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutPersonsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPersonsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPersonsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPersonsInput, CompanyUncheckedCreateWithoutPersonsInput>
  }

  export type UserCreateWithoutPersonInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPersonInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    companyId: string
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeUncheckedCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestUncheckedCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodUncheckedCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPersonInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonInput, UserUncheckedCreateWithoutPersonInput>
  }

  export type EmployeeCreateWithoutPersonInput = {
    id?: string
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutEmployeesInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    schedule?: ScheduleCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineCreateNestedManyWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPersonInput = {
    id?: string
    companyId: string
    userId?: string | null
    scheduleId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPersonInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPersonInput, EmployeeUncheckedCreateWithoutPersonInput>
  }

  export type StudentCreateWithoutPersonInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStudentsInput
    class: SchoolClassCreateNestedOneWithoutStudentsInput
    attendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutStudentInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutPersonInput = {
    id?: string
    companyId: string
    classId: string
    firstName: string
    lastName: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutStudentInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutPersonInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
  }

  export type WorkerCreateWithoutPersonInput = {
    id?: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutWorkersInput
    attendances?: AttendanceEventCreateNestedManyWithoutWorkerInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUncheckedCreateWithoutPersonInput = {
    id?: string
    companyId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutWorkerInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type WorkerCreateOrConnectWithoutPersonInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutPersonInput, WorkerUncheckedCreateWithoutPersonInput>
  }

  export type ConstructionWorkerCreateWithoutPersonInput = {
    id?: string
    name: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutConstructionWorkersInput
    team: ConstructionTeamCreateNestedOneWithoutWorkersInput
    attendance?: SiteAttendanceCreateNestedManyWithoutWorkerInput
  }

  export type ConstructionWorkerUncheckedCreateWithoutPersonInput = {
    id?: string
    companyId: string
    teamId: string
    name: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: SiteAttendanceUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type ConstructionWorkerCreateOrConnectWithoutPersonInput = {
    where: ConstructionWorkerWhereUniqueInput
    create: XOR<ConstructionWorkerCreateWithoutPersonInput, ConstructionWorkerUncheckedCreateWithoutPersonInput>
  }

  export type DeviceCreateWithoutPersonInput = {
    id?: string
    uuid: string
    platform: string
    model: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutDeviceInput
    company: CompanyCreateNestedOneWithoutDevicesInput
  }

  export type DeviceUncheckedCreateWithoutPersonInput = {
    id?: string
    uuid: string
    platform: string
    model: string
    companyId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutPersonInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutPersonInput, DeviceUncheckedCreateWithoutPersonInput>
  }

  export type DeviceCreateManyPersonInputEnvelope = {
    data: DeviceCreateManyPersonInput | DeviceCreateManyPersonInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutPersonsInput = {
    update: XOR<CompanyUpdateWithoutPersonsInput, CompanyUncheckedUpdateWithoutPersonsInput>
    create: XOR<CompanyCreateWithoutPersonsInput, CompanyUncheckedCreateWithoutPersonsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPersonsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPersonsInput, CompanyUncheckedUpdateWithoutPersonsInput>
  }

  export type CompanyUpdateWithoutPersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutPersonInput = {
    update: XOR<UserUpdateWithoutPersonInput, UserUncheckedUpdateWithoutPersonInput>
    create: XOR<UserCreateWithoutPersonInput, UserUncheckedCreateWithoutPersonInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPersonInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPersonInput, UserUncheckedUpdateWithoutPersonInput>
  }

  export type UserUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUncheckedUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUncheckedUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUncheckedUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmployeeUpsertWithoutPersonInput = {
    update: XOR<EmployeeUpdateWithoutPersonInput, EmployeeUncheckedUpdateWithoutPersonInput>
    create: XOR<EmployeeCreateWithoutPersonInput, EmployeeUncheckedCreateWithoutPersonInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPersonInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPersonInput, EmployeeUncheckedUpdateWithoutPersonInput>
  }

  export type EmployeeUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    schedule?: ScheduleUpdateOneWithoutEmployeesNestedInput
    attendances?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type StudentUpsertWithoutPersonInput = {
    update: XOR<StudentUpdateWithoutPersonInput, StudentUncheckedUpdateWithoutPersonInput>
    create: XOR<StudentCreateWithoutPersonInput, StudentUncheckedCreateWithoutPersonInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutPersonInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutPersonInput, StudentUncheckedUpdateWithoutPersonInput>
  }

  export type StudentUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStudentsNestedInput
    class?: SchoolClassUpdateOneRequiredWithoutStudentsNestedInput
    attendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutStudentNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutStudentNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type WorkerUpsertWithoutPersonInput = {
    update: XOR<WorkerUpdateWithoutPersonInput, WorkerUncheckedUpdateWithoutPersonInput>
    create: XOR<WorkerCreateWithoutPersonInput, WorkerUncheckedCreateWithoutPersonInput>
    where?: WorkerWhereInput
  }

  export type WorkerUpdateToOneWithWhereWithoutPersonInput = {
    where?: WorkerWhereInput
    data: XOR<WorkerUpdateWithoutPersonInput, WorkerUncheckedUpdateWithoutPersonInput>
  }

  export type WorkerUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutWorkersNestedInput
    attendances?: AttendanceEventUpdateManyWithoutWorkerNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutWorkerNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type ConstructionWorkerUpsertWithoutPersonInput = {
    update: XOR<ConstructionWorkerUpdateWithoutPersonInput, ConstructionWorkerUncheckedUpdateWithoutPersonInput>
    create: XOR<ConstructionWorkerCreateWithoutPersonInput, ConstructionWorkerUncheckedCreateWithoutPersonInput>
    where?: ConstructionWorkerWhereInput
  }

  export type ConstructionWorkerUpdateToOneWithWhereWithoutPersonInput = {
    where?: ConstructionWorkerWhereInput
    data: XOR<ConstructionWorkerUpdateWithoutPersonInput, ConstructionWorkerUncheckedUpdateWithoutPersonInput>
  }

  export type ConstructionWorkerUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutConstructionWorkersNestedInput
    team?: ConstructionTeamUpdateOneRequiredWithoutWorkersNestedInput
    attendance?: SiteAttendanceUpdateManyWithoutWorkerNestedInput
  }

  export type ConstructionWorkerUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: SiteAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type DeviceUpsertWithWhereUniqueWithoutPersonInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutPersonInput, DeviceUncheckedUpdateWithoutPersonInput>
    create: XOR<DeviceCreateWithoutPersonInput, DeviceUncheckedCreateWithoutPersonInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutPersonInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutPersonInput, DeviceUncheckedUpdateWithoutPersonInput>
  }

  export type DeviceUpdateManyWithWhereWithoutPersonInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutPersonInput>
  }

  export type CompanyCreateWithoutEmployeesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutEmployeesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
  }

  export type PersonCreateWithoutEmployeeInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPersonsInput
    user?: UserCreateNestedOneWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    worker?: WorkerCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerCreateNestedOneWithoutPersonInput
    devices?: DeviceCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutEmployeeInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserUncheckedCreateNestedOneWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    worker?: WorkerUncheckedCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerUncheckedCreateNestedOneWithoutPersonInput
    devices?: DeviceUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutEmployeeInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutEmployeeInput, PersonUncheckedCreateWithoutEmployeeInput>
  }

  export type UserCreateWithoutEmployeeInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    person?: PersonCreateNestedOneWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    companyId: string
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeUncheckedCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestUncheckedCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodUncheckedCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type ScheduleCreateWithoutEmployeesInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    daysOfWeek?: ScheduleCreatedaysOfWeekInput | string[]
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutEmployeesInput = {
    id?: string
    companyId: string
    name: string
    startTime: string
    endTime: string
    daysOfWeek?: ScheduleCreatedaysOfWeekInput | string[]
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutEmployeesInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutEmployeesInput, ScheduleUncheckedCreateWithoutEmployeesInput>
  }

  export type AttendanceEventCreateWithoutEmployeeInput = {
    id?: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    createdAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutAttendanceEventsInput
    student?: StudentCreateNestedOneWithoutAttendanceEventsInput
    worker?: WorkerCreateNestedOneWithoutAttendancesInput
    device?: DeviceCreateNestedOneWithoutAttendanceEventsInput
  }

  export type AttendanceEventUncheckedCreateWithoutEmployeeInput = {
    id?: string
    companyId: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    studentId?: string | null
    workerId?: string | null
    deviceId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceEventCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceEventWhereUniqueInput
    create: XOR<AttendanceEventCreateWithoutEmployeeInput, AttendanceEventUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceEventCreateManyEmployeeInputEnvelope = {
    data: AttendanceEventCreateManyEmployeeInput | AttendanceEventCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceDailySummaryCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutAttendanceDailySummariesInput
    student?: StudentCreateNestedOneWithoutDailySummariesInput
    worker?: WorkerCreateNestedOneWithoutDailySummariesInput
    validatedBy?: UserCreateNestedOneWithoutAttendanceValidationsInput
  }

  export type AttendanceDailySummaryUncheckedCreateWithoutEmployeeInput = {
    id?: string
    companyId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    studentId?: string | null
    workerId?: string | null
    validatedByUserId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceDailySummaryCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    create: XOR<AttendanceDailySummaryCreateWithoutEmployeeInput, AttendanceDailySummaryUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceDailySummaryCreateManyEmployeeInputEnvelope = {
    data: AttendanceDailySummaryCreateManyEmployeeInput | AttendanceDailySummaryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type PayrollLineCreateWithoutEmployeeInput = {
    id?: string
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutPayrollLinesInput
    payrollPeriod: PayrollPeriodCreateNestedOneWithoutLinesInput
  }

  export type PayrollLineUncheckedCreateWithoutEmployeeInput = {
    id?: string
    companyId: string
    payrollPeriodId: string
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PayrollLineCreateOrConnectWithoutEmployeeInput = {
    where: PayrollLineWhereUniqueInput
    create: XOR<PayrollLineCreateWithoutEmployeeInput, PayrollLineUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollLineCreateManyEmployeeInputEnvelope = {
    data: PayrollLineCreateManyEmployeeInput | PayrollLineCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutEmployeeInput = {
    id?: string
    salaryType: $Enums.SalaryType
    baseSalary: number
    hourlyRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutContractsInput
  }

  export type ContractUncheckedCreateWithoutEmployeeInput = {
    id?: string
    companyId: string
    salaryType: $Enums.SalaryType
    baseSalary: number
    hourlyRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ContractCreateOrConnectWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput>
  }

  export type ContractCreateManyEmployeeInputEnvelope = {
    data: ContractCreateManyEmployeeInput | ContractCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveBalanceCreateWithoutEmployeeInput = {
    id?: string
    year: number
    totalDays: number
    usedDays?: number
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutLeaveBalancesInput
    leaveType: LeaveTypeCreateNestedOneWithoutBalancesInput
  }

  export type LeaveBalanceUncheckedCreateWithoutEmployeeInput = {
    id?: string
    companyId: string
    leaveTypeId: string
    year: number
    totalDays: number
    usedDays?: number
    deletedAt?: Date | string | null
  }

  export type LeaveBalanceCreateOrConnectWithoutEmployeeInput = {
    where: LeaveBalanceWhereUniqueInput
    create: XOR<LeaveBalanceCreateWithoutEmployeeInput, LeaveBalanceUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveBalanceCreateManyEmployeeInputEnvelope = {
    data: LeaveBalanceCreateManyEmployeeInput | LeaveBalanceCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutEmployeeInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutLeaveRequestsInput
    leaveType: LeaveTypeCreateNestedOneWithoutRequestsInput
    validatedBy?: UserCreateNestedOneWithoutLeaveValidationsInput
  }

  export type LeaveRequestUncheckedCreateWithoutEmployeeInput = {
    id?: string
    companyId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    validatedByUserId?: string | null
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateOrConnectWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveRequestCreateManyEmployeeInputEnvelope = {
    data: LeaveRequestCreateManyEmployeeInput | LeaveRequestCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutEmployeesInput = {
    update: XOR<CompanyUpdateWithoutEmployeesInput, CompanyUncheckedUpdateWithoutEmployeesInput>
    create: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutEmployeesInput, CompanyUncheckedUpdateWithoutEmployeesInput>
  }

  export type CompanyUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PersonUpsertWithoutEmployeeInput = {
    update: XOR<PersonUpdateWithoutEmployeeInput, PersonUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PersonCreateWithoutEmployeeInput, PersonUncheckedCreateWithoutEmployeeInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutEmployeeInput, PersonUncheckedUpdateWithoutEmployeeInput>
  }

  export type PersonUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPersonsNestedInput
    user?: UserUpdateOneWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    worker?: WorkerUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUpdateOneWithoutPersonNestedInput
    devices?: DeviceUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateOneWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUncheckedUpdateOneWithoutPersonNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUncheckedUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUncheckedUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUncheckedUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ScheduleUpsertWithoutEmployeesInput = {
    update: XOR<ScheduleUpdateWithoutEmployeesInput, ScheduleUncheckedUpdateWithoutEmployeesInput>
    create: XOR<ScheduleCreateWithoutEmployeesInput, ScheduleUncheckedCreateWithoutEmployeesInput>
    where?: ScheduleWhereInput
  }

  export type ScheduleUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: ScheduleWhereInput
    data: XOR<ScheduleUpdateWithoutEmployeesInput, ScheduleUncheckedUpdateWithoutEmployeesInput>
  }

  export type ScheduleUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduleUpdatedaysOfWeekInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduleUpdatedaysOfWeekInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceEventWhereUniqueInput
    update: XOR<AttendanceEventUpdateWithoutEmployeeInput, AttendanceEventUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceEventCreateWithoutEmployeeInput, AttendanceEventUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceEventUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceEventWhereUniqueInput
    data: XOR<AttendanceEventUpdateWithoutEmployeeInput, AttendanceEventUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceEventUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceEventScalarWhereInput
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AttendanceDailySummaryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    update: XOR<AttendanceDailySummaryUpdateWithoutEmployeeInput, AttendanceDailySummaryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceDailySummaryCreateWithoutEmployeeInput, AttendanceDailySummaryUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceDailySummaryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    data: XOR<AttendanceDailySummaryUpdateWithoutEmployeeInput, AttendanceDailySummaryUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceDailySummaryUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceDailySummaryScalarWhereInput
    data: XOR<AttendanceDailySummaryUpdateManyMutationInput, AttendanceDailySummaryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PayrollLineUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollLineWhereUniqueInput
    update: XOR<PayrollLineUpdateWithoutEmployeeInput, PayrollLineUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PayrollLineCreateWithoutEmployeeInput, PayrollLineUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollLineUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollLineWhereUniqueInput
    data: XOR<PayrollLineUpdateWithoutEmployeeInput, PayrollLineUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollLineUpdateManyWithWhereWithoutEmployeeInput = {
    where: PayrollLineScalarWhereInput
    data: XOR<PayrollLineUpdateManyMutationInput, PayrollLineUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type ContractUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutEmployeeInput, ContractUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutEmployeeInput, ContractUncheckedUpdateWithoutEmployeeInput>
  }

  export type ContractUpdateManyWithWhereWithoutEmployeeInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LeaveBalanceUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveBalanceWhereUniqueInput
    update: XOR<LeaveBalanceUpdateWithoutEmployeeInput, LeaveBalanceUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveBalanceCreateWithoutEmployeeInput, LeaveBalanceUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveBalanceUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveBalanceWhereUniqueInput
    data: XOR<LeaveBalanceUpdateWithoutEmployeeInput, LeaveBalanceUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveBalanceUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveBalanceScalarWhereInput
    data: XOR<LeaveBalanceUpdateManyMutationInput, LeaveBalanceUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutEmployeeInput, LeaveRequestUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutEmployeeInput, LeaveRequestUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type CompanyCreateWithoutWorkersInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutWorkersInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutWorkersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutWorkersInput, CompanyUncheckedCreateWithoutWorkersInput>
  }

  export type PersonCreateWithoutWorkerInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPersonsInput
    user?: UserCreateNestedOneWithoutPersonInput
    employee?: EmployeeCreateNestedOneWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerCreateNestedOneWithoutPersonInput
    devices?: DeviceCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutWorkerInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserUncheckedCreateNestedOneWithoutPersonInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerUncheckedCreateNestedOneWithoutPersonInput
    devices?: DeviceUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutWorkerInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutWorkerInput, PersonUncheckedCreateWithoutWorkerInput>
  }

  export type AttendanceEventCreateWithoutWorkerInput = {
    id?: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    createdAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutAttendanceEventsInput
    employee?: EmployeeCreateNestedOneWithoutAttendancesInput
    student?: StudentCreateNestedOneWithoutAttendanceEventsInput
    device?: DeviceCreateNestedOneWithoutAttendanceEventsInput
  }

  export type AttendanceEventUncheckedCreateWithoutWorkerInput = {
    id?: string
    companyId: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    employeeId?: string | null
    studentId?: string | null
    deviceId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceEventCreateOrConnectWithoutWorkerInput = {
    where: AttendanceEventWhereUniqueInput
    create: XOR<AttendanceEventCreateWithoutWorkerInput, AttendanceEventUncheckedCreateWithoutWorkerInput>
  }

  export type AttendanceEventCreateManyWorkerInputEnvelope = {
    data: AttendanceEventCreateManyWorkerInput | AttendanceEventCreateManyWorkerInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceDailySummaryCreateWithoutWorkerInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutAttendanceDailySummariesInput
    employee?: EmployeeCreateNestedOneWithoutDailySummariesInput
    student?: StudentCreateNestedOneWithoutDailySummariesInput
    validatedBy?: UserCreateNestedOneWithoutAttendanceValidationsInput
  }

  export type AttendanceDailySummaryUncheckedCreateWithoutWorkerInput = {
    id?: string
    companyId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    employeeId?: string | null
    studentId?: string | null
    validatedByUserId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceDailySummaryCreateOrConnectWithoutWorkerInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    create: XOR<AttendanceDailySummaryCreateWithoutWorkerInput, AttendanceDailySummaryUncheckedCreateWithoutWorkerInput>
  }

  export type AttendanceDailySummaryCreateManyWorkerInputEnvelope = {
    data: AttendanceDailySummaryCreateManyWorkerInput | AttendanceDailySummaryCreateManyWorkerInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutWorkersInput = {
    update: XOR<CompanyUpdateWithoutWorkersInput, CompanyUncheckedUpdateWithoutWorkersInput>
    create: XOR<CompanyCreateWithoutWorkersInput, CompanyUncheckedCreateWithoutWorkersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutWorkersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutWorkersInput, CompanyUncheckedUpdateWithoutWorkersInput>
  }

  export type CompanyUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PersonUpsertWithoutWorkerInput = {
    update: XOR<PersonUpdateWithoutWorkerInput, PersonUncheckedUpdateWithoutWorkerInput>
    create: XOR<PersonCreateWithoutWorkerInput, PersonUncheckedCreateWithoutWorkerInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutWorkerInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutWorkerInput, PersonUncheckedUpdateWithoutWorkerInput>
  }

  export type PersonUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPersonsNestedInput
    user?: UserUpdateOneWithoutPersonNestedInput
    employee?: EmployeeUpdateOneWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUpdateOneWithoutPersonNestedInput
    devices?: DeviceUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateOneWithoutPersonNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUncheckedUpdateOneWithoutPersonNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type AttendanceEventUpsertWithWhereUniqueWithoutWorkerInput = {
    where: AttendanceEventWhereUniqueInput
    update: XOR<AttendanceEventUpdateWithoutWorkerInput, AttendanceEventUncheckedUpdateWithoutWorkerInput>
    create: XOR<AttendanceEventCreateWithoutWorkerInput, AttendanceEventUncheckedCreateWithoutWorkerInput>
  }

  export type AttendanceEventUpdateWithWhereUniqueWithoutWorkerInput = {
    where: AttendanceEventWhereUniqueInput
    data: XOR<AttendanceEventUpdateWithoutWorkerInput, AttendanceEventUncheckedUpdateWithoutWorkerInput>
  }

  export type AttendanceEventUpdateManyWithWhereWithoutWorkerInput = {
    where: AttendanceEventScalarWhereInput
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyWithoutWorkerInput>
  }

  export type AttendanceDailySummaryUpsertWithWhereUniqueWithoutWorkerInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    update: XOR<AttendanceDailySummaryUpdateWithoutWorkerInput, AttendanceDailySummaryUncheckedUpdateWithoutWorkerInput>
    create: XOR<AttendanceDailySummaryCreateWithoutWorkerInput, AttendanceDailySummaryUncheckedCreateWithoutWorkerInput>
  }

  export type AttendanceDailySummaryUpdateWithWhereUniqueWithoutWorkerInput = {
    where: AttendanceDailySummaryWhereUniqueInput
    data: XOR<AttendanceDailySummaryUpdateWithoutWorkerInput, AttendanceDailySummaryUncheckedUpdateWithoutWorkerInput>
  }

  export type AttendanceDailySummaryUpdateManyWithWhereWithoutWorkerInput = {
    where: AttendanceDailySummaryScalarWhereInput
    data: XOR<AttendanceDailySummaryUpdateManyMutationInput, AttendanceDailySummaryUncheckedUpdateManyWithoutWorkerInput>
  }

  export type CompanyCreateWithoutAttendanceEventsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAttendanceEventsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAttendanceEventsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAttendanceEventsInput, CompanyUncheckedCreateWithoutAttendanceEventsInput>
  }

  export type EmployeeCreateWithoutAttendancesInput = {
    id?: string
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutEmployeesInput
    person: PersonCreateNestedOneWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    schedule?: ScheduleCreateNestedOneWithoutEmployeesInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineCreateNestedManyWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAttendancesInput = {
    id?: string
    companyId: string
    personId: string
    userId?: string | null
    scheduleId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAttendancesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
  }

  export type StudentCreateWithoutAttendanceEventsInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStudentsInput
    class: SchoolClassCreateNestedOneWithoutStudentsInput
    person?: PersonCreateNestedOneWithoutStudentInput
    attendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAttendanceEventsInput = {
    id?: string
    companyId: string
    classId: string
    firstName: string
    lastName: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAttendanceEventsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAttendanceEventsInput, StudentUncheckedCreateWithoutAttendanceEventsInput>
  }

  export type WorkerCreateWithoutAttendancesInput = {
    id?: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutWorkersInput
    person: PersonCreateNestedOneWithoutWorkerInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUncheckedCreateWithoutAttendancesInput = {
    id?: string
    companyId: string
    personId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type WorkerCreateOrConnectWithoutAttendancesInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutAttendancesInput, WorkerUncheckedCreateWithoutAttendancesInput>
  }

  export type DeviceCreateWithoutAttendanceEventsInput = {
    id?: string
    uuid: string
    platform: string
    model: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    person: PersonCreateNestedOneWithoutDevicesInput
    company: CompanyCreateNestedOneWithoutDevicesInput
  }

  export type DeviceUncheckedCreateWithoutAttendanceEventsInput = {
    id?: string
    uuid: string
    platform: string
    model: string
    personId: string
    companyId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DeviceCreateOrConnectWithoutAttendanceEventsInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutAttendanceEventsInput, DeviceUncheckedCreateWithoutAttendanceEventsInput>
  }

  export type CompanyUpsertWithoutAttendanceEventsInput = {
    update: XOR<CompanyUpdateWithoutAttendanceEventsInput, CompanyUncheckedUpdateWithoutAttendanceEventsInput>
    create: XOR<CompanyCreateWithoutAttendanceEventsInput, CompanyUncheckedCreateWithoutAttendanceEventsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAttendanceEventsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAttendanceEventsInput, CompanyUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type CompanyUpdateWithoutAttendanceEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAttendanceEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type EmployeeUpsertWithoutAttendancesInput = {
    update: XOR<EmployeeUpdateWithoutAttendancesInput, EmployeeUncheckedUpdateWithoutAttendancesInput>
    create: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAttendancesInput, EmployeeUncheckedUpdateWithoutAttendancesInput>
  }

  export type EmployeeUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
    person?: PersonUpdateOneRequiredWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    schedule?: ScheduleUpdateOneWithoutEmployeesNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type StudentUpsertWithoutAttendanceEventsInput = {
    update: XOR<StudentUpdateWithoutAttendanceEventsInput, StudentUncheckedUpdateWithoutAttendanceEventsInput>
    create: XOR<StudentCreateWithoutAttendanceEventsInput, StudentUncheckedCreateWithoutAttendanceEventsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAttendanceEventsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAttendanceEventsInput, StudentUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type StudentUpdateWithoutAttendanceEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStudentsNestedInput
    class?: SchoolClassUpdateOneRequiredWithoutStudentsNestedInput
    person?: PersonUpdateOneWithoutStudentNestedInput
    attendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAttendanceEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type WorkerUpsertWithoutAttendancesInput = {
    update: XOR<WorkerUpdateWithoutAttendancesInput, WorkerUncheckedUpdateWithoutAttendancesInput>
    create: XOR<WorkerCreateWithoutAttendancesInput, WorkerUncheckedCreateWithoutAttendancesInput>
    where?: WorkerWhereInput
  }

  export type WorkerUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: WorkerWhereInput
    data: XOR<WorkerUpdateWithoutAttendancesInput, WorkerUncheckedUpdateWithoutAttendancesInput>
  }

  export type WorkerUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutWorkersNestedInput
    person?: PersonUpdateOneRequiredWithoutWorkerNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type DeviceUpsertWithoutAttendanceEventsInput = {
    update: XOR<DeviceUpdateWithoutAttendanceEventsInput, DeviceUncheckedUpdateWithoutAttendanceEventsInput>
    create: XOR<DeviceCreateWithoutAttendanceEventsInput, DeviceUncheckedCreateWithoutAttendanceEventsInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutAttendanceEventsInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutAttendanceEventsInput, DeviceUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type DeviceUpdateWithoutAttendanceEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutDevicesNestedInput
    company?: CompanyUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type DeviceUncheckedUpdateWithoutAttendanceEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateWithoutAttendanceDailySummariesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAttendanceDailySummariesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAttendanceDailySummariesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAttendanceDailySummariesInput, CompanyUncheckedCreateWithoutAttendanceDailySummariesInput>
  }

  export type EmployeeCreateWithoutDailySummariesInput = {
    id?: string
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutEmployeesInput
    person: PersonCreateNestedOneWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    schedule?: ScheduleCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineCreateNestedManyWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDailySummariesInput = {
    id?: string
    companyId: string
    personId: string
    userId?: string | null
    scheduleId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDailySummariesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDailySummariesInput, EmployeeUncheckedCreateWithoutDailySummariesInput>
  }

  export type StudentCreateWithoutDailySummariesInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStudentsInput
    class: SchoolClassCreateNestedOneWithoutStudentsInput
    person?: PersonCreateNestedOneWithoutStudentInput
    attendance?: StudentAttendanceCreateNestedManyWithoutStudentInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutDailySummariesInput = {
    id?: string
    companyId: string
    classId: string
    firstName: string
    lastName: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutDailySummariesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutDailySummariesInput, StudentUncheckedCreateWithoutDailySummariesInput>
  }

  export type WorkerCreateWithoutDailySummariesInput = {
    id?: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutWorkersInput
    person: PersonCreateNestedOneWithoutWorkerInput
    attendances?: AttendanceEventCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUncheckedCreateWithoutDailySummariesInput = {
    id?: string
    companyId: string
    personId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type WorkerCreateOrConnectWithoutDailySummariesInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutDailySummariesInput, WorkerUncheckedCreateWithoutDailySummariesInput>
  }

  export type UserCreateWithoutAttendanceValidationsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    person?: PersonCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    leaveValidations?: LeaveRequestCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttendanceValidationsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    companyId: string
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeUncheckedCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    leaveValidations?: LeaveRequestUncheckedCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodUncheckedCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttendanceValidationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceValidationsInput, UserUncheckedCreateWithoutAttendanceValidationsInput>
  }

  export type CompanyUpsertWithoutAttendanceDailySummariesInput = {
    update: XOR<CompanyUpdateWithoutAttendanceDailySummariesInput, CompanyUncheckedUpdateWithoutAttendanceDailySummariesInput>
    create: XOR<CompanyCreateWithoutAttendanceDailySummariesInput, CompanyUncheckedCreateWithoutAttendanceDailySummariesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAttendanceDailySummariesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAttendanceDailySummariesInput, CompanyUncheckedUpdateWithoutAttendanceDailySummariesInput>
  }

  export type CompanyUpdateWithoutAttendanceDailySummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAttendanceDailySummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type EmployeeUpsertWithoutDailySummariesInput = {
    update: XOR<EmployeeUpdateWithoutDailySummariesInput, EmployeeUncheckedUpdateWithoutDailySummariesInput>
    create: XOR<EmployeeCreateWithoutDailySummariesInput, EmployeeUncheckedCreateWithoutDailySummariesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutDailySummariesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutDailySummariesInput, EmployeeUncheckedUpdateWithoutDailySummariesInput>
  }

  export type EmployeeUpdateWithoutDailySummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
    person?: PersonUpdateOneRequiredWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    schedule?: ScheduleUpdateOneWithoutEmployeesNestedInput
    attendances?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDailySummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type StudentUpsertWithoutDailySummariesInput = {
    update: XOR<StudentUpdateWithoutDailySummariesInput, StudentUncheckedUpdateWithoutDailySummariesInput>
    create: XOR<StudentCreateWithoutDailySummariesInput, StudentUncheckedCreateWithoutDailySummariesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutDailySummariesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutDailySummariesInput, StudentUncheckedUpdateWithoutDailySummariesInput>
  }

  export type StudentUpdateWithoutDailySummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStudentsNestedInput
    class?: SchoolClassUpdateOneRequiredWithoutStudentsNestedInput
    person?: PersonUpdateOneWithoutStudentNestedInput
    attendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutDailySummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type WorkerUpsertWithoutDailySummariesInput = {
    update: XOR<WorkerUpdateWithoutDailySummariesInput, WorkerUncheckedUpdateWithoutDailySummariesInput>
    create: XOR<WorkerCreateWithoutDailySummariesInput, WorkerUncheckedCreateWithoutDailySummariesInput>
    where?: WorkerWhereInput
  }

  export type WorkerUpdateToOneWithWhereWithoutDailySummariesInput = {
    where?: WorkerWhereInput
    data: XOR<WorkerUpdateWithoutDailySummariesInput, WorkerUncheckedUpdateWithoutDailySummariesInput>
  }

  export type WorkerUpdateWithoutDailySummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutWorkersNestedInput
    person?: PersonUpdateOneRequiredWithoutWorkerNestedInput
    attendances?: AttendanceEventUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateWithoutDailySummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type UserUpsertWithoutAttendanceValidationsInput = {
    update: XOR<UserUpdateWithoutAttendanceValidationsInput, UserUncheckedUpdateWithoutAttendanceValidationsInput>
    create: XOR<UserCreateWithoutAttendanceValidationsInput, UserUncheckedCreateWithoutAttendanceValidationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceValidationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceValidationsInput, UserUncheckedUpdateWithoutAttendanceValidationsInput>
  }

  export type UserUpdateWithoutAttendanceValidationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    leaveValidations?: LeaveRequestUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceValidationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUncheckedUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    leaveValidations?: LeaveRequestUncheckedUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUncheckedUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PersonCreateWithoutDevicesInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPersonsInput
    user?: UserCreateNestedOneWithoutPersonInput
    employee?: EmployeeCreateNestedOneWithoutPersonInput
    student?: StudentCreateNestedOneWithoutPersonInput
    worker?: WorkerCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerCreateNestedOneWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutDevicesInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserUncheckedCreateNestedOneWithoutPersonInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutPersonInput
    student?: StudentUncheckedCreateNestedOneWithoutPersonInput
    worker?: WorkerUncheckedCreateNestedOneWithoutPersonInput
    constructionWorker?: ConstructionWorkerUncheckedCreateNestedOneWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutDevicesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutDevicesInput, PersonUncheckedCreateWithoutDevicesInput>
  }

  export type AttendanceEventCreateWithoutDeviceInput = {
    id?: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    createdAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutAttendanceEventsInput
    employee?: EmployeeCreateNestedOneWithoutAttendancesInput
    student?: StudentCreateNestedOneWithoutAttendanceEventsInput
    worker?: WorkerCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceEventUncheckedCreateWithoutDeviceInput = {
    id?: string
    companyId: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    employeeId?: string | null
    studentId?: string | null
    workerId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceEventCreateOrConnectWithoutDeviceInput = {
    where: AttendanceEventWhereUniqueInput
    create: XOR<AttendanceEventCreateWithoutDeviceInput, AttendanceEventUncheckedCreateWithoutDeviceInput>
  }

  export type AttendanceEventCreateManyDeviceInputEnvelope = {
    data: AttendanceEventCreateManyDeviceInput | AttendanceEventCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutDevicesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDevicesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDevicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDevicesInput, CompanyUncheckedCreateWithoutDevicesInput>
  }

  export type PersonUpsertWithoutDevicesInput = {
    update: XOR<PersonUpdateWithoutDevicesInput, PersonUncheckedUpdateWithoutDevicesInput>
    create: XOR<PersonCreateWithoutDevicesInput, PersonUncheckedCreateWithoutDevicesInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutDevicesInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutDevicesInput, PersonUncheckedUpdateWithoutDevicesInput>
  }

  export type PersonUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPersonsNestedInput
    user?: UserUpdateOneWithoutPersonNestedInput
    employee?: EmployeeUpdateOneWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    worker?: WorkerUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUpdateOneWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateOneWithoutPersonNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUncheckedUpdateOneWithoutPersonNestedInput
  }

  export type AttendanceEventUpsertWithWhereUniqueWithoutDeviceInput = {
    where: AttendanceEventWhereUniqueInput
    update: XOR<AttendanceEventUpdateWithoutDeviceInput, AttendanceEventUncheckedUpdateWithoutDeviceInput>
    create: XOR<AttendanceEventCreateWithoutDeviceInput, AttendanceEventUncheckedCreateWithoutDeviceInput>
  }

  export type AttendanceEventUpdateWithWhereUniqueWithoutDeviceInput = {
    where: AttendanceEventWhereUniqueInput
    data: XOR<AttendanceEventUpdateWithoutDeviceInput, AttendanceEventUncheckedUpdateWithoutDeviceInput>
  }

  export type AttendanceEventUpdateManyWithWhereWithoutDeviceInput = {
    where: AttendanceEventScalarWhereInput
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyWithoutDeviceInput>
  }

  export type CompanyUpsertWithoutDevicesInput = {
    update: XOR<CompanyUpdateWithoutDevicesInput, CompanyUncheckedUpdateWithoutDevicesInput>
    create: XOR<CompanyCreateWithoutDevicesInput, CompanyUncheckedCreateWithoutDevicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDevicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDevicesInput, CompanyUncheckedUpdateWithoutDevicesInput>
  }

  export type CompanyUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutLeaveTypesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutLeaveTypesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutLeaveTypesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutLeaveTypesInput, CompanyUncheckedCreateWithoutLeaveTypesInput>
  }

  export type LeaveBalanceCreateWithoutLeaveTypeInput = {
    id?: string
    year: number
    totalDays: number
    usedDays?: number
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutLeaveBalancesInput
    employee: EmployeeCreateNestedOneWithoutLeaveBalancesInput
  }

  export type LeaveBalanceUncheckedCreateWithoutLeaveTypeInput = {
    id?: string
    companyId: string
    employeeId: string
    year: number
    totalDays: number
    usedDays?: number
    deletedAt?: Date | string | null
  }

  export type LeaveBalanceCreateOrConnectWithoutLeaveTypeInput = {
    where: LeaveBalanceWhereUniqueInput
    create: XOR<LeaveBalanceCreateWithoutLeaveTypeInput, LeaveBalanceUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LeaveBalanceCreateManyLeaveTypeInputEnvelope = {
    data: LeaveBalanceCreateManyLeaveTypeInput | LeaveBalanceCreateManyLeaveTypeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutLeaveTypeInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutLeaveRequestsInput
    employee: EmployeeCreateNestedOneWithoutLeaveRequestsInput
    validatedBy?: UserCreateNestedOneWithoutLeaveValidationsInput
  }

  export type LeaveRequestUncheckedCreateWithoutLeaveTypeInput = {
    id?: string
    companyId: string
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    validatedByUserId?: string | null
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateOrConnectWithoutLeaveTypeInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutLeaveTypeInput, LeaveRequestUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LeaveRequestCreateManyLeaveTypeInputEnvelope = {
    data: LeaveRequestCreateManyLeaveTypeInput | LeaveRequestCreateManyLeaveTypeInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutLeaveTypesInput = {
    update: XOR<CompanyUpdateWithoutLeaveTypesInput, CompanyUncheckedUpdateWithoutLeaveTypesInput>
    create: XOR<CompanyCreateWithoutLeaveTypesInput, CompanyUncheckedCreateWithoutLeaveTypesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutLeaveTypesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutLeaveTypesInput, CompanyUncheckedUpdateWithoutLeaveTypesInput>
  }

  export type CompanyUpdateWithoutLeaveTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutLeaveTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type LeaveBalanceUpsertWithWhereUniqueWithoutLeaveTypeInput = {
    where: LeaveBalanceWhereUniqueInput
    update: XOR<LeaveBalanceUpdateWithoutLeaveTypeInput, LeaveBalanceUncheckedUpdateWithoutLeaveTypeInput>
    create: XOR<LeaveBalanceCreateWithoutLeaveTypeInput, LeaveBalanceUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LeaveBalanceUpdateWithWhereUniqueWithoutLeaveTypeInput = {
    where: LeaveBalanceWhereUniqueInput
    data: XOR<LeaveBalanceUpdateWithoutLeaveTypeInput, LeaveBalanceUncheckedUpdateWithoutLeaveTypeInput>
  }

  export type LeaveBalanceUpdateManyWithWhereWithoutLeaveTypeInput = {
    where: LeaveBalanceScalarWhereInput
    data: XOR<LeaveBalanceUpdateManyMutationInput, LeaveBalanceUncheckedUpdateManyWithoutLeaveTypeInput>
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutLeaveTypeInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutLeaveTypeInput, LeaveRequestUncheckedUpdateWithoutLeaveTypeInput>
    create: XOR<LeaveRequestCreateWithoutLeaveTypeInput, LeaveRequestUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutLeaveTypeInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutLeaveTypeInput, LeaveRequestUncheckedUpdateWithoutLeaveTypeInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutLeaveTypeInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutLeaveTypeInput>
  }

  export type CompanyCreateWithoutLeaveBalancesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutLeaveBalancesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutLeaveBalancesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutLeaveBalancesInput, CompanyUncheckedCreateWithoutLeaveBalancesInput>
  }

  export type EmployeeCreateWithoutLeaveBalancesInput = {
    id?: string
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutEmployeesInput
    person: PersonCreateNestedOneWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    schedule?: ScheduleCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineCreateNestedManyWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLeaveBalancesInput = {
    id?: string
    companyId: string
    personId: string
    userId?: string | null
    scheduleId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLeaveBalancesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeaveBalancesInput, EmployeeUncheckedCreateWithoutLeaveBalancesInput>
  }

  export type LeaveTypeCreateWithoutBalancesInput = {
    id?: string
    name: string
    code: string
    isPaid: boolean
    maxDaysYear?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutLeaveTypesInput
    requests?: LeaveRequestCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUncheckedCreateWithoutBalancesInput = {
    id?: string
    companyId: string
    name: string
    code: string
    isPaid: boolean
    maxDaysYear?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    requests?: LeaveRequestUncheckedCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeCreateOrConnectWithoutBalancesInput = {
    where: LeaveTypeWhereUniqueInput
    create: XOR<LeaveTypeCreateWithoutBalancesInput, LeaveTypeUncheckedCreateWithoutBalancesInput>
  }

  export type CompanyUpsertWithoutLeaveBalancesInput = {
    update: XOR<CompanyUpdateWithoutLeaveBalancesInput, CompanyUncheckedUpdateWithoutLeaveBalancesInput>
    create: XOR<CompanyCreateWithoutLeaveBalancesInput, CompanyUncheckedCreateWithoutLeaveBalancesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutLeaveBalancesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutLeaveBalancesInput, CompanyUncheckedUpdateWithoutLeaveBalancesInput>
  }

  export type CompanyUpdateWithoutLeaveBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutLeaveBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type EmployeeUpsertWithoutLeaveBalancesInput = {
    update: XOR<EmployeeUpdateWithoutLeaveBalancesInput, EmployeeUncheckedUpdateWithoutLeaveBalancesInput>
    create: XOR<EmployeeCreateWithoutLeaveBalancesInput, EmployeeUncheckedCreateWithoutLeaveBalancesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeaveBalancesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeaveBalancesInput, EmployeeUncheckedUpdateWithoutLeaveBalancesInput>
  }

  export type EmployeeUpdateWithoutLeaveBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
    person?: PersonUpdateOneRequiredWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    schedule?: ScheduleUpdateOneWithoutEmployeesNestedInput
    attendances?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeaveBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type LeaveTypeUpsertWithoutBalancesInput = {
    update: XOR<LeaveTypeUpdateWithoutBalancesInput, LeaveTypeUncheckedUpdateWithoutBalancesInput>
    create: XOR<LeaveTypeCreateWithoutBalancesInput, LeaveTypeUncheckedCreateWithoutBalancesInput>
    where?: LeaveTypeWhereInput
  }

  export type LeaveTypeUpdateToOneWithWhereWithoutBalancesInput = {
    where?: LeaveTypeWhereInput
    data: XOR<LeaveTypeUpdateWithoutBalancesInput, LeaveTypeUncheckedUpdateWithoutBalancesInput>
  }

  export type LeaveTypeUpdateWithoutBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    maxDaysYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutLeaveTypesNestedInput
    requests?: LeaveRequestUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateWithoutBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    maxDaysYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requests?: LeaveRequestUncheckedUpdateManyWithoutLeaveTypeNestedInput
  }

  export type CompanyCreateWithoutLeaveRequestsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutLeaveRequestsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutLeaveRequestsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutLeaveRequestsInput, CompanyUncheckedCreateWithoutLeaveRequestsInput>
  }

  export type EmployeeCreateWithoutLeaveRequestsInput = {
    id?: string
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutEmployeesInput
    person: PersonCreateNestedOneWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    schedule?: ScheduleCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineCreateNestedManyWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLeaveRequestsInput = {
    id?: string
    companyId: string
    personId: string
    userId?: string | null
    scheduleId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLeaveRequestsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeaveRequestsInput, EmployeeUncheckedCreateWithoutLeaveRequestsInput>
  }

  export type LeaveTypeCreateWithoutRequestsInput = {
    id?: string
    name: string
    code: string
    isPaid: boolean
    maxDaysYear?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutLeaveTypesInput
    balances?: LeaveBalanceCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUncheckedCreateWithoutRequestsInput = {
    id?: string
    companyId: string
    name: string
    code: string
    isPaid: boolean
    maxDaysYear?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    balances?: LeaveBalanceUncheckedCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeCreateOrConnectWithoutRequestsInput = {
    where: LeaveTypeWhereUniqueInput
    create: XOR<LeaveTypeCreateWithoutRequestsInput, LeaveTypeUncheckedCreateWithoutRequestsInput>
  }

  export type UserCreateWithoutLeaveValidationsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    person?: PersonCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaveValidationsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    companyId: string
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeUncheckedCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutValidatedByInput
    payrollPeriodClosures?: PayrollPeriodUncheckedCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaveValidationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaveValidationsInput, UserUncheckedCreateWithoutLeaveValidationsInput>
  }

  export type CompanyUpsertWithoutLeaveRequestsInput = {
    update: XOR<CompanyUpdateWithoutLeaveRequestsInput, CompanyUncheckedUpdateWithoutLeaveRequestsInput>
    create: XOR<CompanyCreateWithoutLeaveRequestsInput, CompanyUncheckedCreateWithoutLeaveRequestsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutLeaveRequestsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutLeaveRequestsInput, CompanyUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type CompanyUpdateWithoutLeaveRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutLeaveRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type EmployeeUpsertWithoutLeaveRequestsInput = {
    update: XOR<EmployeeUpdateWithoutLeaveRequestsInput, EmployeeUncheckedUpdateWithoutLeaveRequestsInput>
    create: XOR<EmployeeCreateWithoutLeaveRequestsInput, EmployeeUncheckedCreateWithoutLeaveRequestsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeaveRequestsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeaveRequestsInput, EmployeeUncheckedUpdateWithoutLeaveRequestsInput>
  }

  export type EmployeeUpdateWithoutLeaveRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
    person?: PersonUpdateOneRequiredWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    schedule?: ScheduleUpdateOneWithoutEmployeesNestedInput
    attendances?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeaveRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type LeaveTypeUpsertWithoutRequestsInput = {
    update: XOR<LeaveTypeUpdateWithoutRequestsInput, LeaveTypeUncheckedUpdateWithoutRequestsInput>
    create: XOR<LeaveTypeCreateWithoutRequestsInput, LeaveTypeUncheckedCreateWithoutRequestsInput>
    where?: LeaveTypeWhereInput
  }

  export type LeaveTypeUpdateToOneWithWhereWithoutRequestsInput = {
    where?: LeaveTypeWhereInput
    data: XOR<LeaveTypeUpdateWithoutRequestsInput, LeaveTypeUncheckedUpdateWithoutRequestsInput>
  }

  export type LeaveTypeUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    maxDaysYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutLeaveTypesNestedInput
    balances?: LeaveBalanceUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    maxDaysYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balances?: LeaveBalanceUncheckedUpdateManyWithoutLeaveTypeNestedInput
  }

  export type UserUpsertWithoutLeaveValidationsInput = {
    update: XOR<UserUpdateWithoutLeaveValidationsInput, UserUncheckedUpdateWithoutLeaveValidationsInput>
    create: XOR<UserCreateWithoutLeaveValidationsInput, UserUncheckedCreateWithoutLeaveValidationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaveValidationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaveValidationsInput, UserUncheckedUpdateWithoutLeaveValidationsInput>
  }

  export type UserUpdateWithoutLeaveValidationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaveValidationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUncheckedUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUncheckedUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutPublicHolidaysInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPublicHolidaysInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPublicHolidaysInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPublicHolidaysInput, CompanyUncheckedCreateWithoutPublicHolidaysInput>
  }

  export type CompanyUpsertWithoutPublicHolidaysInput = {
    update: XOR<CompanyUpdateWithoutPublicHolidaysInput, CompanyUncheckedUpdateWithoutPublicHolidaysInput>
    create: XOR<CompanyCreateWithoutPublicHolidaysInput, CompanyUncheckedCreateWithoutPublicHolidaysInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPublicHolidaysInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPublicHolidaysInput, CompanyUncheckedUpdateWithoutPublicHolidaysInput>
  }

  export type CompanyUpdateWithoutPublicHolidaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPublicHolidaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutContractsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutContractsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutContractsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutContractsInput, CompanyUncheckedCreateWithoutContractsInput>
  }

  export type EmployeeCreateWithoutContractsInput = {
    id?: string
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutEmployeesInput
    person: PersonCreateNestedOneWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    schedule?: ScheduleCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutContractsInput = {
    id?: string
    companyId: string
    personId: string
    userId?: string | null
    scheduleId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutContractsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
  }

  export type CompanyUpsertWithoutContractsInput = {
    update: XOR<CompanyUpdateWithoutContractsInput, CompanyUncheckedUpdateWithoutContractsInput>
    create: XOR<CompanyCreateWithoutContractsInput, CompanyUncheckedCreateWithoutContractsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutContractsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutContractsInput, CompanyUncheckedUpdateWithoutContractsInput>
  }

  export type CompanyUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type EmployeeUpsertWithoutContractsInput = {
    update: XOR<EmployeeUpdateWithoutContractsInput, EmployeeUncheckedUpdateWithoutContractsInput>
    create: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutContractsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutContractsInput, EmployeeUncheckedUpdateWithoutContractsInput>
  }

  export type EmployeeUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
    person?: PersonUpdateOneRequiredWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    schedule?: ScheduleUpdateOneWithoutEmployeesNestedInput
    attendances?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type CompanyCreateWithoutPayrollPeriodsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPayrollPeriodsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollLines?: PayrollLineUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPayrollPeriodsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPayrollPeriodsInput, CompanyUncheckedCreateWithoutPayrollPeriodsInput>
  }

  export type UserCreateWithoutPayrollPeriodClosuresInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    person?: PersonCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    attendance?: AttendanceCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestCreateNestedManyWithoutValidatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPayrollPeriodClosuresInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    companyId: string
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    overtimeRequests?: OvertimeUncheckedCreateNestedManyWithoutUserInput
    overtimeApprovals?: OvertimeUncheckedCreateNestedManyWithoutApprovedByInput
    studentAttendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutRecordedByInput
    attendanceValidations?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutValidatedByInput
    leaveValidations?: LeaveRequestUncheckedCreateNestedManyWithoutValidatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPayrollPeriodClosuresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPayrollPeriodClosuresInput, UserUncheckedCreateWithoutPayrollPeriodClosuresInput>
  }

  export type PayrollLineCreateWithoutPayrollPeriodInput = {
    id?: string
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutPayrollLinesInput
    employee: EmployeeCreateNestedOneWithoutPayrollLinesInput
  }

  export type PayrollLineUncheckedCreateWithoutPayrollPeriodInput = {
    id?: string
    companyId: string
    employeeId: string
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PayrollLineCreateOrConnectWithoutPayrollPeriodInput = {
    where: PayrollLineWhereUniqueInput
    create: XOR<PayrollLineCreateWithoutPayrollPeriodInput, PayrollLineUncheckedCreateWithoutPayrollPeriodInput>
  }

  export type PayrollLineCreateManyPayrollPeriodInputEnvelope = {
    data: PayrollLineCreateManyPayrollPeriodInput | PayrollLineCreateManyPayrollPeriodInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutPayrollPeriodsInput = {
    update: XOR<CompanyUpdateWithoutPayrollPeriodsInput, CompanyUncheckedUpdateWithoutPayrollPeriodsInput>
    create: XOR<CompanyCreateWithoutPayrollPeriodsInput, CompanyUncheckedCreateWithoutPayrollPeriodsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPayrollPeriodsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPayrollPeriodsInput, CompanyUncheckedUpdateWithoutPayrollPeriodsInput>
  }

  export type CompanyUpdateWithoutPayrollPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPayrollPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutPayrollPeriodClosuresInput = {
    update: XOR<UserUpdateWithoutPayrollPeriodClosuresInput, UserUncheckedUpdateWithoutPayrollPeriodClosuresInput>
    create: XOR<UserCreateWithoutPayrollPeriodClosuresInput, UserUncheckedCreateWithoutPayrollPeriodClosuresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPayrollPeriodClosuresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPayrollPeriodClosuresInput, UserUncheckedUpdateWithoutPayrollPeriodClosuresInput>
  }

  export type UserUpdateWithoutPayrollPeriodClosuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUpdateManyWithoutValidatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPayrollPeriodClosuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUncheckedUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUncheckedUpdateManyWithoutValidatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PayrollLineUpsertWithWhereUniqueWithoutPayrollPeriodInput = {
    where: PayrollLineWhereUniqueInput
    update: XOR<PayrollLineUpdateWithoutPayrollPeriodInput, PayrollLineUncheckedUpdateWithoutPayrollPeriodInput>
    create: XOR<PayrollLineCreateWithoutPayrollPeriodInput, PayrollLineUncheckedCreateWithoutPayrollPeriodInput>
  }

  export type PayrollLineUpdateWithWhereUniqueWithoutPayrollPeriodInput = {
    where: PayrollLineWhereUniqueInput
    data: XOR<PayrollLineUpdateWithoutPayrollPeriodInput, PayrollLineUncheckedUpdateWithoutPayrollPeriodInput>
  }

  export type PayrollLineUpdateManyWithWhereWithoutPayrollPeriodInput = {
    where: PayrollLineScalarWhereInput
    data: XOR<PayrollLineUpdateManyMutationInput, PayrollLineUncheckedUpdateManyWithoutPayrollPeriodInput>
  }

  export type CompanyCreateWithoutPayrollLinesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    persons?: PersonCreateNestedManyWithoutCompanyInput
    employees?: EmployeeCreateNestedManyWithoutCompanyInput
    workers?: WorkerCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutCompanyInput
    contracts?: ContractCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportCreateNestedManyWithoutCompanyInput
    reports?: ReportCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassCreateNestedManyWithoutCompanyInput
    courses?: CourseCreateNestedManyWithoutCompanyInput
    students?: StudentCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
    devices?: DeviceCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPayrollLinesInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.CompanyType
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    persons?: PersonUncheckedCreateNestedManyWithoutCompanyInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutCompanyInput
    workers?: WorkerUncheckedCreateNestedManyWithoutCompanyInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutCompanyInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutCompanyInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutCompanyInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    overtime?: OvertimeUncheckedCreateNestedManyWithoutCompanyInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutCompanyInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutCompanyInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutCompanyInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCompanyInput
    payrollExports?: PayrollExportUncheckedCreateNestedManyWithoutCompanyInput
    reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    schoolClasses?: SchoolClassUncheckedCreateNestedManyWithoutCompanyInput
    courses?: CourseUncheckedCreateNestedManyWithoutCompanyInput
    students?: StudentUncheckedCreateNestedManyWithoutCompanyInput
    studentAttendance?: StudentAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutCompanyInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutCompanyInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutCompanyInput
    publicHolidays?: PublicHolidayUncheckedCreateNestedManyWithoutCompanyInput
    constructionSites?: ConstructionSiteUncheckedCreateNestedManyWithoutCompanyInput
    constructionTeams?: ConstructionTeamUncheckedCreateNestedManyWithoutCompanyInput
    constructionWorkers?: ConstructionWorkerUncheckedCreateNestedManyWithoutCompanyInput
    siteAttendance?: SiteAttendanceUncheckedCreateNestedManyWithoutCompanyInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
    devices?: DeviceUncheckedCreateNestedManyWithoutCompanyInput
    periodClosures?: PeriodClosureUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPayrollLinesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPayrollLinesInput, CompanyUncheckedCreateWithoutPayrollLinesInput>
  }

  export type PayrollPeriodCreateWithoutLinesInput = {
    id?: string
    month: number
    year: number
    isClosed?: boolean
    closedAt?: Date | string | null
    deletedAt?: Date | string | null
    company: CompanyCreateNestedOneWithoutPayrollPeriodsInput
    closedBy?: UserCreateNestedOneWithoutPayrollPeriodClosuresInput
  }

  export type PayrollPeriodUncheckedCreateWithoutLinesInput = {
    id?: string
    month: number
    year: number
    companyId: string
    isClosed?: boolean
    closedAt?: Date | string | null
    closedByUserId?: string | null
    deletedAt?: Date | string | null
  }

  export type PayrollPeriodCreateOrConnectWithoutLinesInput = {
    where: PayrollPeriodWhereUniqueInput
    create: XOR<PayrollPeriodCreateWithoutLinesInput, PayrollPeriodUncheckedCreateWithoutLinesInput>
  }

  export type EmployeeCreateWithoutPayrollLinesInput = {
    id?: string
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutEmployeesInput
    person: PersonCreateNestedOneWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    schedule?: ScheduleCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryCreateNestedManyWithoutEmployeeInput
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPayrollLinesInput = {
    id?: string
    companyId: string
    personId: string
    userId?: string | null
    scheduleId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    attendances?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    dailySummaries?: AttendanceDailySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaveBalances?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    leaveRequests?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPayrollLinesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPayrollLinesInput, EmployeeUncheckedCreateWithoutPayrollLinesInput>
  }

  export type CompanyUpsertWithoutPayrollLinesInput = {
    update: XOR<CompanyUpdateWithoutPayrollLinesInput, CompanyUncheckedUpdateWithoutPayrollLinesInput>
    create: XOR<CompanyCreateWithoutPayrollLinesInput, CompanyUncheckedCreateWithoutPayrollLinesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPayrollLinesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPayrollLinesInput, CompanyUncheckedUpdateWithoutPayrollLinesInput>
  }

  export type CompanyUpdateWithoutPayrollLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    persons?: PersonUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUpdateManyWithoutCompanyNestedInput
    reports?: ReportUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUpdateManyWithoutCompanyNestedInput
    courses?: CourseUpdateManyWithoutCompanyNestedInput
    students?: StudentUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPayrollLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCompanyTypeFieldUpdateOperationsInput | $Enums.CompanyType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    persons?: PersonUncheckedUpdateManyWithoutCompanyNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutCompanyNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceDailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    overtime?: OvertimeUncheckedUpdateManyWithoutCompanyNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutCompanyNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutCompanyNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutCompanyNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCompanyNestedInput
    payrollExports?: PayrollExportUncheckedUpdateManyWithoutCompanyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    schoolClasses?: SchoolClassUncheckedUpdateManyWithoutCompanyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCompanyNestedInput
    students?: StudentUncheckedUpdateManyWithoutCompanyNestedInput
    studentAttendance?: StudentAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutCompanyNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutCompanyNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutCompanyNestedInput
    publicHolidays?: PublicHolidayUncheckedUpdateManyWithoutCompanyNestedInput
    constructionSites?: ConstructionSiteUncheckedUpdateManyWithoutCompanyNestedInput
    constructionTeams?: ConstructionTeamUncheckedUpdateManyWithoutCompanyNestedInput
    constructionWorkers?: ConstructionWorkerUncheckedUpdateManyWithoutCompanyNestedInput
    siteAttendance?: SiteAttendanceUncheckedUpdateManyWithoutCompanyNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutCompanyNestedInput
    periodClosures?: PeriodClosureUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PayrollPeriodUpsertWithoutLinesInput = {
    update: XOR<PayrollPeriodUpdateWithoutLinesInput, PayrollPeriodUncheckedUpdateWithoutLinesInput>
    create: XOR<PayrollPeriodCreateWithoutLinesInput, PayrollPeriodUncheckedCreateWithoutLinesInput>
    where?: PayrollPeriodWhereInput
  }

  export type PayrollPeriodUpdateToOneWithWhereWithoutLinesInput = {
    where?: PayrollPeriodWhereInput
    data: XOR<PayrollPeriodUpdateWithoutLinesInput, PayrollPeriodUncheckedUpdateWithoutLinesInput>
  }

  export type PayrollPeriodUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPayrollPeriodsNestedInput
    closedBy?: UserUpdateOneWithoutPayrollPeriodClosuresNestedInput
  }

  export type PayrollPeriodUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeUpsertWithoutPayrollLinesInput = {
    update: XOR<EmployeeUpdateWithoutPayrollLinesInput, EmployeeUncheckedUpdateWithoutPayrollLinesInput>
    create: XOR<EmployeeCreateWithoutPayrollLinesInput, EmployeeUncheckedCreateWithoutPayrollLinesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPayrollLinesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPayrollLinesInput, EmployeeUncheckedUpdateWithoutPayrollLinesInput>
  }

  export type EmployeeUpdateWithoutPayrollLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
    person?: PersonUpdateOneRequiredWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    schedule?: ScheduleUpdateOneWithoutEmployeesNestedInput
    attendances?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPayrollLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    isActive?: boolean
    personId?: string | null
    refreshTokenHash?: string | null
    refreshTokenExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonCreateManyCompanyInput = {
    id?: string
    firstName: string
    lastName: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmployeeCreateManyCompanyInput = {
    id?: string
    personId: string
    userId?: string | null
    scheduleId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WorkerCreateManyCompanyInput = {
    id?: string
    personId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateManyCompanyInput = {
    id?: string
    userId: string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceEventCreateManyCompanyInput = {
    id?: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    employeeId?: string | null
    studentId?: string | null
    workerId?: string | null
    deviceId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceDailySummaryCreateManyCompanyInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    employeeId?: string | null
    studentId?: string | null
    workerId?: string | null
    validatedByUserId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ScheduleCreateManyCompanyInput = {
    id?: string
    name: string
    startTime: string
    endTime: string
    daysOfWeek?: ScheduleCreatedaysOfWeekInput | string[]
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeCreateManyCompanyInput = {
    id?: string
    userId: string
    date: Date | string
    hours: number
    reason?: string | null
    status?: $Enums.OvertimeStatus
    approvedByUserId?: string | null
    approvedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceSummaryCreateManyCompanyInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    totalHours: number
    overtimeHours: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateManyCompanyInput = {
    id?: string
    attendanceSummaryId: string
    periodStart: Date | string
    periodEnd: Date | string
    grossPay: number
    netPay: number
    status?: $Enums.PayrollStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollPeriodCreateManyCompanyInput = {
    id?: string
    month: number
    year: number
    isClosed?: boolean
    closedAt?: Date | string | null
    closedByUserId?: string | null
    deletedAt?: Date | string | null
  }

  export type PayrollLineCreateManyCompanyInput = {
    id?: string
    payrollPeriodId: string
    employeeId: string
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ContractCreateManyCompanyInput = {
    id?: string
    employeeId: string
    salaryType: $Enums.SalaryType
    baseSalary: number
    hourlyRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type PayrollExportCreateManyCompanyInput = {
    id?: string
    payrollId: string
    format: $Enums.ExportFormat
    path: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateManyCompanyInput = {
    id?: string
    type: $Enums.ReportType
    periodStart: Date | string
    periodEnd: Date | string
    data: JsonNullValueInput | InputJsonValue
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolClassCreateManyCompanyInput = {
    id?: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreateManyCompanyInput = {
    id?: string
    classId: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyCompanyInput = {
    id?: string
    classId: string
    firstName: string
    lastName: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateManyCompanyInput = {
    id?: string
    studentId: string
    date: Date | string
    status: $Enums.StudentAttendanceStatus
    note?: string | null
    recordedByUserId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveTypeCreateManyCompanyInput = {
    id?: string
    name: string
    code: string
    isPaid: boolean
    maxDaysYear?: number | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LeaveBalanceCreateManyCompanyInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    year: number
    totalDays: number
    usedDays?: number
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateManyCompanyInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    validatedByUserId?: string | null
    deletedAt?: Date | string | null
  }

  export type PublicHolidayCreateManyCompanyInput = {
    id?: string
    date: Date | string
    name: string
    country: string
    deletedAt?: Date | string | null
  }

  export type ConstructionSiteCreateManyCompanyInput = {
    id?: string
    name: string
    location?: string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConstructionTeamCreateManyCompanyInput = {
    id?: string
    siteId: string
    name: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConstructionWorkerCreateManyCompanyInput = {
    id?: string
    teamId: string
    name: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteAttendanceCreateManyCompanyInput = {
    id?: string
    siteId: string
    workerId: string
    date: Date | string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyCompanyInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    actionType?: $Enums.AuditAction | null
    entityType?: $Enums.AuditEntity | null
    ip?: string | null
    userId?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserRoleCreateManyCompanyInput = {
    id?: string
    role: $Enums.Role
    userId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DeviceCreateManyCompanyInput = {
    id?: string
    uuid: string
    platform: string
    model: string
    personId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PeriodClosureCreateManyCompanyInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    closedAt?: Date | string
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    overtimeRequests?: OvertimeUncheckedUpdateManyWithoutUserNestedInput
    overtimeApprovals?: OvertimeUncheckedUpdateManyWithoutApprovedByNestedInput
    studentAttendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutRecordedByNestedInput
    attendanceValidations?: AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByNestedInput
    leaveValidations?: LeaveRequestUncheckedUpdateManyWithoutValidatedByNestedInput
    payrollPeriodClosures?: PayrollPeriodUncheckedUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutPersonNestedInput
    employee?: EmployeeUpdateOneWithoutPersonNestedInput
    student?: StudentUpdateOneWithoutPersonNestedInput
    worker?: WorkerUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUpdateOneWithoutPersonNestedInput
    devices?: DeviceUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateOneWithoutPersonNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutPersonNestedInput
    student?: StudentUncheckedUpdateOneWithoutPersonNestedInput
    worker?: WorkerUncheckedUpdateOneWithoutPersonNestedInput
    constructionWorker?: ConstructionWorkerUncheckedUpdateOneWithoutPersonNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    schedule?: ScheduleUpdateOneWithoutEmployeesNestedInput
    attendances?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutWorkerNestedInput
    attendances?: AttendanceEventUpdateManyWithoutWorkerNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutWorkerNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneWithoutAttendancesNestedInput
    student?: StudentUpdateOneWithoutAttendanceEventsNestedInput
    worker?: WorkerUpdateOneWithoutAttendancesNestedInput
    device?: DeviceUpdateOneWithoutAttendanceEventsNestedInput
  }

  export type AttendanceEventUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceEventUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDailySummaryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneWithoutDailySummariesNestedInput
    student?: StudentUpdateOneWithoutDailySummariesNestedInput
    worker?: WorkerUpdateOneWithoutDailySummariesNestedInput
    validatedBy?: UserUpdateOneWithoutAttendanceValidationsNestedInput
  }

  export type AttendanceDailySummaryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDailySummaryUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduleUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduleUpdatedaysOfWeekInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduleUpdatedaysOfWeekInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduleUpdatedaysOfWeekInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOvertimeRequestsNestedInput
    approvedBy?: UserUpdateOneWithoutOvertimeApprovalsNestedInput
  }

  export type OvertimeUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSummaryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrolls?: PayrollUpdateManyWithoutAttendanceSummaryNestedInput
  }

  export type AttendanceSummaryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrolls?: PayrollUncheckedUpdateManyWithoutAttendanceSummaryNestedInput
  }

  export type AttendanceSummaryUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossPay?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceSummary?: AttendanceSummaryUpdateOneRequiredWithoutPayrollsNestedInput
    exports?: PayrollExportUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceSummaryId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossPay?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exports?: PayrollExportUncheckedUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attendanceSummaryId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossPay?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollPeriodUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: UserUpdateOneWithoutPayrollPeriodClosuresNestedInput
    lines?: PayrollLineUpdateManyWithoutPayrollPeriodNestedInput
  }

  export type PayrollPeriodUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: PayrollLineUncheckedUpdateManyWithoutPayrollPeriodNestedInput
  }

  export type PayrollPeriodUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollLineUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateMinutes?: IntFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollPeriod?: PayrollPeriodUpdateOneRequiredWithoutLinesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutPayrollLinesNestedInput
  }

  export type PayrollLineUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    payrollPeriodId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateMinutes?: IntFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollLineUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    payrollPeriodId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateMinutes?: IntFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    salaryType?: EnumSalaryTypeFieldUpdateOperationsInput | $Enums.SalaryType
    baseSalary?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutContractsNestedInput
  }

  export type ContractUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    salaryType?: EnumSalaryTypeFieldUpdateOperationsInput | $Enums.SalaryType
    baseSalary?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    salaryType?: EnumSalaryTypeFieldUpdateOperationsInput | $Enums.SalaryType
    baseSalary?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollExportUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    path?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payroll?: PayrollUpdateOneRequiredWithoutExportsNestedInput
  }

  export type PayrollExportUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    payrollId?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    path?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollExportUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    payrollId?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    path?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolClassUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
  }

  export type SchoolClassUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SchoolClassUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: SchoolClassUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: SchoolClassUpdateOneRequiredWithoutStudentsNestedInput
    person?: PersonUpdateOneWithoutStudentNestedInput
    attendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutStudentNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutStudentNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentAttendanceStatusFieldUpdateOperationsInput | $Enums.StudentAttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendanceNestedInput
    recordedBy?: UserUpdateOneWithoutStudentAttendanceRecordsNestedInput
  }

  export type StudentAttendanceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentAttendanceStatusFieldUpdateOperationsInput | $Enums.StudentAttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentAttendanceStatusFieldUpdateOperationsInput | $Enums.StudentAttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveTypeUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    maxDaysYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balances?: LeaveBalanceUpdateManyWithoutLeaveTypeNestedInput
    requests?: LeaveRequestUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    maxDaysYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balances?: LeaveBalanceUncheckedUpdateManyWithoutLeaveTypeNestedInput
    requests?: LeaveRequestUncheckedUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    maxDaysYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveBalanceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutLeaveBalancesNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type LeaveBalanceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutLeaveRequestsNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutRequestsNestedInput
    validatedBy?: UserUpdateOneWithoutLeaveValidationsNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PublicHolidayUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PublicHolidayUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PublicHolidayUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConstructionSiteUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: ConstructionTeamUpdateManyWithoutSiteNestedInput
    attendance?: SiteAttendanceUpdateManyWithoutSiteNestedInput
  }

  export type ConstructionSiteUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: ConstructionTeamUncheckedUpdateManyWithoutSiteNestedInput
    attendance?: SiteAttendanceUncheckedUpdateManyWithoutSiteNestedInput
  }

  export type ConstructionSiteUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConstructionTeamUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: ConstructionSiteUpdateOneRequiredWithoutTeamsNestedInput
    workers?: ConstructionWorkerUpdateManyWithoutTeamNestedInput
  }

  export type ConstructionTeamUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workers?: ConstructionWorkerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ConstructionTeamUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConstructionWorkerUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: ConstructionTeamUpdateOneRequiredWithoutWorkersNestedInput
    person?: PersonUpdateOneWithoutConstructionWorkerNestedInput
    attendance?: SiteAttendanceUpdateManyWithoutWorkerNestedInput
  }

  export type ConstructionWorkerUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: SiteAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type ConstructionWorkerUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteAttendanceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    site?: ConstructionSiteUpdateOneRequiredWithoutAttendanceNestedInput
    worker?: ConstructionWorkerUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type SiteAttendanceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteAttendanceUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: NullableEnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction | null
    entityType?: NullableEnumAuditEntityFieldUpdateOperationsInput | $Enums.AuditEntity | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: NullableEnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction | null
    entityType?: NullableEnumAuditEntityFieldUpdateOperationsInput | $Enums.AuditEntity | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: NullableEnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction | null
    entityType?: NullableEnumAuditEntityFieldUpdateOperationsInput | $Enums.AuditEntity | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    person?: PersonUpdateOneRequiredWithoutDevicesNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodClosureUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodClosureUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodClosureUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyUserInput = {
    id?: string
    companyId: string
    role: $Enums.Role
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateManyUserInput = {
    id?: string
    companyId: string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeCreateManyUserInput = {
    id?: string
    companyId: string
    date: Date | string
    hours: number
    reason?: string | null
    status?: $Enums.OvertimeStatus
    approvedByUserId?: string | null
    approvedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeCreateManyApprovedByInput = {
    id?: string
    companyId: string
    userId: string
    date: Date | string
    hours: number
    reason?: string | null
    status?: $Enums.OvertimeStatus
    approvedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAttendanceCreateManyRecordedByInput = {
    id?: string
    companyId: string
    studentId: string
    date: Date | string
    status: $Enums.StudentAttendanceStatus
    note?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceDailySummaryCreateManyValidatedByInput = {
    id?: string
    companyId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    employeeId?: string | null
    studentId?: string | null
    workerId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateManyValidatedByInput = {
    id?: string
    companyId: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type PayrollPeriodCreateManyClosedByInput = {
    id?: string
    month: number
    year: number
    companyId: string
    isClosed?: boolean
    closedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    companyId: string
    action: string
    entity: string
    entityId: string
    actionType?: $Enums.AuditAction | null
    entityType?: $Enums.AuditEntity | null
    ip?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutOvertimeNestedInput
    approvedBy?: UserUpdateOneWithoutOvertimeApprovalsNestedInput
  }

  export type OvertimeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutOvertimeNestedInput
    user?: UserUpdateOneRequiredWithoutOvertimeRequestsNestedInput
  }

  export type OvertimeUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentAttendanceStatusFieldUpdateOperationsInput | $Enums.StudentAttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStudentAttendanceNestedInput
    student?: StudentUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type StudentAttendanceUncheckedUpdateWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentAttendanceStatusFieldUpdateOperationsInput | $Enums.StudentAttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutRecordedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentAttendanceStatusFieldUpdateOperationsInput | $Enums.StudentAttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDailySummaryUpdateWithoutValidatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutAttendanceDailySummariesNestedInput
    employee?: EmployeeUpdateOneWithoutDailySummariesNestedInput
    student?: StudentUpdateOneWithoutDailySummariesNestedInput
    worker?: WorkerUpdateOneWithoutDailySummariesNestedInput
  }

  export type AttendanceDailySummaryUncheckedUpdateWithoutValidatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDailySummaryUncheckedUpdateManyWithoutValidatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUpdateWithoutValidatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutLeaveRequestsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLeaveRequestsNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutRequestsNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutValidatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUncheckedUpdateManyWithoutValidatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollPeriodUpdateWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutPayrollPeriodsNestedInput
    lines?: PayrollLineUpdateManyWithoutPayrollPeriodNestedInput
  }

  export type PayrollPeriodUncheckedUpdateWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: PayrollLineUncheckedUpdateManyWithoutPayrollPeriodNestedInput
  }

  export type PayrollPeriodUncheckedUpdateManyWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: NullableEnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction | null
    entityType?: NullableEnumAuditEntityFieldUpdateOperationsInput | $Enums.AuditEntity | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: NullableEnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction | null
    entityType?: NullableEnumAuditEntityFieldUpdateOperationsInput | $Enums.AuditEntity | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    actionType?: NullableEnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction | null
    entityType?: NullableEnumAuditEntityFieldUpdateOperationsInput | $Enums.AuditEntity | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyScheduleInput = {
    id?: string
    companyId: string
    personId: string
    userId?: string | null
    matricule?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type EmployeeUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
    person?: PersonUpdateOneRequiredWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    attendances?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollLines?: PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveBalances?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveRequests?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateManyAttendanceSummaryInput = {
    id?: string
    companyId: string
    periodStart: Date | string
    periodEnd: Date | string
    grossPay: number
    netPay: number
    status?: $Enums.PayrollStatus
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateWithoutAttendanceSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossPay?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPayrollsNestedInput
    exports?: PayrollExportUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateWithoutAttendanceSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossPay?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exports?: PayrollExportUncheckedUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateManyWithoutAttendanceSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossPay?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollExportCreateManyPayrollInput = {
    id?: string
    companyId: string
    format: $Enums.ExportFormat
    path: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollExportUpdateWithoutPayrollInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    path?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPayrollExportsNestedInput
  }

  export type PayrollExportUncheckedUpdateWithoutPayrollInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    path?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollExportUncheckedUpdateManyWithoutPayrollInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    format?: EnumExportFormatFieldUpdateOperationsInput | $Enums.ExportFormat
    path?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateManyClassInput = {
    id?: string
    companyId: string
    name: string
    code: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyClassInput = {
    id?: string
    companyId: string
    firstName: string
    lastName: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStudentsNestedInput
    person?: PersonUpdateOneWithoutStudentNestedInput
    attendance?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutStudentNestedInput
    dailySummaries?: AttendanceDailySummaryUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutStudentNestedInput
    dailySummaries?: AttendanceDailySummaryUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceCreateManyStudentInput = {
    id?: string
    companyId: string
    date: Date | string
    status: $Enums.StudentAttendanceStatus
    note?: string | null
    recordedByUserId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceEventCreateManyStudentInput = {
    id?: string
    companyId: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    employeeId?: string | null
    workerId?: string | null
    deviceId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceDailySummaryCreateManyStudentInput = {
    id?: string
    companyId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    employeeId?: string | null
    workerId?: string | null
    validatedByUserId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StudentAttendanceUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentAttendanceStatusFieldUpdateOperationsInput | $Enums.StudentAttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStudentAttendanceNestedInput
    recordedBy?: UserUpdateOneWithoutStudentAttendanceRecordsNestedInput
  }

  export type StudentAttendanceUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentAttendanceStatusFieldUpdateOperationsInput | $Enums.StudentAttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStudentAttendanceStatusFieldUpdateOperationsInput | $Enums.StudentAttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutAttendanceEventsNestedInput
    employee?: EmployeeUpdateOneWithoutAttendancesNestedInput
    worker?: WorkerUpdateOneWithoutAttendancesNestedInput
    device?: DeviceUpdateOneWithoutAttendanceEventsNestedInput
  }

  export type AttendanceEventUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceEventUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDailySummaryUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutAttendanceDailySummariesNestedInput
    employee?: EmployeeUpdateOneWithoutDailySummariesNestedInput
    worker?: WorkerUpdateOneWithoutDailySummariesNestedInput
    validatedBy?: UserUpdateOneWithoutAttendanceValidationsNestedInput
  }

  export type AttendanceDailySummaryUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDailySummaryUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConstructionTeamCreateManySiteInput = {
    id?: string
    companyId: string
    name: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteAttendanceCreateManySiteInput = {
    id?: string
    companyId: string
    workerId: string
    date: Date | string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConstructionTeamUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutConstructionTeamsNestedInput
    workers?: ConstructionWorkerUpdateManyWithoutTeamNestedInput
  }

  export type ConstructionTeamUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workers?: ConstructionWorkerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ConstructionTeamUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteAttendanceUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSiteAttendanceNestedInput
    worker?: ConstructionWorkerUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type SiteAttendanceUncheckedUpdateWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteAttendanceUncheckedUpdateManyWithoutSiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    workerId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConstructionWorkerCreateManyTeamInput = {
    id?: string
    companyId: string
    name: string
    email?: string | null
    personId?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConstructionWorkerUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutConstructionWorkersNestedInput
    person?: PersonUpdateOneWithoutConstructionWorkerNestedInput
    attendance?: SiteAttendanceUpdateManyWithoutWorkerNestedInput
  }

  export type ConstructionWorkerUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: SiteAttendanceUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type ConstructionWorkerUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteAttendanceCreateManyWorkerInput = {
    id?: string
    companyId: string
    siteId: string
    date: Date | string
    checkInAt: Date | string
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteAttendanceUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSiteAttendanceNestedInput
    site?: ConstructionSiteUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type SiteAttendanceUncheckedUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteAttendanceUncheckedUpdateManyWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    siteId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateManyPersonInput = {
    id?: string
    uuid: string
    platform: string
    model: string
    companyId: string
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DeviceUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceEvents?: AttendanceEventUpdateManyWithoutDeviceNestedInput
    company?: CompanyUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type DeviceUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateManyWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventCreateManyEmployeeInput = {
    id?: string
    companyId: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    studentId?: string | null
    workerId?: string | null
    deviceId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceDailySummaryCreateManyEmployeeInput = {
    id?: string
    companyId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    studentId?: string | null
    workerId?: string | null
    validatedByUserId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PayrollLineCreateManyEmployeeInput = {
    id?: string
    companyId: string
    payrollPeriodId: string
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ContractCreateManyEmployeeInput = {
    id?: string
    companyId: string
    salaryType: $Enums.SalaryType
    baseSalary: number
    hourlyRate?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LeaveBalanceCreateManyEmployeeInput = {
    id?: string
    companyId: string
    leaveTypeId: string
    year: number
    totalDays: number
    usedDays?: number
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateManyEmployeeInput = {
    id?: string
    companyId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    validatedByUserId?: string | null
    deletedAt?: Date | string | null
  }

  export type AttendanceEventUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutAttendanceEventsNestedInput
    student?: StudentUpdateOneWithoutAttendanceEventsNestedInput
    worker?: WorkerUpdateOneWithoutAttendancesNestedInput
    device?: DeviceUpdateOneWithoutAttendanceEventsNestedInput
  }

  export type AttendanceEventUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceEventUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDailySummaryUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutAttendanceDailySummariesNestedInput
    student?: StudentUpdateOneWithoutDailySummariesNestedInput
    worker?: WorkerUpdateOneWithoutDailySummariesNestedInput
    validatedBy?: UserUpdateOneWithoutAttendanceValidationsNestedInput
  }

  export type AttendanceDailySummaryUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDailySummaryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollLineUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateMinutes?: IntFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPayrollLinesNestedInput
    payrollPeriod?: PayrollPeriodUpdateOneRequiredWithoutLinesNestedInput
  }

  export type PayrollLineUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    payrollPeriodId?: StringFieldUpdateOperationsInput | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateMinutes?: IntFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollLineUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    payrollPeriodId?: StringFieldUpdateOperationsInput | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateMinutes?: IntFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    salaryType?: EnumSalaryTypeFieldUpdateOperationsInput | $Enums.SalaryType
    baseSalary?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutContractsNestedInput
  }

  export type ContractUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    salaryType?: EnumSalaryTypeFieldUpdateOperationsInput | $Enums.SalaryType
    baseSalary?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContractUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    salaryType?: EnumSalaryTypeFieldUpdateOperationsInput | $Enums.SalaryType
    baseSalary?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveBalanceUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutLeaveBalancesNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type LeaveBalanceUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutLeaveRequestsNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutRequestsNestedInput
    validatedBy?: UserUpdateOneWithoutLeaveValidationsNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceEventCreateManyWorkerInput = {
    id?: string
    companyId: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    employeeId?: string | null
    studentId?: string | null
    deviceId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceDailySummaryCreateManyWorkerInput = {
    id?: string
    companyId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    lateMinutes?: number | null
    earlyMinutes?: number | null
    workedMinutes?: number | null
    employeeId?: string | null
    studentId?: string | null
    validatedByUserId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceEventUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutAttendanceEventsNestedInput
    employee?: EmployeeUpdateOneWithoutAttendancesNestedInput
    student?: StudentUpdateOneWithoutAttendanceEventsNestedInput
    device?: DeviceUpdateOneWithoutAttendanceEventsNestedInput
  }

  export type AttendanceEventUncheckedUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceEventUncheckedUpdateManyWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDailySummaryUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutAttendanceDailySummariesNestedInput
    employee?: EmployeeUpdateOneWithoutDailySummariesNestedInput
    student?: StudentUpdateOneWithoutDailySummariesNestedInput
    validatedBy?: UserUpdateOneWithoutAttendanceValidationsNestedInput
  }

  export type AttendanceDailySummaryUncheckedUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceDailySummaryUncheckedUpdateManyWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    lateMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    earlyMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    workedMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceEventCreateManyDeviceInput = {
    id?: string
    companyId: string
    type: $Enums.AttendanceType
    timestamp: Date | string
    date: Date | string
    personType: $Enums.PersonType
    employeeId?: string | null
    studentId?: string | null
    workerId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttendanceEventUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutAttendanceEventsNestedInput
    employee?: EmployeeUpdateOneWithoutAttendancesNestedInput
    student?: StudentUpdateOneWithoutAttendanceEventsNestedInput
    worker?: WorkerUpdateOneWithoutAttendancesNestedInput
  }

  export type AttendanceEventUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceEventUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveBalanceCreateManyLeaveTypeInput = {
    id?: string
    companyId: string
    employeeId: string
    year: number
    totalDays: number
    usedDays?: number
    deletedAt?: Date | string | null
  }

  export type LeaveRequestCreateManyLeaveTypeInput = {
    id?: string
    companyId: string
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    days: number
    status: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    validatedAt?: Date | string | null
    validatedByUserId?: string | null
    deletedAt?: Date | string | null
  }

  export type LeaveBalanceUpdateWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutLeaveBalancesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLeaveBalancesNestedInput
  }

  export type LeaveBalanceUncheckedUpdateWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUpdateWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutLeaveRequestsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLeaveRequestsNestedInput
    validatedBy?: UserUpdateOneWithoutLeaveValidationsNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUncheckedUpdateManyWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollLineCreateManyPayrollPeriodInput = {
    id?: string
    companyId: string
    employeeId: string
    workedDays: number
    absentDays: number
    lateMinutes: number
    overtimeHours: number
    grossSalary: number
    deductions: number
    netSalary: number
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PayrollLineUpdateWithoutPayrollPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateMinutes?: IntFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPayrollLinesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutPayrollLinesNestedInput
  }

  export type PayrollLineUncheckedUpdateWithoutPayrollPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateMinutes?: IntFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollLineUncheckedUpdateManyWithoutPayrollPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateMinutes?: IntFieldUpdateOperationsInput | number
    overtimeHours?: FloatFieldUpdateOperationsInput | number
    grossSalary?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netSalary?: FloatFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}